//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Package-scope variables */
var _, exports;

(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                       //
// packages/underscore/pre.js                                                                            //
//                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                         //
// Define an object named exports. This will cause underscore.js to put `_` as a                         // 1
// field on it, instead of in the global namespace.  See also post.js.                                   // 2
exports = {};                                                                                            // 3
                                                                                                         // 4
///////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                       //
// packages/underscore/underscore.js                                                                     //
//                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                         //
//     Underscore.js 1.5.2                                                                               // 1
//     http://underscorejs.org                                                                           // 2
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors                // 3
//     Underscore may be freely distributed under the MIT license.                                       // 4
                                                                                                         // 5
(function() {                                                                                            // 6
                                                                                                         // 7
  // Baseline setup                                                                                      // 8
  // --------------                                                                                      // 9
                                                                                                         // 10
  // Establish the root object, `window` in the browser, or `exports` on the server.                     // 11
  var root = this;                                                                                       // 12
                                                                                                         // 13
  // Save the previous value of the `_` variable.                                                        // 14
  var previousUnderscore = root._;                                                                       // 15
                                                                                                         // 16
  // Establish the object that gets returned to break out of a loop iteration.                           // 17
  var breaker = {};                                                                                      // 18
                                                                                                         // 19
  // Save bytes in the minified (but not gzipped) version:                                               // 20
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;         // 21
                                                                                                         // 22
  // Create quick reference variables for speed access to core prototypes.                               // 23
  var                                                                                                    // 24
    push             = ArrayProto.push,                                                                  // 25
    slice            = ArrayProto.slice,                                                                 // 26
    concat           = ArrayProto.concat,                                                                // 27
    toString         = ObjProto.toString,                                                                // 28
    hasOwnProperty   = ObjProto.hasOwnProperty;                                                          // 29
                                                                                                         // 30
  // All **ECMAScript 5** native function implementations that we hope to use                            // 31
  // are declared here.                                                                                  // 32
  var                                                                                                    // 33
    nativeForEach      = ArrayProto.forEach,                                                             // 34
    nativeMap          = ArrayProto.map,                                                                 // 35
    nativeReduce       = ArrayProto.reduce,                                                              // 36
    nativeReduceRight  = ArrayProto.reduceRight,                                                         // 37
    nativeFilter       = ArrayProto.filter,                                                              // 38
    nativeEvery        = ArrayProto.every,                                                               // 39
    nativeSome         = ArrayProto.some,                                                                // 40
    nativeIndexOf      = ArrayProto.indexOf,                                                             // 41
    nativeLastIndexOf  = ArrayProto.lastIndexOf,                                                         // 42
    nativeIsArray      = Array.isArray,                                                                  // 43
    nativeKeys         = Object.keys,                                                                    // 44
    nativeBind         = FuncProto.bind;                                                                 // 45
                                                                                                         // 46
  // Create a safe reference to the Underscore object for use below.                                     // 47
  var _ = function(obj) {                                                                                // 48
    if (obj instanceof _) return obj;                                                                    // 49
    if (!(this instanceof _)) return new _(obj);                                                         // 50
    this._wrapped = obj;                                                                                 // 51
  };                                                                                                     // 52
                                                                                                         // 53
  // Export the Underscore object for **Node.js**, with                                                  // 54
  // backwards-compatibility for the old `require()` API. If we're in                                    // 55
  // the browser, add `_` as a global object via a string identifier,                                    // 56
  // for Closure Compiler "advanced" mode.                                                               // 57
  if (typeof exports !== 'undefined') {                                                                  // 58
    if (typeof module !== 'undefined' && module.exports) {                                               // 59
      exports = module.exports = _;                                                                      // 60
    }                                                                                                    // 61
    exports._ = _;                                                                                       // 62
  } else {                                                                                               // 63
    root._ = _;                                                                                          // 64
  }                                                                                                      // 65
                                                                                                         // 66
  // Current version.                                                                                    // 67
  _.VERSION = '1.5.2';                                                                                   // 68
                                                                                                         // 69
  // Collection Functions                                                                                // 70
  // --------------------                                                                                // 71
                                                                                                         // 72
  // METEOR CHANGE: Define _isArguments instead of depending on                                          // 73
  // _.isArguments which is defined using each. In looksLikeArray                                        // 74
  // (which each depends on), we then use _isArguments instead of                                        // 75
  // _.isArguments.                                                                                      // 76
  var _isArguments = function (obj) {                                                                    // 77
    return toString.call(obj) === '[object Arguments]';                                                  // 78
  };                                                                                                     // 79
  // Define a fallback version of the method in browsers (ahem, IE), where                               // 80
  // there isn't any inspectable "Arguments" type.                                                       // 81
  if (!_isArguments(arguments)) {                                                                        // 82
    _isArguments = function (obj) {                                                                      // 83
      return !!(obj && hasOwnProperty.call(obj, 'callee') && typeof obj.callee === 'function');          // 84
    };                                                                                                   // 85
  }                                                                                                      // 86
                                                                                                         // 87
  // METEOR CHANGE: _.each({length: 5}) should be treated like an object, not an                         // 88
  // array. This looksLikeArray function is introduced by Meteor, and replaces                           // 89
  // all instances of `obj.length === +obj.length`.                                                      // 90
  // https://github.com/meteor/meteor/issues/594                                                         // 91
  // https://github.com/jashkenas/underscore/issues/770                                                  // 92
  var looksLikeArray = function (obj) {                                                                  // 93
    return (obj.length === +obj.length                                                                   // 94
            // _.isArguments not yet necessarily defined here                                            // 95
            && (_isArguments(obj) || obj.constructor !== Object));                                       // 96
  };                                                                                                     // 97
                                                                                                         // 98
  // The cornerstone, an `each` implementation, aka `forEach`.                                           // 99
  // Handles objects with the built-in `forEach`, arrays, and raw objects.                               // 100
  // Delegates to **ECMAScript 5**'s native `forEach` if available.                                      // 101
  var each = _.each = _.forEach = function(obj, iterator, context) {                                     // 102
    if (obj == null) return;                                                                             // 103
    if (nativeForEach && obj.forEach === nativeForEach) {                                                // 104
      obj.forEach(iterator, context);                                                                    // 105
    } else if (looksLikeArray(obj)) {                                                                    // 106
      for (var i = 0, length = obj.length; i < length; i++) {                                            // 107
        if (iterator.call(context, obj[i], i, obj) === breaker) return;                                  // 108
      }                                                                                                  // 109
    } else {                                                                                             // 110
      var keys = _.keys(obj);                                                                            // 111
      for (var i = 0, length = keys.length; i < length; i++) {                                           // 112
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;                      // 113
      }                                                                                                  // 114
    }                                                                                                    // 115
  };                                                                                                     // 116
                                                                                                         // 117
  // Return the results of applying the iterator to each element.                                        // 118
  // Delegates to **ECMAScript 5**'s native `map` if available.                                          // 119
  _.map = _.collect = function(obj, iterator, context) {                                                 // 120
    var results = [];                                                                                    // 121
    if (obj == null) return results;                                                                     // 122
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);                           // 123
    each(obj, function(value, index, list) {                                                             // 124
      results.push(iterator.call(context, value, index, list));                                          // 125
    });                                                                                                  // 126
    return results;                                                                                      // 127
  };                                                                                                     // 128
                                                                                                         // 129
  var reduceError = 'Reduce of empty array with no initial value';                                       // 130
                                                                                                         // 131
  // **Reduce** builds up a single result from a list of values, aka `inject`,                           // 132
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.                           // 133
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {                               // 134
    var initial = arguments.length > 2;                                                                  // 135
    if (obj == null) obj = [];                                                                           // 136
    if (nativeReduce && obj.reduce === nativeReduce) {                                                   // 137
      if (context) iterator = _.bind(iterator, context);                                                 // 138
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);                                // 139
    }                                                                                                    // 140
    each(obj, function(value, index, list) {                                                             // 141
      if (!initial) {                                                                                    // 142
        memo = value;                                                                                    // 143
        initial = true;                                                                                  // 144
      } else {                                                                                           // 145
        memo = iterator.call(context, memo, value, index, list);                                         // 146
      }                                                                                                  // 147
    });                                                                                                  // 148
    if (!initial) throw new TypeError(reduceError);                                                      // 149
    return memo;                                                                                         // 150
  };                                                                                                     // 151
                                                                                                         // 152
  // The right-associative version of reduce, also known as `foldr`.                                     // 153
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.                                  // 154
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {                                     // 155
    var initial = arguments.length > 2;                                                                  // 156
    if (obj == null) obj = [];                                                                           // 157
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {                                    // 158
      if (context) iterator = _.bind(iterator, context);                                                 // 159
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);                      // 160
    }                                                                                                    // 161
    var length = obj.length;                                                                             // 162
    if (!looksLikeArray(obj)) {                                                                          // 163
      var keys = _.keys(obj);                                                                            // 164
      length = keys.length;                                                                              // 165
    }                                                                                                    // 166
    each(obj, function(value, index, list) {                                                             // 167
      index = keys ? keys[--length] : --length;                                                          // 168
      if (!initial) {                                                                                    // 169
        memo = obj[index];                                                                               // 170
        initial = true;                                                                                  // 171
      } else {                                                                                           // 172
        memo = iterator.call(context, memo, obj[index], index, list);                                    // 173
      }                                                                                                  // 174
    });                                                                                                  // 175
    if (!initial) throw new TypeError(reduceError);                                                      // 176
    return memo;                                                                                         // 177
  };                                                                                                     // 178
                                                                                                         // 179
  // Return the first value which passes a truth test. Aliased as `detect`.                              // 180
  _.find = _.detect = function(obj, iterator, context) {                                                 // 181
    var result;                                                                                          // 182
    any(obj, function(value, index, list) {                                                              // 183
      if (iterator.call(context, value, index, list)) {                                                  // 184
        result = value;                                                                                  // 185
        return true;                                                                                     // 186
      }                                                                                                  // 187
    });                                                                                                  // 188
    return result;                                                                                       // 189
  };                                                                                                     // 190
                                                                                                         // 191
  // Return all the elements that pass a truth test.                                                     // 192
  // Delegates to **ECMAScript 5**'s native `filter` if available.                                       // 193
  // Aliased as `select`.                                                                                // 194
  _.filter = _.select = function(obj, iterator, context) {                                               // 195
    var results = [];                                                                                    // 196
    if (obj == null) return results;                                                                     // 197
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);               // 198
    each(obj, function(value, index, list) {                                                             // 199
      if (iterator.call(context, value, index, list)) results.push(value);                               // 200
    });                                                                                                  // 201
    return results;                                                                                      // 202
  };                                                                                                     // 203
                                                                                                         // 204
  // Return all the elements for which a truth test fails.                                               // 205
  _.reject = function(obj, iterator, context) {                                                          // 206
    return _.filter(obj, function(value, index, list) {                                                  // 207
      return !iterator.call(context, value, index, list);                                                // 208
    }, context);                                                                                         // 209
  };                                                                                                     // 210
                                                                                                         // 211
  // Determine whether all of the elements match a truth test.                                           // 212
  // Delegates to **ECMAScript 5**'s native `every` if available.                                        // 213
  // Aliased as `all`.                                                                                   // 214
  _.every = _.all = function(obj, iterator, context) {                                                   // 215
    iterator || (iterator = _.identity);                                                                 // 216
    var result = true;                                                                                   // 217
    if (obj == null) return result;                                                                      // 218
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);                   // 219
    each(obj, function(value, index, list) {                                                             // 220
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;              // 221
    });                                                                                                  // 222
    return !!result;                                                                                     // 223
  };                                                                                                     // 224
                                                                                                         // 225
  // Determine if at least one element in the object matches a truth test.                               // 226
  // Delegates to **ECMAScript 5**'s native `some` if available.                                         // 227
  // Aliased as `any`.                                                                                   // 228
  var any = _.some = _.any = function(obj, iterator, context) {                                          // 229
    iterator || (iterator = _.identity);                                                                 // 230
    var result = false;                                                                                  // 231
    if (obj == null) return result;                                                                      // 232
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);                       // 233
    each(obj, function(value, index, list) {                                                             // 234
      if (result || (result = iterator.call(context, value, index, list))) return breaker;               // 235
    });                                                                                                  // 236
    return !!result;                                                                                     // 237
  };                                                                                                     // 238
                                                                                                         // 239
  // Determine if the array or object contains a given value (using `===`).                              // 240
  // Aliased as `include`.                                                                               // 241
  _.contains = _.include = function(obj, target) {                                                       // 242
    if (obj == null) return false;                                                                       // 243
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;                // 244
    return any(obj, function(value) {                                                                    // 245
      return value === target;                                                                           // 246
    });                                                                                                  // 247
  };                                                                                                     // 248
                                                                                                         // 249
  // Invoke a method (with arguments) on every item in a collection.                                     // 250
  _.invoke = function(obj, method) {                                                                     // 251
    var args = slice.call(arguments, 2);                                                                 // 252
    var isFunc = _.isFunction(method);                                                                   // 253
    return _.map(obj, function(value) {                                                                  // 254
      return (isFunc ? method : value[method]).apply(value, args);                                       // 255
    });                                                                                                  // 256
  };                                                                                                     // 257
                                                                                                         // 258
  // Convenience version of a common use case of `map`: fetching a property.                             // 259
  _.pluck = function(obj, key) {                                                                         // 260
    return _.map(obj, function(value){ return value[key]; });                                            // 261
  };                                                                                                     // 262
                                                                                                         // 263
  // Convenience version of a common use case of `filter`: selecting only objects                        // 264
  // containing specific `key:value` pairs.                                                              // 265
  _.where = function(obj, attrs, first) {                                                                // 266
    if (_.isEmpty(attrs)) return first ? void 0 : [];                                                    // 267
    return _[first ? 'find' : 'filter'](obj, function(value) {                                           // 268
      for (var key in attrs) {                                                                           // 269
        if (attrs[key] !== value[key]) return false;                                                     // 270
      }                                                                                                  // 271
      return true;                                                                                       // 272
    });                                                                                                  // 273
  };                                                                                                     // 274
                                                                                                         // 275
  // Convenience version of a common use case of `find`: getting the first object                        // 276
  // containing specific `key:value` pairs.                                                              // 277
  _.findWhere = function(obj, attrs) {                                                                   // 278
    return _.where(obj, attrs, true);                                                                    // 279
  };                                                                                                     // 280
                                                                                                         // 281
  // Return the maximum element or (element-based computation).                                          // 282
  // Can't optimize arrays of integers longer than 65,535 elements.                                      // 283
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)                               // 284
  _.max = function(obj, iterator, context) {                                                             // 285
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {                       // 286
      return Math.max.apply(Math, obj);                                                                  // 287
    }                                                                                                    // 288
    if (!iterator && _.isEmpty(obj)) return -Infinity;                                                   // 289
    var result = {computed : -Infinity, value: -Infinity};                                               // 290
    each(obj, function(value, index, list) {                                                             // 291
      var computed = iterator ? iterator.call(context, value, index, list) : value;                      // 292
      computed > result.computed && (result = {value : value, computed : computed});                     // 293
    });                                                                                                  // 294
    return result.value;                                                                                 // 295
  };                                                                                                     // 296
                                                                                                         // 297
  // Return the minimum element (or element-based computation).                                          // 298
  _.min = function(obj, iterator, context) {                                                             // 299
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {                       // 300
      return Math.min.apply(Math, obj);                                                                  // 301
    }                                                                                                    // 302
    if (!iterator && _.isEmpty(obj)) return Infinity;                                                    // 303
    var result = {computed : Infinity, value: Infinity};                                                 // 304
    each(obj, function(value, index, list) {                                                             // 305
      var computed = iterator ? iterator.call(context, value, index, list) : value;                      // 306
      computed < result.computed && (result = {value : value, computed : computed});                     // 307
    });                                                                                                  // 308
    return result.value;                                                                                 // 309
  };                                                                                                     // 310
                                                                                                         // 311
  // Shuffle an array, using the modern version of the                                                   // 312
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).                          // 313
  _.shuffle = function(obj) {                                                                            // 314
    var rand;                                                                                            // 315
    var index = 0;                                                                                       // 316
    var shuffled = [];                                                                                   // 317
    each(obj, function(value) {                                                                          // 318
      rand = _.random(index++);                                                                          // 319
      shuffled[index - 1] = shuffled[rand];                                                              // 320
      shuffled[rand] = value;                                                                            // 321
    });                                                                                                  // 322
    return shuffled;                                                                                     // 323
  };                                                                                                     // 324
                                                                                                         // 325
  // Sample **n** random values from an array.                                                           // 326
  // If **n** is not specified, returns a single random element from the array.                          // 327
  // The internal `guard` argument allows it to work with `map`.                                         // 328
  _.sample = function(obj, n, guard) {                                                                   // 329
    if (arguments.length < 2 || guard) {                                                                 // 330
      return obj[_.random(obj.length - 1)];                                                              // 331
    }                                                                                                    // 332
    return _.shuffle(obj).slice(0, Math.max(0, n));                                                      // 333
  };                                                                                                     // 334
                                                                                                         // 335
  // An internal function to generate lookup iterators.                                                  // 336
  var lookupIterator = function(value) {                                                                 // 337
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };                            // 338
  };                                                                                                     // 339
                                                                                                         // 340
  // Sort the object's values by a criterion produced by an iterator.                                    // 341
  _.sortBy = function(obj, value, context) {                                                             // 342
    var iterator = lookupIterator(value);                                                                // 343
    return _.pluck(_.map(obj, function(value, index, list) {                                             // 344
      return {                                                                                           // 345
        value: value,                                                                                    // 346
        index: index,                                                                                    // 347
        criteria: iterator.call(context, value, index, list)                                             // 348
      };                                                                                                 // 349
    }).sort(function(left, right) {                                                                      // 350
      var a = left.criteria;                                                                             // 351
      var b = right.criteria;                                                                            // 352
      if (a !== b) {                                                                                     // 353
        if (a > b || a === void 0) return 1;                                                             // 354
        if (a < b || b === void 0) return -1;                                                            // 355
      }                                                                                                  // 356
      return left.index - right.index;                                                                   // 357
    }), 'value');                                                                                        // 358
  };                                                                                                     // 359
                                                                                                         // 360
  // An internal function used for aggregate "group by" operations.                                      // 361
  var group = function(behavior) {                                                                       // 362
    return function(obj, value, context) {                                                               // 363
      var result = {};                                                                                   // 364
      var iterator = value == null ? _.identity : lookupIterator(value);                                 // 365
      each(obj, function(value, index) {                                                                 // 366
        var key = iterator.call(context, value, index, obj);                                             // 367
        behavior(result, key, value);                                                                    // 368
      });                                                                                                // 369
      return result;                                                                                     // 370
    };                                                                                                   // 371
  };                                                                                                     // 372
                                                                                                         // 373
  // Groups the object's values by a criterion. Pass either a string attribute                           // 374
  // to group by, or a function that returns the criterion.                                              // 375
  _.groupBy = group(function(result, key, value) {                                                       // 376
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);                                 // 377
  });                                                                                                    // 378
                                                                                                         // 379
  // Indexes the object's values by a criterion, similar to `groupBy`, but for                           // 380
  // when you know that your index values will be unique.                                                // 381
  _.indexBy = group(function(result, key, value) {                                                       // 382
    result[key] = value;                                                                                 // 383
  });                                                                                                    // 384
                                                                                                         // 385
  // Counts instances of an object that group by a certain criterion. Pass                               // 386
  // either a string attribute to count by, or a function that returns the                               // 387
  // criterion.                                                                                          // 388
  _.countBy = group(function(result, key) {                                                              // 389
    _.has(result, key) ? result[key]++ : result[key] = 1;                                                // 390
  });                                                                                                    // 391
                                                                                                         // 392
  // Use a comparator function to figure out the smallest index at which                                 // 393
  // an object should be inserted so as to maintain order. Uses binary search.                           // 394
  _.sortedIndex = function(array, obj, iterator, context) {                                              // 395
    iterator = iterator == null ? _.identity : lookupIterator(iterator);                                 // 396
    var value = iterator.call(context, obj);                                                             // 397
    var low = 0, high = array.length;                                                                    // 398
    while (low < high) {                                                                                 // 399
      var mid = (low + high) >>> 1;                                                                      // 400
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;                           // 401
    }                                                                                                    // 402
    return low;                                                                                          // 403
  };                                                                                                     // 404
                                                                                                         // 405
  // Safely create a real, live array from anything iterable.                                            // 406
  _.toArray = function(obj) {                                                                            // 407
    if (!obj) return [];                                                                                 // 408
    if (_.isArray(obj)) return slice.call(obj);                                                          // 409
    if (looksLikeArray(obj)) return _.map(obj, _.identity);                                              // 410
    return _.values(obj);                                                                                // 411
  };                                                                                                     // 412
                                                                                                         // 413
  // Return the number of elements in an object.                                                         // 414
  _.size = function(obj) {                                                                               // 415
    if (obj == null) return 0;                                                                           // 416
    return (looksLikeArray(obj)) ? obj.length : _.keys(obj).length;                                      // 417
  };                                                                                                     // 418
                                                                                                         // 419
  // Array Functions                                                                                     // 420
  // ---------------                                                                                     // 421
                                                                                                         // 422
  // Get the first element of an array. Passing **n** will return the first N                            // 423
  // values in the array. Aliased as `head` and `take`. The **guard** check                              // 424
  // allows it to work with `_.map`.                                                                     // 425
  _.first = _.head = _.take = function(array, n, guard) {                                                // 426
    if (array == null) return void 0;                                                                    // 427
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);                                    // 428
  };                                                                                                     // 429
                                                                                                         // 430
  // Returns everything but the last entry of the array. Especially useful on                            // 431
  // the arguments object. Passing **n** will return all the values in                                   // 432
  // the array, excluding the last N. The **guard** check allows it to work with                         // 433
  // `_.map`.                                                                                            // 434
  _.initial = function(array, n, guard) {                                                                // 435
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));                          // 436
  };                                                                                                     // 437
                                                                                                         // 438
  // Get the last element of an array. Passing **n** will return the last N                              // 439
  // values in the array. The **guard** check allows it to work with `_.map`.                            // 440
  _.last = function(array, n, guard) {                                                                   // 441
    if (array == null) return void 0;                                                                    // 442
    if ((n == null) || guard) {                                                                          // 443
      return array[array.length - 1];                                                                    // 444
    } else {                                                                                             // 445
      return slice.call(array, Math.max(array.length - n, 0));                                           // 446
    }                                                                                                    // 447
  };                                                                                                     // 448
                                                                                                         // 449
  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.                  // 450
  // Especially useful on the arguments object. Passing an **n** will return                             // 451
  // the rest N values in the array. The **guard**                                                       // 452
  // check allows it to work with `_.map`.                                                               // 453
  _.rest = _.tail = _.drop = function(array, n, guard) {                                                 // 454
    return slice.call(array, (n == null) || guard ? 1 : n);                                              // 455
  };                                                                                                     // 456
                                                                                                         // 457
  // Trim out all falsy values from an array.                                                            // 458
  _.compact = function(array) {                                                                          // 459
    return _.filter(array, _.identity);                                                                  // 460
  };                                                                                                     // 461
                                                                                                         // 462
  // Internal implementation of a recursive `flatten` function.                                          // 463
  var flatten = function(input, shallow, output) {                                                       // 464
    if (shallow && _.every(input, _.isArray)) {                                                          // 465
      return concat.apply(output, input);                                                                // 466
    }                                                                                                    // 467
    each(input, function(value) {                                                                        // 468
      if (_.isArray(value) || _.isArguments(value)) {                                                    // 469
        shallow ? push.apply(output, value) : flatten(value, shallow, output);                           // 470
      } else {                                                                                           // 471
        output.push(value);                                                                              // 472
      }                                                                                                  // 473
    });                                                                                                  // 474
    return output;                                                                                       // 475
  };                                                                                                     // 476
                                                                                                         // 477
  // Flatten out an array, either recursively (by default), or just one level.                           // 478
  _.flatten = function(array, shallow) {                                                                 // 479
    return flatten(array, shallow, []);                                                                  // 480
  };                                                                                                     // 481
                                                                                                         // 482
  // Return a version of the array that does not contain the specified value(s).                         // 483
  _.without = function(array) {                                                                          // 484
    return _.difference(array, slice.call(arguments, 1));                                                // 485
  };                                                                                                     // 486
                                                                                                         // 487
  // Produce a duplicate-free version of the array. If the array has already                             // 488
  // been sorted, you have the option of using a faster algorithm.                                       // 489
  // Aliased as `unique`.                                                                                // 490
  _.uniq = _.unique = function(array, isSorted, iterator, context) {                                     // 491
    if (_.isFunction(isSorted)) {                                                                        // 492
      context = iterator;                                                                                // 493
      iterator = isSorted;                                                                               // 494
      isSorted = false;                                                                                  // 495
    }                                                                                                    // 496
    var initial = iterator ? _.map(array, iterator, context) : array;                                    // 497
    var results = [];                                                                                    // 498
    var seen = [];                                                                                       // 499
    each(initial, function(value, index) {                                                               // 500
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {           // 501
        seen.push(value);                                                                                // 502
        results.push(array[index]);                                                                      // 503
      }                                                                                                  // 504
    });                                                                                                  // 505
    return results;                                                                                      // 506
  };                                                                                                     // 507
                                                                                                         // 508
  // Produce an array that contains the union: each distinct element from all of                         // 509
  // the passed-in arrays.                                                                               // 510
  _.union = function() {                                                                                 // 511
    return _.uniq(_.flatten(arguments, true));                                                           // 512
  };                                                                                                     // 513
                                                                                                         // 514
  // Produce an array that contains every item shared between all the                                    // 515
  // passed-in arrays.                                                                                   // 516
  _.intersection = function(array) {                                                                     // 517
    var rest = slice.call(arguments, 1);                                                                 // 518
    return _.filter(_.uniq(array), function(item) {                                                      // 519
      return _.every(rest, function(other) {                                                             // 520
        return _.indexOf(other, item) >= 0;                                                              // 521
      });                                                                                                // 522
    });                                                                                                  // 523
  };                                                                                                     // 524
                                                                                                         // 525
  // Take the difference between one array and a number of other arrays.                                 // 526
  // Only the elements present in just the first array will remain.                                      // 527
  _.difference = function(array) {                                                                       // 528
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 529
    return _.filter(array, function(value){ return !_.contains(rest, value); });                         // 530
  };                                                                                                     // 531
                                                                                                         // 532
  // Zip together multiple lists into a single array -- elements that share                              // 533
  // an index go together.                                                                               // 534
  _.zip = function() {                                                                                   // 535
    var length = _.max(_.pluck(arguments, "length").concat(0));                                          // 536
    var results = new Array(length);                                                                     // 537
    for (var i = 0; i < length; i++) {                                                                   // 538
      results[i] = _.pluck(arguments, '' + i);                                                           // 539
    }                                                                                                    // 540
    return results;                                                                                      // 541
  };                                                                                                     // 542
                                                                                                         // 543
  // Converts lists into objects. Pass either a single array of `[key, value]`                           // 544
  // pairs, or two parallel arrays of the same length -- one of keys, and one of                         // 545
  // the corresponding values.                                                                           // 546
  _.object = function(list, values) {                                                                    // 547
    if (list == null) return {};                                                                         // 548
    var result = {};                                                                                     // 549
    for (var i = 0, length = list.length; i < length; i++) {                                             // 550
      if (values) {                                                                                      // 551
        result[list[i]] = values[i];                                                                     // 552
      } else {                                                                                           // 553
        result[list[i][0]] = list[i][1];                                                                 // 554
      }                                                                                                  // 555
    }                                                                                                    // 556
    return result;                                                                                       // 557
  };                                                                                                     // 558
                                                                                                         // 559
  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),                       // 560
  // we need this function. Return the position of the first occurrence of an                            // 561
  // item in an array, or -1 if the item is not included in the array.                                   // 562
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.                                      // 563
  // If the array is large and already in sort order, pass `true`                                        // 564
  // for **isSorted** to use binary search.                                                              // 565
  _.indexOf = function(array, item, isSorted) {                                                          // 566
    if (array == null) return -1;                                                                        // 567
    var i = 0, length = array.length;                                                                    // 568
    if (isSorted) {                                                                                      // 569
      if (typeof isSorted == 'number') {                                                                 // 570
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);                                  // 571
      } else {                                                                                           // 572
        i = _.sortedIndex(array, item);                                                                  // 573
        return array[i] === item ? i : -1;                                                               // 574
      }                                                                                                  // 575
    }                                                                                                    // 576
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);          // 577
    for (; i < length; i++) if (array[i] === item) return i;                                             // 578
    return -1;                                                                                           // 579
  };                                                                                                     // 580
                                                                                                         // 581
  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.                                  // 582
  _.lastIndexOf = function(array, item, from) {                                                          // 583
    if (array == null) return -1;                                                                        // 584
    var hasIndex = from != null;                                                                         // 585
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {                                  // 586
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);                         // 587
    }                                                                                                    // 588
    var i = (hasIndex ? from : array.length);                                                            // 589
    while (i--) if (array[i] === item) return i;                                                         // 590
    return -1;                                                                                           // 591
  };                                                                                                     // 592
                                                                                                         // 593
  // Generate an integer Array containing an arithmetic progression. A port of                           // 594
  // the native Python `range()` function. See                                                           // 595
  // [the Python documentation](http://docs.python.org/library/functions.html#range).                    // 596
  _.range = function(start, stop, step) {                                                                // 597
    if (arguments.length <= 1) {                                                                         // 598
      stop = start || 0;                                                                                 // 599
      start = 0;                                                                                         // 600
    }                                                                                                    // 601
    step = arguments[2] || 1;                                                                            // 602
                                                                                                         // 603
    var length = Math.max(Math.ceil((stop - start) / step), 0);                                          // 604
    var idx = 0;                                                                                         // 605
    var range = new Array(length);                                                                       // 606
                                                                                                         // 607
    while(idx < length) {                                                                                // 608
      range[idx++] = start;                                                                              // 609
      start += step;                                                                                     // 610
    }                                                                                                    // 611
                                                                                                         // 612
    return range;                                                                                        // 613
  };                                                                                                     // 614
                                                                                                         // 615
  // Function (ahem) Functions                                                                           // 616
  // ------------------                                                                                  // 617
                                                                                                         // 618
  // Reusable constructor function for prototype setting.                                                // 619
  var ctor = function(){};                                                                               // 620
                                                                                                         // 621
  // Create a function bound to a given object (assigning `this`, and arguments,                         // 622
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if                              // 623
  // available.                                                                                          // 624
  _.bind = function(func, context) {                                                                     // 625
    var args, bound;                                                                                     // 626
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1)); // 627
    if (!_.isFunction(func)) throw new TypeError;                                                        // 628
    args = slice.call(arguments, 2);                                                                     // 629
    return bound = function() {                                                                          // 630
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));      // 631
      ctor.prototype = func.prototype;                                                                   // 632
      var self = new ctor;                                                                               // 633
      ctor.prototype = null;                                                                             // 634
      var result = func.apply(self, args.concat(slice.call(arguments)));                                 // 635
      if (Object(result) === result) return result;                                                      // 636
      return self;                                                                                       // 637
    };                                                                                                   // 638
  };                                                                                                     // 639
                                                                                                         // 640
  // Partially apply a function by creating a version that has had some of its                           // 641
  // arguments pre-filled, without changing its dynamic `this` context.                                  // 642
  _.partial = function(func) {                                                                           // 643
    var args = slice.call(arguments, 1);                                                                 // 644
    return function() {                                                                                  // 645
      return func.apply(this, args.concat(slice.call(arguments)));                                       // 646
    };                                                                                                   // 647
  };                                                                                                     // 648
                                                                                                         // 649
  // Bind all of an object's methods to that object. Useful for ensuring that                            // 650
  // all callbacks defined on an object belong to it.                                                    // 651
  _.bindAll = function(obj) {                                                                            // 652
    var funcs = slice.call(arguments, 1);                                                                // 653
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");                    // 654
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });                                          // 655
    return obj;                                                                                          // 656
  };                                                                                                     // 657
                                                                                                         // 658
  // Memoize an expensive function by storing its results.                                               // 659
  _.memoize = function(func, hasher) {                                                                   // 660
    var memo = {};                                                                                       // 661
    hasher || (hasher = _.identity);                                                                     // 662
    return function() {                                                                                  // 663
      var key = hasher.apply(this, arguments);                                                           // 664
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));                   // 665
    };                                                                                                   // 666
  };                                                                                                     // 667
                                                                                                         // 668
  // Delays a function for the given number of milliseconds, and then calls                              // 669
  // it with the arguments supplied.                                                                     // 670
  _.delay = function(func, wait) {                                                                       // 671
    var args = slice.call(arguments, 2);                                                                 // 672
    return setTimeout(function(){ return func.apply(null, args); }, wait);                               // 673
  };                                                                                                     // 674
                                                                                                         // 675
  // Defers a function, scheduling it to run after the current call stack has                            // 676
  // cleared.                                                                                            // 677
  _.defer = function(func) {                                                                             // 678
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));                                 // 679
  };                                                                                                     // 680
                                                                                                         // 681
  // Returns a function, that, when invoked, will only be triggered at most once                         // 682
  // during a given window of time. Normally, the throttled function will run                            // 683
  // as much as it can, without ever going more than once per `wait` duration;                           // 684
  // but if you'd like to disable the execution on the leading edge, pass                                // 685
  // `{leading: false}`. To disable execution on the trailing edge, ditto.                               // 686
  _.throttle = function(func, wait, options) {                                                           // 687
    var context, args, result;                                                                           // 688
    var timeout = null;                                                                                  // 689
    var previous = 0;                                                                                    // 690
    options || (options = {});                                                                           // 691
    var later = function() {                                                                             // 692
      previous = options.leading === false ? 0 : new Date;                                               // 693
      timeout = null;                                                                                    // 694
      result = func.apply(context, args);                                                                // 695
    };                                                                                                   // 696
    return function() {                                                                                  // 697
      var now = new Date;                                                                                // 698
      if (!previous && options.leading === false) previous = now;                                        // 699
      var remaining = wait - (now - previous);                                                           // 700
      context = this;                                                                                    // 701
      args = arguments;                                                                                  // 702
      if (remaining <= 0) {                                                                              // 703
        clearTimeout(timeout);                                                                           // 704
        timeout = null;                                                                                  // 705
        previous = now;                                                                                  // 706
        result = func.apply(context, args);                                                              // 707
      } else if (!timeout && options.trailing !== false) {                                               // 708
        timeout = setTimeout(later, remaining);                                                          // 709
      }                                                                                                  // 710
      return result;                                                                                     // 711
    };                                                                                                   // 712
  };                                                                                                     // 713
                                                                                                         // 714
  // Returns a function, that, as long as it continues to be invoked, will not                           // 715
  // be triggered. The function will be called after it stops being called for                           // 716
  // N milliseconds. If `immediate` is passed, trigger the function on the                               // 717
  // leading edge, instead of the trailing.                                                              // 718
  _.debounce = function(func, wait, immediate) {                                                         // 719
    var timeout, args, context, timestamp, result;                                                       // 720
    return function() {                                                                                  // 721
      context = this;                                                                                    // 722
      args = arguments;                                                                                  // 723
      timestamp = new Date();                                                                            // 724
      var later = function() {                                                                           // 725
        var last = (new Date()) - timestamp;                                                             // 726
        if (last < wait) {                                                                               // 727
          timeout = setTimeout(later, wait - last);                                                      // 728
        } else {                                                                                         // 729
          timeout = null;                                                                                // 730
          if (!immediate) result = func.apply(context, args);                                            // 731
        }                                                                                                // 732
      };                                                                                                 // 733
      var callNow = immediate && !timeout;                                                               // 734
      if (!timeout) {                                                                                    // 735
        timeout = setTimeout(later, wait);                                                               // 736
      }                                                                                                  // 737
      if (callNow) result = func.apply(context, args);                                                   // 738
      return result;                                                                                     // 739
    };                                                                                                   // 740
  };                                                                                                     // 741
                                                                                                         // 742
  // Returns a function that will be executed at most one time, no matter how                            // 743
  // often you call it. Useful for lazy initialization.                                                  // 744
  _.once = function(func) {                                                                              // 745
    var ran = false, memo;                                                                               // 746
    return function() {                                                                                  // 747
      if (ran) return memo;                                                                              // 748
      ran = true;                                                                                        // 749
      memo = func.apply(this, arguments);                                                                // 750
      func = null;                                                                                       // 751
      return memo;                                                                                       // 752
    };                                                                                                   // 753
  };                                                                                                     // 754
                                                                                                         // 755
  // Returns the first function passed as an argument to the second,                                     // 756
  // allowing you to adjust arguments, run code before and after, and                                    // 757
  // conditionally execute the original function.                                                        // 758
  _.wrap = function(func, wrapper) {                                                                     // 759
    return function() {                                                                                  // 760
      var args = [func];                                                                                 // 761
      push.apply(args, arguments);                                                                       // 762
      return wrapper.apply(this, args);                                                                  // 763
    };                                                                                                   // 764
  };                                                                                                     // 765
                                                                                                         // 766
  // Returns a function that is the composition of a list of functions, each                             // 767
  // consuming the return value of the function that follows.                                            // 768
  _.compose = function() {                                                                               // 769
    var funcs = arguments;                                                                               // 770
    return function() {                                                                                  // 771
      var args = arguments;                                                                              // 772
      for (var i = funcs.length - 1; i >= 0; i--) {                                                      // 773
        args = [funcs[i].apply(this, args)];                                                             // 774
      }                                                                                                  // 775
      return args[0];                                                                                    // 776
    };                                                                                                   // 777
  };                                                                                                     // 778
                                                                                                         // 779
  // Returns a function that will only be executed after being called N times.                           // 780
  _.after = function(times, func) {                                                                      // 781
    return function() {                                                                                  // 782
      if (--times < 1) {                                                                                 // 783
        return func.apply(this, arguments);                                                              // 784
      }                                                                                                  // 785
    };                                                                                                   // 786
  };                                                                                                     // 787
                                                                                                         // 788
  // Object Functions                                                                                    // 789
  // ----------------                                                                                    // 790
                                                                                                         // 791
  // Retrieve the names of an object's properties.                                                       // 792
  // Delegates to **ECMAScript 5**'s native `Object.keys`                                                // 793
  _.keys = nativeKeys || function(obj) {                                                                 // 794
    if (obj !== Object(obj)) throw new TypeError('Invalid object');                                      // 795
    var keys = [];                                                                                       // 796
    for (var key in obj) if (_.has(obj, key)) keys.push(key);                                            // 797
    return keys;                                                                                         // 798
  };                                                                                                     // 799
                                                                                                         // 800
  // Retrieve the values of an object's properties.                                                      // 801
  _.values = function(obj) {                                                                             // 802
    var keys = _.keys(obj);                                                                              // 803
    var length = keys.length;                                                                            // 804
    var values = new Array(length);                                                                      // 805
    for (var i = 0; i < length; i++) {                                                                   // 806
      values[i] = obj[keys[i]];                                                                          // 807
    }                                                                                                    // 808
    return values;                                                                                       // 809
  };                                                                                                     // 810
                                                                                                         // 811
  // Convert an object into a list of `[key, value]` pairs.                                              // 812
  _.pairs = function(obj) {                                                                              // 813
    var keys = _.keys(obj);                                                                              // 814
    var length = keys.length;                                                                            // 815
    var pairs = new Array(length);                                                                       // 816
    for (var i = 0; i < length; i++) {                                                                   // 817
      pairs[i] = [keys[i], obj[keys[i]]];                                                                // 818
    }                                                                                                    // 819
    return pairs;                                                                                        // 820
  };                                                                                                     // 821
                                                                                                         // 822
  // Invert the keys and values of an object. The values must be serializable.                           // 823
  _.invert = function(obj) {                                                                             // 824
    var result = {};                                                                                     // 825
    var keys = _.keys(obj);                                                                              // 826
    for (var i = 0, length = keys.length; i < length; i++) {                                             // 827
      result[obj[keys[i]]] = keys[i];                                                                    // 828
    }                                                                                                    // 829
    return result;                                                                                       // 830
  };                                                                                                     // 831
                                                                                                         // 832
  // Return a sorted list of the function names available on the object.                                 // 833
  // Aliased as `methods`                                                                                // 834
  _.functions = _.methods = function(obj) {                                                              // 835
    var names = [];                                                                                      // 836
    for (var key in obj) {                                                                               // 837
      if (_.isFunction(obj[key])) names.push(key);                                                       // 838
    }                                                                                                    // 839
    return names.sort();                                                                                 // 840
  };                                                                                                     // 841
                                                                                                         // 842
  // Extend a given object with all the properties in passed-in object(s).                               // 843
  _.extend = function(obj) {                                                                             // 844
    each(slice.call(arguments, 1), function(source) {                                                    // 845
      if (source) {                                                                                      // 846
        for (var prop in source) {                                                                       // 847
          obj[prop] = source[prop];                                                                      // 848
        }                                                                                                // 849
      }                                                                                                  // 850
    });                                                                                                  // 851
    return obj;                                                                                          // 852
  };                                                                                                     // 853
                                                                                                         // 854
  // Return a copy of the object only containing the whitelisted properties.                             // 855
  _.pick = function(obj) {                                                                               // 856
    var copy = {};                                                                                       // 857
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 858
    each(keys, function(key) {                                                                           // 859
      if (key in obj) copy[key] = obj[key];                                                              // 860
    });                                                                                                  // 861
    return copy;                                                                                         // 862
  };                                                                                                     // 863
                                                                                                         // 864
   // Return a copy of the object without the blacklisted properties.                                    // 865
  _.omit = function(obj) {                                                                               // 866
    var copy = {};                                                                                       // 867
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 868
    for (var key in obj) {                                                                               // 869
      if (!_.contains(keys, key)) copy[key] = obj[key];                                                  // 870
    }                                                                                                    // 871
    return copy;                                                                                         // 872
  };                                                                                                     // 873
                                                                                                         // 874
  // Fill in a given object with default properties.                                                     // 875
  _.defaults = function(obj) {                                                                           // 876
    each(slice.call(arguments, 1), function(source) {                                                    // 877
      if (source) {                                                                                      // 878
        for (var prop in source) {                                                                       // 879
          if (obj[prop] === void 0) obj[prop] = source[prop];                                            // 880
        }                                                                                                // 881
      }                                                                                                  // 882
    });                                                                                                  // 883
    return obj;                                                                                          // 884
  };                                                                                                     // 885
                                                                                                         // 886
  // Create a (shallow-cloned) duplicate of an object.                                                   // 887
  _.clone = function(obj) {                                                                              // 888
    if (!_.isObject(obj)) return obj;                                                                    // 889
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);                                             // 890
  };                                                                                                     // 891
                                                                                                         // 892
  // Invokes interceptor with the obj, and then returns obj.                                             // 893
  // The primary purpose of this method is to "tap into" a method chain, in                              // 894
  // order to perform operations on intermediate results within the chain.                               // 895
  _.tap = function(obj, interceptor) {                                                                   // 896
    interceptor(obj);                                                                                    // 897
    return obj;                                                                                          // 898
  };                                                                                                     // 899
                                                                                                         // 900
  // Internal recursive comparison function for `isEqual`.                                               // 901
  var eq = function(a, b, aStack, bStack) {                                                              // 902
    // Identical objects are equal. `0 === -0`, but they aren't identical.                               // 903
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).           // 904
    if (a === b) return a !== 0 || 1 / a == 1 / b;                                                       // 905
    // A strict comparison is necessary because `null == undefined`.                                     // 906
    if (a == null || b == null) return a === b;                                                          // 907
    // Unwrap any wrapped objects.                                                                       // 908
    if (a instanceof _) a = a._wrapped;                                                                  // 909
    if (b instanceof _) b = b._wrapped;                                                                  // 910
    // Compare `[[Class]]` names.                                                                        // 911
    var className = toString.call(a);                                                                    // 912
    if (className != toString.call(b)) return false;                                                     // 913
    switch (className) {                                                                                 // 914
      // Strings, numbers, dates, and booleans are compared by value.                                    // 915
      case '[object String]':                                                                            // 916
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is             // 917
        // equivalent to `new String("5")`.                                                              // 918
        return a == String(b);                                                                           // 919
      case '[object Number]':                                                                            // 920
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for               // 921
        // other numeric values.                                                                         // 922
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);                                  // 923
      case '[object Date]':                                                                              // 924
      case '[object Boolean]':                                                                           // 925
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their            // 926
        // millisecond representations. Note that invalid dates with millisecond representations         // 927
        // of `NaN` are not equivalent.                                                                  // 928
        return +a == +b;                                                                                 // 929
      // RegExps are compared by their source patterns and flags.                                        // 930
      case '[object RegExp]':                                                                            // 931
        return a.source == b.source &&                                                                   // 932
               a.global == b.global &&                                                                   // 933
               a.multiline == b.multiline &&                                                             // 934
               a.ignoreCase == b.ignoreCase;                                                             // 935
    }                                                                                                    // 936
    if (typeof a != 'object' || typeof b != 'object') return false;                                      // 937
    // Assume equality for cyclic structures. The algorithm for detecting cyclic                         // 938
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.                       // 939
    var length = aStack.length;                                                                          // 940
    while (length--) {                                                                                   // 941
      // Linear search. Performance is inversely proportional to the number of                           // 942
      // unique nested structures.                                                                       // 943
      if (aStack[length] == a) return bStack[length] == b;                                               // 944
    }                                                                                                    // 945
    // Objects with different constructors are not equivalent, but `Object`s                             // 946
    // from different frames are.                                                                        // 947
    var aCtor = a.constructor, bCtor = b.constructor;                                                    // 948
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&                          // 949
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {                         // 950
      return false;                                                                                      // 951
    }                                                                                                    // 952
    // Add the first object to the stack of traversed objects.                                           // 953
    aStack.push(a);                                                                                      // 954
    bStack.push(b);                                                                                      // 955
    var size = 0, result = true;                                                                         // 956
    // Recursively compare objects and arrays.                                                           // 957
    if (className == '[object Array]') {                                                                 // 958
      // Compare array lengths to determine if a deep comparison is necessary.                           // 959
      size = a.length;                                                                                   // 960
      result = size == b.length;                                                                         // 961
      if (result) {                                                                                      // 962
        // Deep compare the contents, ignoring non-numeric properties.                                   // 963
        while (size--) {                                                                                 // 964
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;                                   // 965
        }                                                                                                // 966
      }                                                                                                  // 967
    } else {                                                                                             // 968
      // Deep compare objects.                                                                           // 969
      for (var key in a) {                                                                               // 970
        if (_.has(a, key)) {                                                                             // 971
          // Count the expected number of properties.                                                    // 972
          size++;                                                                                        // 973
          // Deep compare each member.                                                                   // 974
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;                    // 975
        }                                                                                                // 976
      }                                                                                                  // 977
      // Ensure that both objects contain the same number of properties.                                 // 978
      if (result) {                                                                                      // 979
        for (key in b) {                                                                                 // 980
          if (_.has(b, key) && !(size--)) break;                                                         // 981
        }                                                                                                // 982
        result = !size;                                                                                  // 983
      }                                                                                                  // 984
    }                                                                                                    // 985
    // Remove the first object from the stack of traversed objects.                                      // 986
    aStack.pop();                                                                                        // 987
    bStack.pop();                                                                                        // 988
    return result;                                                                                       // 989
  };                                                                                                     // 990
                                                                                                         // 991
  // Perform a deep comparison to check if two objects are equal.                                        // 992
  _.isEqual = function(a, b) {                                                                           // 993
    return eq(a, b, [], []);                                                                             // 994
  };                                                                                                     // 995
                                                                                                         // 996
  // Is a given array, string, or object empty?                                                          // 997
  // An "empty" object has no enumerable own-properties.                                                 // 998
  _.isEmpty = function(obj) {                                                                            // 999
    if (obj == null) return true;                                                                        // 1000
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;                                      // 1001
    for (var key in obj) if (_.has(obj, key)) return false;                                              // 1002
    return true;                                                                                         // 1003
  };                                                                                                     // 1004
                                                                                                         // 1005
  // Is a given value a DOM element?                                                                     // 1006
  _.isElement = function(obj) {                                                                          // 1007
    return !!(obj && obj.nodeType === 1);                                                                // 1008
  };                                                                                                     // 1009
                                                                                                         // 1010
  // Is a given value an array?                                                                          // 1011
  // Delegates to ECMA5's native Array.isArray                                                           // 1012
  _.isArray = nativeIsArray || function(obj) {                                                           // 1013
    return toString.call(obj) == '[object Array]';                                                       // 1014
  };                                                                                                     // 1015
                                                                                                         // 1016
  // Is a given variable an object?                                                                      // 1017
  _.isObject = function(obj) {                                                                           // 1018
    return obj === Object(obj);                                                                          // 1019
  };                                                                                                     // 1020
                                                                                                         // 1021
  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.             // 1022
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {                 // 1023
    _['is' + name] = function(obj) {                                                                     // 1024
      return toString.call(obj) == '[object ' + name + ']';                                              // 1025
    };                                                                                                   // 1026
  });                                                                                                    // 1027
                                                                                                         // 1028
  // Define a fallback version of the method in browsers (ahem, IE), where                               // 1029
  // there isn't any inspectable "Arguments" type.                                                       // 1030
  if (!_.isArguments(arguments)) {                                                                       // 1031
    _.isArguments = function(obj) {                                                                      // 1032
      return !!(obj && _.has(obj, 'callee'));                                                            // 1033
    };                                                                                                   // 1034
  }                                                                                                      // 1035
                                                                                                         // 1036
  // Optimize `isFunction` if appropriate.                                                               // 1037
  if (typeof (/./) !== 'function') {                                                                     // 1038
    _.isFunction = function(obj) {                                                                       // 1039
      return typeof obj === 'function';                                                                  // 1040
    };                                                                                                   // 1041
  }                                                                                                      // 1042
                                                                                                         // 1043
  // Is a given object a finite number?                                                                  // 1044
  _.isFinite = function(obj) {                                                                           // 1045
    return isFinite(obj) && !isNaN(parseFloat(obj));                                                     // 1046
  };                                                                                                     // 1047
                                                                                                         // 1048
  // Is the given value `NaN`? (NaN is the only number which does not equal itself).                     // 1049
  _.isNaN = function(obj) {                                                                              // 1050
    return _.isNumber(obj) && obj != +obj;                                                               // 1051
  };                                                                                                     // 1052
                                                                                                         // 1053
  // Is a given value a boolean?                                                                         // 1054
  _.isBoolean = function(obj) {                                                                          // 1055
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';                    // 1056
  };                                                                                                     // 1057
                                                                                                         // 1058
  // Is a given value equal to null?                                                                     // 1059
  _.isNull = function(obj) {                                                                             // 1060
    return obj === null;                                                                                 // 1061
  };                                                                                                     // 1062
                                                                                                         // 1063
  // Is a given variable undefined?                                                                      // 1064
  _.isUndefined = function(obj) {                                                                        // 1065
    return obj === void 0;                                                                               // 1066
  };                                                                                                     // 1067
                                                                                                         // 1068
  // Shortcut function for checking if an object has a given property directly                           // 1069
  // on itself (in other words, not on a prototype).                                                     // 1070
  _.has = function(obj, key) {                                                                           // 1071
    return hasOwnProperty.call(obj, key);                                                                // 1072
  };                                                                                                     // 1073
                                                                                                         // 1074
  // Utility Functions                                                                                   // 1075
  // -----------------                                                                                   // 1076
                                                                                                         // 1077
  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its                           // 1078
  // previous owner. Returns a reference to the Underscore object.                                       // 1079
  _.noConflict = function() {                                                                            // 1080
    root._ = previousUnderscore;                                                                         // 1081
    return this;                                                                                         // 1082
  };                                                                                                     // 1083
                                                                                                         // 1084
  // Keep the identity function around for default iterators.                                            // 1085
  _.identity = function(value) {                                                                         // 1086
    return value;                                                                                        // 1087
  };                                                                                                     // 1088
                                                                                                         // 1089
  // Run a function **n** times.                                                                         // 1090
  _.times = function(n, iterator, context) {                                                             // 1091
    var accum = Array(Math.max(0, n));                                                                   // 1092
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);                                    // 1093
    return accum;                                                                                        // 1094
  };                                                                                                     // 1095
                                                                                                         // 1096
  // Return a random integer between min and max (inclusive).                                            // 1097
  _.random = function(min, max) {                                                                        // 1098
    if (max == null) {                                                                                   // 1099
      max = min;                                                                                         // 1100
      min = 0;                                                                                           // 1101
    }                                                                                                    // 1102
    return min + Math.floor(Math.random() * (max - min + 1));                                            // 1103
  };                                                                                                     // 1104
                                                                                                         // 1105
  // List of HTML entities for escaping.                                                                 // 1106
  var entityMap = {                                                                                      // 1107
    escape: {                                                                                            // 1108
      '&': '&amp;',                                                                                      // 1109
      '<': '&lt;',                                                                                       // 1110
      '>': '&gt;',                                                                                       // 1111
      '"': '&quot;',                                                                                     // 1112
      "'": '&#x27;'                                                                                      // 1113
    }                                                                                                    // 1114
  };                                                                                                     // 1115
  entityMap.unescape = _.invert(entityMap.escape);                                                       // 1116
                                                                                                         // 1117
  // Regexes containing the keys and values listed immediately above.                                    // 1118
  var entityRegexes = {                                                                                  // 1119
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),                            // 1120
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')                          // 1121
  };                                                                                                     // 1122
                                                                                                         // 1123
  // Functions for escaping and unescaping strings to/from HTML interpolation.                           // 1124
  _.each(['escape', 'unescape'], function(method) {                                                      // 1125
    _[method] = function(string) {                                                                       // 1126
      if (string == null) return '';                                                                     // 1127
      return ('' + string).replace(entityRegexes[method], function(match) {                              // 1128
        return entityMap[method][match];                                                                 // 1129
      });                                                                                                // 1130
    };                                                                                                   // 1131
  });                                                                                                    // 1132
                                                                                                         // 1133
  // If the value of the named `property` is a function then invoke it with the                          // 1134
  // `object` as context; otherwise, return it.                                                          // 1135
  _.result = function(object, property) {                                                                // 1136
    if (object == null) return void 0;                                                                   // 1137
    var value = object[property];                                                                        // 1138
    return _.isFunction(value) ? value.call(object) : value;                                             // 1139
  };                                                                                                     // 1140
                                                                                                         // 1141
  // Add your own custom functions to the Underscore object.                                             // 1142
  _.mixin = function(obj) {                                                                              // 1143
    each(_.functions(obj), function(name) {                                                              // 1144
      var func = _[name] = obj[name];                                                                    // 1145
      _.prototype[name] = function() {                                                                   // 1146
        var args = [this._wrapped];                                                                      // 1147
        push.apply(args, arguments);                                                                     // 1148
        return result.call(this, func.apply(_, args));                                                   // 1149
      };                                                                                                 // 1150
    });                                                                                                  // 1151
  };                                                                                                     // 1152
                                                                                                         // 1153
  // Generate a unique integer id (unique within the entire client session).                             // 1154
  // Useful for temporary DOM ids.                                                                       // 1155
  var idCounter = 0;                                                                                     // 1156
  _.uniqueId = function(prefix) {                                                                        // 1157
    var id = ++idCounter + '';                                                                           // 1158
    return prefix ? prefix + id : id;                                                                    // 1159
  };                                                                                                     // 1160
                                                                                                         // 1161
  // By default, Underscore uses ERB-style template delimiters, change the                               // 1162
  // following template settings to use alternative delimiters.                                          // 1163
  _.templateSettings = {                                                                                 // 1164
    evaluate    : /<%([\s\S]+?)%>/g,                                                                     // 1165
    interpolate : /<%=([\s\S]+?)%>/g,                                                                    // 1166
    escape      : /<%-([\s\S]+?)%>/g                                                                     // 1167
  };                                                                                                     // 1168
                                                                                                         // 1169
  // When customizing `templateSettings`, if you don't want to define an                                 // 1170
  // interpolation, evaluation or escaping regex, we need one that is                                    // 1171
  // guaranteed not to match.                                                                            // 1172
  var noMatch = /(.)^/;                                                                                  // 1173
                                                                                                         // 1174
  // Certain characters need to be escaped so that they can be put into a                                // 1175
  // string literal.                                                                                     // 1176
  var escapes = {                                                                                        // 1177
    "'":      "'",                                                                                       // 1178
    '\\':     '\\',                                                                                      // 1179
    '\r':     'r',                                                                                       // 1180
    '\n':     'n',                                                                                       // 1181
    '\t':     't',                                                                                       // 1182
    '\u2028': 'u2028',                                                                                   // 1183
    '\u2029': 'u2029'                                                                                    // 1184
  };                                                                                                     // 1185
                                                                                                         // 1186
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;                                                          // 1187
                                                                                                         // 1188
  // JavaScript micro-templating, similar to John Resig's implementation.                                // 1189
  // Underscore templating handles arbitrary delimiters, preserves whitespace,                           // 1190
  // and correctly escapes quotes within interpolated code.                                              // 1191
  _.template = function(text, data, settings) {                                                          // 1192
    var render;                                                                                          // 1193
    settings = _.defaults({}, settings, _.templateSettings);                                             // 1194
                                                                                                         // 1195
    // Combine delimiters into one regular expression via alternation.                                   // 1196
    var matcher = new RegExp([                                                                           // 1197
      (settings.escape || noMatch).source,                                                               // 1198
      (settings.interpolate || noMatch).source,                                                          // 1199
      (settings.evaluate || noMatch).source                                                              // 1200
    ].join('|') + '|$', 'g');                                                                            // 1201
                                                                                                         // 1202
    // Compile the template source, escaping string literals appropriately.                              // 1203
    var index = 0;                                                                                       // 1204
    var source = "__p+='";                                                                               // 1205
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {                       // 1206
      source += text.slice(index, offset)                                                                // 1207
        .replace(escaper, function(match) { return '\\' + escapes[match]; });                            // 1208
                                                                                                         // 1209
      if (escape) {                                                                                      // 1210
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";                             // 1211
      }                                                                                                  // 1212
      if (interpolate) {                                                                                 // 1213
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";                                  // 1214
      }                                                                                                  // 1215
      if (evaluate) {                                                                                    // 1216
        source += "';\n" + evaluate + "\n__p+='";                                                        // 1217
      }                                                                                                  // 1218
      index = offset + match.length;                                                                     // 1219
      return match;                                                                                      // 1220
    });                                                                                                  // 1221
    source += "';\n";                                                                                    // 1222
                                                                                                         // 1223
    // If a variable is not specified, place data values in local scope.                                 // 1224
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';                                // 1225
                                                                                                         // 1226
    source = "var __t,__p='',__j=Array.prototype.join," +                                                // 1227
      "print=function(){__p+=__j.call(arguments,'');};\n" +                                              // 1228
      source + "return __p;\n";                                                                          // 1229
                                                                                                         // 1230
    try {                                                                                                // 1231
      render = new Function(settings.variable || 'obj', '_', source);                                    // 1232
    } catch (e) {                                                                                        // 1233
      e.source = source;                                                                                 // 1234
      throw e;                                                                                           // 1235
    }                                                                                                    // 1236
                                                                                                         // 1237
    if (data) return render(data, _);                                                                    // 1238
    var template = function(data) {                                                                      // 1239
      return render.call(this, data, _);                                                                 // 1240
    };                                                                                                   // 1241
                                                                                                         // 1242
    // Provide the compiled function source as a convenience for precompilation.                         // 1243
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';                // 1244
                                                                                                         // 1245
    return template;                                                                                     // 1246
  };                                                                                                     // 1247
                                                                                                         // 1248
  // Add a "chain" function, which will delegate to the wrapper.                                         // 1249
  _.chain = function(obj) {                                                                              // 1250
    return _(obj).chain();                                                                               // 1251
  };                                                                                                     // 1252
                                                                                                         // 1253
  // OOP                                                                                                 // 1254
  // ---------------                                                                                     // 1255
  // If Underscore is called as a function, it returns a wrapped object that                             // 1256
  // can be used OO-style. This wrapper holds altered versions of all the                                // 1257
  // underscore functions. Wrapped objects may be chained.                                               // 1258
                                                                                                         // 1259
  // Helper function to continue chaining intermediate results.                                          // 1260
  var result = function(obj) {                                                                           // 1261
    return this._chain ? _(obj).chain() : obj;                                                           // 1262
  };                                                                                                     // 1263
                                                                                                         // 1264
  // Add all of the Underscore functions to the wrapper object.                                          // 1265
  _.mixin(_);                                                                                            // 1266
                                                                                                         // 1267
  // Add all mutator Array functions to the wrapper.                                                     // 1268
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {                // 1269
    var method = ArrayProto[name];                                                                       // 1270
    _.prototype[name] = function() {                                                                     // 1271
      var obj = this._wrapped;                                                                           // 1272
      method.apply(obj, arguments);                                                                      // 1273
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];                      // 1274
      return result.call(this, obj);                                                                     // 1275
    };                                                                                                   // 1276
  });                                                                                                    // 1277
                                                                                                         // 1278
  // Add all accessor Array functions to the wrapper.                                                    // 1279
  each(['concat', 'join', 'slice'], function(name) {                                                     // 1280
    var method = ArrayProto[name];                                                                       // 1281
    _.prototype[name] = function() {                                                                     // 1282
      return result.call(this, method.apply(this._wrapped, arguments));                                  // 1283
    };                                                                                                   // 1284
  });                                                                                                    // 1285
                                                                                                         // 1286
  _.extend(_.prototype, {                                                                                // 1287
                                                                                                         // 1288
    // Start chaining a wrapped Underscore object.                                                       // 1289
    chain: function() {                                                                                  // 1290
      this._chain = true;                                                                                // 1291
      return this;                                                                                       // 1292
    },                                                                                                   // 1293
                                                                                                         // 1294
    // Extracts the result from a wrapped and chained object.                                            // 1295
    value: function() {                                                                                  // 1296
      return this._wrapped;                                                                              // 1297
    }                                                                                                    // 1298
                                                                                                         // 1299
  });                                                                                                    // 1300
                                                                                                         // 1301
}).call(this);                                                                                           // 1302
                                                                                                         // 1303
///////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                       //
// packages/underscore/post.js                                                                           //
//                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                         //
// This exports object was created in pre.js.  Now copy the `_` object from it                           // 1
// into the package-scope variable `_`, which will get exported.                                         // 2
_ = exports._;                                                                                           // 3
                                                                                                         // 4
///////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.underscore = {
  _: _
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var _ = Package.underscore._;

/* Package-scope variables */
var Meteor;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/client_environment.js                                                                  //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
/**                                                                                                       // 1
 * @summary The Meteor namespace                                                                          // 2
 * @namespace Meteor                                                                                      // 3
 */                                                                                                       // 4
Meteor = {                                                                                                // 5
                                                                                                          // 6
  /**                                                                                                     // 7
   * @summary Boolean variable.  True if running in client environment.                                   // 8
   * @locus Anywhere                                                                                      // 9
   * @static                                                                                              // 10
   * @type {Boolean}                                                                                      // 11
   */                                                                                                     // 12
  isClient: true,                                                                                         // 13
                                                                                                          // 14
  /**                                                                                                     // 15
   * @summary Boolean variable.  True if running in server environment.                                   // 16
   * @locus Anywhere                                                                                      // 17
   * @static                                                                                              // 18
   * @type {Boolean}                                                                                      // 19
   */                                                                                                     // 20
  isServer: false,                                                                                        // 21
  isCordova: false                                                                                        // 22
};                                                                                                        // 23
                                                                                                          // 24
if (typeof __meteor_runtime_config__ === 'object' &&                                                      // 25
    __meteor_runtime_config__.PUBLIC_SETTINGS) {                                                          // 26
  /**                                                                                                     // 27
   * @summary `Meteor.settings` contains deployment-specific configuration options. You can initialize settings by passing the `--settings` option (which takes the name of a file containing JSON data) to `meteor run` or `meteor deploy`. When running your server directly (e.g. from a bundle), you instead specify settings by putting the JSON directly into the `METEOR_SETTINGS` environment variable. If you don't provide any settings, `Meteor.settings` will be an empty object.  If the settings object contains a key named `public`, then `Meteor.settings.public` will be available on the client as well as the server.  All other properties of `Meteor.settings` are only defined on the server.
   * @locus Anywhere                                                                                      // 29
   * @type {Object}                                                                                       // 30
   */                                                                                                     // 31
  Meteor.settings = { 'public': __meteor_runtime_config__.PUBLIC_SETTINGS };                              // 32
}                                                                                                         // 33
                                                                                                          // 34
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/helpers.js                                                                             //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
if (Meteor.isServer)                                                                                      // 1
  var Future = Npm.require('fibers/future');                                                              // 2
                                                                                                          // 3
if (typeof __meteor_runtime_config__ === 'object' &&                                                      // 4
    __meteor_runtime_config__.meteorRelease) {                                                            // 5
  /**                                                                                                     // 6
   * @summary `Meteor.release` is a string containing the name of the [release](#meteorupdate) with which the project was built (for example, `"1.2.3"`). It is `undefined` if the project was built using a git checkout of Meteor.
   * @locus Anywhere                                                                                      // 8
   * @type {String}                                                                                       // 9
   */                                                                                                     // 10
  Meteor.release = __meteor_runtime_config__.meteorRelease;                                               // 11
}                                                                                                         // 12
                                                                                                          // 13
// XXX find a better home for these? Ideally they would be _.get,                                         // 14
// _.ensure, _.delete..                                                                                   // 15
                                                                                                          // 16
_.extend(Meteor, {                                                                                        // 17
  // _get(a,b,c,d) returns a[b][c][d], or else undefined if a[b] or                                       // 18
  // a[b][c] doesn't exist.                                                                               // 19
  //                                                                                                      // 20
  _get: function (obj /*, arguments */) {                                                                 // 21
    for (var i = 1; i < arguments.length; i++) {                                                          // 22
      if (!(arguments[i] in obj))                                                                         // 23
        return undefined;                                                                                 // 24
      obj = obj[arguments[i]];                                                                            // 25
    }                                                                                                     // 26
    return obj;                                                                                           // 27
  },                                                                                                      // 28
                                                                                                          // 29
  // _ensure(a,b,c,d) ensures that a[b][c][d] exists. If it does not,                                     // 30
  // it is created and set to {}. Either way, it is returned.                                             // 31
  //                                                                                                      // 32
  _ensure: function (obj /*, arguments */) {                                                              // 33
    for (var i = 1; i < arguments.length; i++) {                                                          // 34
      var key = arguments[i];                                                                             // 35
      if (!(key in obj))                                                                                  // 36
        obj[key] = {};                                                                                    // 37
      obj = obj[key];                                                                                     // 38
    }                                                                                                     // 39
                                                                                                          // 40
    return obj;                                                                                           // 41
  },                                                                                                      // 42
                                                                                                          // 43
  // _delete(a, b, c, d) deletes a[b][c][d], then a[b][c] unless it                                       // 44
  // isn't empty, then a[b] unless it isn't empty.                                                        // 45
  //                                                                                                      // 46
  _delete: function (obj /*, arguments */) {                                                              // 47
    var stack = [obj];                                                                                    // 48
    var leaf = true;                                                                                      // 49
    for (var i = 1; i < arguments.length - 1; i++) {                                                      // 50
      var key = arguments[i];                                                                             // 51
      if (!(key in obj)) {                                                                                // 52
        leaf = false;                                                                                     // 53
        break;                                                                                            // 54
      }                                                                                                   // 55
      obj = obj[key];                                                                                     // 56
      if (typeof obj !== "object")                                                                        // 57
        break;                                                                                            // 58
      stack.push(obj);                                                                                    // 59
    }                                                                                                     // 60
                                                                                                          // 61
    for (var i = stack.length - 1; i >= 0; i--) {                                                         // 62
      var key = arguments[i+1];                                                                           // 63
                                                                                                          // 64
      if (leaf)                                                                                           // 65
        leaf = false;                                                                                     // 66
      else                                                                                                // 67
        for (var other in stack[i][key])                                                                  // 68
          return; // not empty -- we're done                                                              // 69
                                                                                                          // 70
      delete stack[i][key];                                                                               // 71
    }                                                                                                     // 72
  },                                                                                                      // 73
                                                                                                          // 74
  // wrapAsync can wrap any function that takes some number of arguments that                             // 75
  // can't be undefined, followed by some optional arguments, where the callback                          // 76
  // is the last optional argument.                                                                       // 77
  // e.g. fs.readFile(pathname, [callback]),                                                              // 78
  // fs.open(pathname, flags, [mode], [callback])                                                         // 79
  // For maximum effectiveness and least confusion, wrapAsync should be used on                           // 80
  // functions where the callback is the only argument of type Function.                                  // 81
                                                                                                          // 82
  /**                                                                                                     // 83
   * @memberOf Meteor                                                                                     // 84
   * @summary Wrap a function that takes a callback function as its final parameter. On the server, the wrapped function can be used either synchronously (without passing a callback) or asynchronously (when a callback is passed). On the client, a callback is always required; errors will be logged if there is no callback. If a callback is provided, the environment captured when the original function was called will be restored in the callback.
   * @locus Anywhere                                                                                      // 86
   * @param {Function} func A function that takes a callback as its final parameter                       // 87
   * @param {Object} [context] Optional `this` object against which the original function will be invoked // 88
   */                                                                                                     // 89
  wrapAsync: function (fn, context) {                                                                     // 90
    return function (/* arguments */) {                                                                   // 91
      var self = context || this;                                                                         // 92
      var newArgs = _.toArray(arguments);                                                                 // 93
      var callback;                                                                                       // 94
                                                                                                          // 95
      for (var i = newArgs.length - 1; i >= 0; --i) {                                                     // 96
        var arg = newArgs[i];                                                                             // 97
        var type = typeof arg;                                                                            // 98
        if (type !== "undefined") {                                                                       // 99
          if (type === "function") {                                                                      // 100
            callback = arg;                                                                               // 101
          }                                                                                               // 102
          break;                                                                                          // 103
        }                                                                                                 // 104
      }                                                                                                   // 105
                                                                                                          // 106
      if (! callback) {                                                                                   // 107
        if (Meteor.isClient) {                                                                            // 108
          callback = logErr;                                                                              // 109
        } else {                                                                                          // 110
          var fut = new Future();                                                                         // 111
          callback = fut.resolver();                                                                      // 112
        }                                                                                                 // 113
        ++i; // Insert the callback just after arg.                                                       // 114
      }                                                                                                   // 115
                                                                                                          // 116
      newArgs[i] = Meteor.bindEnvironment(callback);                                                      // 117
      var result = fn.apply(self, newArgs);                                                               // 118
      return fut ? fut.wait() : result;                                                                   // 119
    };                                                                                                    // 120
  },                                                                                                      // 121
                                                                                                          // 122
  // Sets child's prototype to a new object whose prototype is parent's                                   // 123
  // prototype. Used as:                                                                                  // 124
  //   Meteor._inherits(ClassB, ClassA).                                                                  // 125
  //   _.extend(ClassB.prototype, { ... })                                                                // 126
  // Inspired by CoffeeScript's `extend` and Google Closure's `goog.inherits`.                            // 127
  _inherits: function (Child, Parent) {                                                                   // 128
    // copy Parent static properties                                                                      // 129
    for (var key in Parent) {                                                                             // 130
      // make sure we only copy hasOwnProperty properties vs. prototype                                   // 131
      // properties                                                                                       // 132
      if (_.has(Parent, key))                                                                             // 133
        Child[key] = Parent[key];                                                                         // 134
    }                                                                                                     // 135
                                                                                                          // 136
    // a middle member of prototype chain: takes the prototype from the Parent                            // 137
    var Middle = function () {                                                                            // 138
      this.constructor = Child;                                                                           // 139
    };                                                                                                    // 140
    Middle.prototype = Parent.prototype;                                                                  // 141
    Child.prototype = new Middle();                                                                       // 142
    Child.__super__ = Parent.prototype;                                                                   // 143
    return Child;                                                                                         // 144
  }                                                                                                       // 145
});                                                                                                       // 146
                                                                                                          // 147
var warnedAboutWrapAsync = false;                                                                         // 148
                                                                                                          // 149
/**                                                                                                       // 150
 * @deprecated in 0.9.3                                                                                   // 151
 */                                                                                                       // 152
Meteor._wrapAsync = function(fn, context) {                                                               // 153
  if (! warnedAboutWrapAsync) {                                                                           // 154
    Meteor._debug("Meteor._wrapAsync has been renamed to Meteor.wrapAsync");                              // 155
    warnedAboutWrapAsync = true;                                                                          // 156
  }                                                                                                       // 157
  return Meteor.wrapAsync.apply(Meteor, arguments);                                                       // 158
};                                                                                                        // 159
                                                                                                          // 160
function logErr(err) {                                                                                    // 161
  if (err) {                                                                                              // 162
    return Meteor._debug(                                                                                 // 163
      "Exception in callback of async function",                                                          // 164
      err.stack ? err.stack : err                                                                         // 165
    );                                                                                                    // 166
  }                                                                                                       // 167
}                                                                                                         // 168
                                                                                                          // 169
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/setimmediate.js                                                                        //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
// Chooses one of three setImmediate implementations:                                                     // 1
//                                                                                                        // 2
// * Native setImmediate (IE 10, Node 0.9+)                                                               // 3
//                                                                                                        // 4
// * postMessage (many browsers)                                                                          // 5
//                                                                                                        // 6
// * setTimeout  (fallback)                                                                               // 7
//                                                                                                        // 8
// The postMessage implementation is based on                                                             // 9
// https://github.com/NobleJS/setImmediate/tree/1.0.1                                                     // 10
//                                                                                                        // 11
// Don't use `nextTick` for Node since it runs its callbacks before                                       // 12
// I/O, which is stricter than we're looking for.                                                         // 13
//                                                                                                        // 14
// Not installed as a polyfill, as our public API is `Meteor.defer`.                                      // 15
// Since we're not trying to be a polyfill, we have some                                                  // 16
// simplifications:                                                                                       // 17
//                                                                                                        // 18
// If one invocation of a setImmediate callback pauses itself by a                                        // 19
// call to alert/prompt/showModelDialog, the NobleJS polyfill                                             // 20
// implementation ensured that no setImmedate callback would run until                                    // 21
// the first invocation completed.  While correct per the spec, what it                                   // 22
// would mean for us in practice is that any reactive updates relying                                     // 23
// on Meteor.defer would be hung in the main window until the modal                                       // 24
// dialog was dismissed.  Thus we only ensure that a setImmediate                                         // 25
// function is called in a later event loop.                                                              // 26
//                                                                                                        // 27
// We don't need to support using a string to be eval'ed for the                                          // 28
// callback, arguments to the function, or clearImmediate.                                                // 29
                                                                                                          // 30
"use strict";                                                                                             // 31
                                                                                                          // 32
var global = this;                                                                                        // 33
                                                                                                          // 34
                                                                                                          // 35
// IE 10, Node >= 9.1                                                                                     // 36
                                                                                                          // 37
function useSetImmediate() {                                                                              // 38
  if (! global.setImmediate)                                                                              // 39
    return null;                                                                                          // 40
  else {                                                                                                  // 41
    var setImmediate = function (fn) {                                                                    // 42
      global.setImmediate(fn);                                                                            // 43
    };                                                                                                    // 44
    setImmediate.implementation = 'setImmediate';                                                         // 45
    return setImmediate;                                                                                  // 46
  }                                                                                                       // 47
}                                                                                                         // 48
                                                                                                          // 49
                                                                                                          // 50
// Android 2.3.6, Chrome 26, Firefox 20, IE 8-9, iOS 5.1.1 Safari                                         // 51
                                                                                                          // 52
function usePostMessage() {                                                                               // 53
  // The test against `importScripts` prevents this implementation                                        // 54
  // from being installed inside a web worker, where                                                      // 55
  // `global.postMessage` means something completely different and                                        // 56
  // can't be used for this purpose.                                                                      // 57
                                                                                                          // 58
  if (!global.postMessage || global.importScripts) {                                                      // 59
    return null;                                                                                          // 60
  }                                                                                                       // 61
                                                                                                          // 62
  // Avoid synchronous post message implementations.                                                      // 63
                                                                                                          // 64
  var postMessageIsAsynchronous = true;                                                                   // 65
  var oldOnMessage = global.onmessage;                                                                    // 66
  global.onmessage = function () {                                                                        // 67
      postMessageIsAsynchronous = false;                                                                  // 68
  };                                                                                                      // 69
  global.postMessage("", "*");                                                                            // 70
  global.onmessage = oldOnMessage;                                                                        // 71
                                                                                                          // 72
  if (! postMessageIsAsynchronous)                                                                        // 73
    return null;                                                                                          // 74
                                                                                                          // 75
  var funcIndex = 0;                                                                                      // 76
  var funcs = {};                                                                                         // 77
                                                                                                          // 78
  // Installs an event handler on `global` for the `message` event: see                                   // 79
  // * https://developer.mozilla.org/en/DOM/window.postMessage                                            // 80
  // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages       // 81
                                                                                                          // 82
  // XXX use Random.id() here?                                                                            // 83
  var MESSAGE_PREFIX = "Meteor._setImmediate." + Math.random() + '.';                                     // 84
                                                                                                          // 85
  function isStringAndStartsWith(string, putativeStart) {                                                 // 86
    return (typeof string === "string" &&                                                                 // 87
            string.substring(0, putativeStart.length) === putativeStart);                                 // 88
  }                                                                                                       // 89
                                                                                                          // 90
  function onGlobalMessage(event) {                                                                       // 91
    // This will catch all incoming messages (even from other                                             // 92
    // windows!), so we need to try reasonably hard to avoid letting                                      // 93
    // anyone else trick us into firing off. We test the origin is                                        // 94
    // still this window, and that a (randomly generated)                                                 // 95
    // unpredictable identifying prefix is present.                                                       // 96
    if (event.source === global &&                                                                        // 97
        isStringAndStartsWith(event.data, MESSAGE_PREFIX)) {                                              // 98
      var index = event.data.substring(MESSAGE_PREFIX.length);                                            // 99
      try {                                                                                               // 100
        if (funcs[index])                                                                                 // 101
          funcs[index]();                                                                                 // 102
      }                                                                                                   // 103
      finally {                                                                                           // 104
        delete funcs[index];                                                                              // 105
      }                                                                                                   // 106
    }                                                                                                     // 107
  }                                                                                                       // 108
                                                                                                          // 109
  if (global.addEventListener) {                                                                          // 110
    global.addEventListener("message", onGlobalMessage, false);                                           // 111
  } else {                                                                                                // 112
    global.attachEvent("onmessage", onGlobalMessage);                                                     // 113
  }                                                                                                       // 114
                                                                                                          // 115
  var setImmediate = function (fn) {                                                                      // 116
    // Make `global` post a message to itself with the handle and                                         // 117
    // identifying prefix, thus asynchronously invoking our                                               // 118
    // onGlobalMessage listener above.                                                                    // 119
    ++funcIndex;                                                                                          // 120
    funcs[funcIndex] = fn;                                                                                // 121
    global.postMessage(MESSAGE_PREFIX + funcIndex, "*");                                                  // 122
  };                                                                                                      // 123
  setImmediate.implementation = 'postMessage';                                                            // 124
  return setImmediate;                                                                                    // 125
}                                                                                                         // 126
                                                                                                          // 127
                                                                                                          // 128
function useTimeout() {                                                                                   // 129
  var setImmediate = function (fn) {                                                                      // 130
    global.setTimeout(fn, 0);                                                                             // 131
  };                                                                                                      // 132
  setImmediate.implementation = 'setTimeout';                                                             // 133
  return setImmediate;                                                                                    // 134
}                                                                                                         // 135
                                                                                                          // 136
                                                                                                          // 137
Meteor._setImmediate =                                                                                    // 138
  useSetImmediate() ||                                                                                    // 139
  usePostMessage() ||                                                                                     // 140
  useTimeout();                                                                                           // 141
                                                                                                          // 142
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/timers.js                                                                              //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
var withoutInvocation = function (f) {                                                                    // 1
  if (Package.ddp) {                                                                                      // 2
    var _CurrentInvocation = Package.ddp.DDP._CurrentInvocation;                                          // 3
    if (_CurrentInvocation.get() && _CurrentInvocation.get().isSimulation)                                // 4
      throw new Error("Can't set timers inside simulations");                                             // 5
    return function () { _CurrentInvocation.withValue(null, f); };                                        // 6
  }                                                                                                       // 7
  else                                                                                                    // 8
    return f;                                                                                             // 9
};                                                                                                        // 10
                                                                                                          // 11
var bindAndCatch = function (context, f) {                                                                // 12
  return Meteor.bindEnvironment(withoutInvocation(f), context);                                           // 13
};                                                                                                        // 14
                                                                                                          // 15
_.extend(Meteor, {                                                                                        // 16
  // Meteor.setTimeout and Meteor.setInterval callbacks scheduled                                         // 17
  // inside a server method are not part of the method invocation and                                     // 18
  // should clear out the CurrentInvocation environment variable.                                         // 19
                                                                                                          // 20
  /**                                                                                                     // 21
   * @memberOf Meteor                                                                                     // 22
   * @summary Call a function in the future after waiting for a specified delay.                          // 23
   * @locus Anywhere                                                                                      // 24
   * @param {Function} func The function to run                                                           // 25
   * @param {Number} delay Number of milliseconds to wait before calling function                         // 26
   */                                                                                                     // 27
  setTimeout: function (f, duration) {                                                                    // 28
    return setTimeout(bindAndCatch("setTimeout callback", f), duration);                                  // 29
  },                                                                                                      // 30
                                                                                                          // 31
  /**                                                                                                     // 32
   * @memberOf Meteor                                                                                     // 33
   * @summary Call a function repeatedly, with a time delay between calls.                                // 34
   * @locus Anywhere                                                                                      // 35
   * @param {Function} func The function to run                                                           // 36
   * @param {Number} delay Number of milliseconds to wait between each function call.                     // 37
   */                                                                                                     // 38
  setInterval: function (f, duration) {                                                                   // 39
    return setInterval(bindAndCatch("setInterval callback", f), duration);                                // 40
  },                                                                                                      // 41
                                                                                                          // 42
  /**                                                                                                     // 43
   * @memberOf Meteor                                                                                     // 44
   * @summary Cancel a repeating function call scheduled by `Meteor.setInterval`.                         // 45
   * @locus Anywhere                                                                                      // 46
   * @param {Number} id The handle returned by `Meteor.setInterval`                                       // 47
   */                                                                                                     // 48
  clearInterval: function(x) {                                                                            // 49
    return clearInterval(x);                                                                              // 50
  },                                                                                                      // 51
                                                                                                          // 52
  /**                                                                                                     // 53
   * @memberOf Meteor                                                                                     // 54
   * @summary Cancel a function call scheduled by `Meteor.setTimeout`.                                    // 55
   * @locus Anywhere                                                                                      // 56
   * @param {Number} id The handle returned by `Meteor.setTimeout`                                        // 57
   */                                                                                                     // 58
  clearTimeout: function(x) {                                                                             // 59
    return clearTimeout(x);                                                                               // 60
  },                                                                                                      // 61
                                                                                                          // 62
  // XXX consider making this guarantee ordering of defer'd callbacks, like                               // 63
  // Tracker.afterFlush or Node's nextTick (in practice). Then tests can do:                              // 64
  //    callSomethingThatDefersSomeWork();                                                                // 65
  //    Meteor.defer(expect(somethingThatValidatesThatTheWorkHappened));                                  // 66
  defer: function (f) {                                                                                   // 67
    Meteor._setImmediate(bindAndCatch("defer callback", f));                                              // 68
  }                                                                                                       // 69
});                                                                                                       // 70
                                                                                                          // 71
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/errors.js                                                                              //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
// Makes an error subclass which properly contains a stack trace in most                                  // 1
// environments. constructor can set fields on `this` (and should probably set                            // 2
// `message`, which is what gets displayed at the top of a stack trace).                                  // 3
//                                                                                                        // 4
Meteor.makeErrorType = function (name, constructor) {                                                     // 5
  var errorClass = function (/*arguments*/) {                                                             // 6
    var self = this;                                                                                      // 7
                                                                                                          // 8
    // Ensure we get a proper stack trace in most Javascript environments                                 // 9
    if (Error.captureStackTrace) {                                                                        // 10
      // V8 environments (Chrome and Node.js)                                                             // 11
      Error.captureStackTrace(self, errorClass);                                                          // 12
    } else {                                                                                              // 13
      // Firefox                                                                                          // 14
      var e = new Error;                                                                                  // 15
      e.__proto__ = errorClass.prototype;                                                                 // 16
      if (e instanceof errorClass)                                                                        // 17
        self = e;                                                                                         // 18
    }                                                                                                     // 19
    // Safari magically works.                                                                            // 20
                                                                                                          // 21
    constructor.apply(self, arguments);                                                                   // 22
                                                                                                          // 23
    self.errorType = name;                                                                                // 24
                                                                                                          // 25
    return self;                                                                                          // 26
  };                                                                                                      // 27
                                                                                                          // 28
  Meteor._inherits(errorClass, Error);                                                                    // 29
                                                                                                          // 30
  return errorClass;                                                                                      // 31
};                                                                                                        // 32
                                                                                                          // 33
// This should probably be in the livedata package, but we don't want                                     // 34
// to require you to use the livedata package to get it. Eventually we                                    // 35
// should probably rename it to DDP.Error and put it back in the                                          // 36
// 'livedata' package (which we should rename to 'ddp' also.)                                             // 37
//                                                                                                        // 38
// Note: The DDP server assumes that Meteor.Error EJSON-serializes as an object                           // 39
// containing 'error' and optionally 'reason' and 'details'.                                              // 40
// The DDP client manually puts these into Meteor.Error objects. (We don't use                            // 41
// EJSON.addType here because the type is determined by location in the                                   // 42
// protocol, not text on the wire.)                                                                       // 43
                                                                                                          // 44
/**                                                                                                       // 45
 * @summary This class represents a symbolic error thrown by a method.                                    // 46
 * @locus Anywhere                                                                                        // 47
 * @class                                                                                                 // 48
 * @param {String} error A string code uniquely identifying this kind of error.                           // 49
 * This string should be used by callers of the method to determine the                                   // 50
 * appropriate action to take, instead of attempting to parse the reason                                  // 51
 * or details fields. For example:                                                                        // 52
 *                                                                                                        // 53
 * ```                                                                                                    // 54
 * // on the server, pick a code unique to this error                                                     // 55
 * // the reason field should be a useful debug message                                                   // 56
 * throw new Meteor.Error("logged-out",                                                                   // 57
 *   "The user must be logged in to post a comment.");                                                    // 58
 *                                                                                                        // 59
 * // on the client                                                                                       // 60
 * Meteor.call("methodName", function (error) {                                                           // 61
 *   // identify the error                                                                                // 62
 *   if (error.error === "logged-out") {                                                                  // 63
 *     // show a nice error message                                                                       // 64
 *     Session.set("errorMessage", "Please log in to post a comment.");                                   // 65
 *   }                                                                                                    // 66
 * });                                                                                                    // 67
 * ```                                                                                                    // 68
 *                                                                                                        // 69
 * For legacy reasons, some built-in Meteor functions such as `check` throw                               // 70
 * errors with a number in this field.                                                                    // 71
 *                                                                                                        // 72
 * @param {String} [reason] Optional.  A short human-readable summary of the                              // 73
 * error, like 'Not Found'.                                                                               // 74
 * @param {String} [details] Optional.  Additional information about the error,                           // 75
 * like a textual stack trace.                                                                            // 76
 */                                                                                                       // 77
Meteor.Error = Meteor.makeErrorType(                                                                      // 78
  "Meteor.Error",                                                                                         // 79
  function (error, reason, details) {                                                                     // 80
    var self = this;                                                                                      // 81
                                                                                                          // 82
    // Currently, a numeric code, likely similar to a HTTP code (eg,                                      // 83
    // 404, 500). That is likely to change though.                                                        // 84
    self.error = error;                                                                                   // 85
                                                                                                          // 86
    // Optional: A short human-readable summary of the error. Not                                         // 87
    // intended to be shown to end users, just developers. ("Not Found",                                  // 88
    // "Internal Server Error")                                                                           // 89
    self.reason = reason;                                                                                 // 90
                                                                                                          // 91
    // Optional: Additional information about the error, say for                                          // 92
    // debugging. It might be a (textual) stack trace if the server is                                    // 93
    // willing to provide one. The corresponding thing in HTTP would be                                   // 94
    // the body of a 404 or 500 response. (The difference is that we                                      // 95
    // never expect this to be shown to end users, only developers, so                                    // 96
    // it doesn't need to be pretty.)                                                                     // 97
    self.details = details;                                                                               // 98
                                                                                                          // 99
    // This is what gets displayed at the top of a stack trace. Current                                   // 100
    // format is "[404]" (if no reason is set) or "File not found [404]"                                  // 101
    if (self.reason)                                                                                      // 102
      self.message = self.reason + ' [' + self.error + ']';                                               // 103
    else                                                                                                  // 104
      self.message = '[' + self.error + ']';                                                              // 105
  });                                                                                                     // 106
                                                                                                          // 107
// Meteor.Error is basically data and is sent over DDP, so you should be able to                          // 108
// properly EJSON-clone it. This is especially important because if a                                     // 109
// Meteor.Error is thrown through a Future, the error, reason, and details                                // 110
// properties become non-enumerable so a standard Object clone won't preserve                             // 111
// them and they will be lost from DDP.                                                                   // 112
Meteor.Error.prototype.clone = function () {                                                              // 113
  var self = this;                                                                                        // 114
  return new Meteor.Error(self.error, self.reason, self.details);                                         // 115
};                                                                                                        // 116
                                                                                                          // 117
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/fiber_stubs_client.js                                                                  //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
// This file is a partial analogue to fiber_helpers.js, which allows the client                           // 1
// to use a queue too, and also to call noYieldsAllowed.                                                  // 2
                                                                                                          // 3
// The client has no ability to yield, so noYieldsAllowed is a noop.                                      // 4
//                                                                                                        // 5
Meteor._noYieldsAllowed = function (f) {                                                                  // 6
  return f();                                                                                             // 7
};                                                                                                        // 8
                                                                                                          // 9
// An even simpler queue of tasks than the fiber-enabled one.  This one just                              // 10
// runs all the tasks when you call runTask or flush, synchronously.                                      // 11
//                                                                                                        // 12
Meteor._SynchronousQueue = function () {                                                                  // 13
  var self = this;                                                                                        // 14
  self._tasks = [];                                                                                       // 15
  self._running = false;                                                                                  // 16
  self._runTimeout = null;                                                                                // 17
};                                                                                                        // 18
                                                                                                          // 19
_.extend(Meteor._SynchronousQueue.prototype, {                                                            // 20
  runTask: function (task) {                                                                              // 21
    var self = this;                                                                                      // 22
    if (!self.safeToRunTask())                                                                            // 23
      throw new Error("Could not synchronously run a task from a running task");                          // 24
    self._tasks.push(task);                                                                               // 25
    var tasks = self._tasks;                                                                              // 26
    self._tasks = [];                                                                                     // 27
    self._running = true;                                                                                 // 28
                                                                                                          // 29
    if (self._runTimeout) {                                                                               // 30
      // Since we're going to drain the queue, we can forget about the timeout                            // 31
      // which tries to run it.  (But if one of our tasks queues something else,                          // 32
      // the timeout will be correctly re-created.)                                                       // 33
      clearTimeout(self._runTimeout);                                                                     // 34
      self._runTimeout = null;                                                                            // 35
    }                                                                                                     // 36
                                                                                                          // 37
    try {                                                                                                 // 38
      while (!_.isEmpty(tasks)) {                                                                         // 39
        var t = tasks.shift();                                                                            // 40
        try {                                                                                             // 41
          t();                                                                                            // 42
        } catch (e) {                                                                                     // 43
          if (_.isEmpty(tasks)) {                                                                         // 44
            // this was the last task, that is, the one we're calling runTask                             // 45
            // for.                                                                                       // 46
            throw e;                                                                                      // 47
          } else {                                                                                        // 48
            Meteor._debug("Exception in queued task: " + e.stack);                                        // 49
          }                                                                                               // 50
        }                                                                                                 // 51
      }                                                                                                   // 52
    } finally {                                                                                           // 53
      self._running = false;                                                                              // 54
    }                                                                                                     // 55
  },                                                                                                      // 56
                                                                                                          // 57
  queueTask: function (task) {                                                                            // 58
    var self = this;                                                                                      // 59
    self._tasks.push(task);                                                                               // 60
    // Intentionally not using Meteor.setTimeout, because it doesn't like runing                          // 61
    // in stubs for now.                                                                                  // 62
    if (!self._runTimeout) {                                                                              // 63
      self._runTimeout = setTimeout(_.bind(self.flush, self), 0);                                         // 64
    }                                                                                                     // 65
  },                                                                                                      // 66
                                                                                                          // 67
  flush: function () {                                                                                    // 68
    var self = this;                                                                                      // 69
    self.runTask(function () {});                                                                         // 70
  },                                                                                                      // 71
                                                                                                          // 72
  drain: function () {                                                                                    // 73
    var self = this;                                                                                      // 74
    if (!self.safeToRunTask())                                                                            // 75
      return;                                                                                             // 76
    while (!_.isEmpty(self._tasks)) {                                                                     // 77
      self.flush();                                                                                       // 78
    }                                                                                                     // 79
  },                                                                                                      // 80
                                                                                                          // 81
  safeToRunTask: function () {                                                                            // 82
    var self = this;                                                                                      // 83
    return !self._running;                                                                                // 84
  }                                                                                                       // 85
});                                                                                                       // 86
                                                                                                          // 87
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/startup_client.js                                                                      //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
var queue = [];                                                                                           // 1
var loaded = !Meteor.isCordova &&                                                                         // 2
  (document.readyState === "loaded" || document.readyState == "complete");                                // 3
                                                                                                          // 4
var awaitingEventsCount = 1;                                                                              // 5
var ready = function() {                                                                                  // 6
  awaitingEventsCount--;                                                                                  // 7
  if (awaitingEventsCount > 0)                                                                            // 8
    return;                                                                                               // 9
                                                                                                          // 10
  loaded = true;                                                                                          // 11
  var runStartupCallbacks = function () {                                                                 // 12
    if (Meteor.isCordova) {                                                                               // 13
      if (! cordova.plugins || ! cordova.plugins.CordovaUpdate) {                                         // 14
        // XXX This timeout should not be necessary.                                                      // 15
        // Cordova indicates that all the cordova plugins files have been loaded                          // 16
        // and plugins are ready to be used when the "deviceready" callback                               // 17
        // fires. Even though we wait for the "deviceready" event, plugins                                // 18
        // have been observed to still not be not ready (likely a Cordova bug).                           // 19
        // We check the availability of the Cordova-Update plugin (the only                               // 20
        // plugin that we always include for sure) and retry a bit later if it                            // 21
        // is nowhere to be found. Experiments have found that either all                                 // 22
        // plugins are attached or none.                                                                  // 23
        Meteor.setTimeout(runStartupCallbacks, 20);                                                       // 24
        return;                                                                                           // 25
      }                                                                                                   // 26
    }                                                                                                     // 27
                                                                                                          // 28
    while (queue.length)                                                                                  // 29
      (queue.shift())();                                                                                  // 30
  };                                                                                                      // 31
  runStartupCallbacks();                                                                                  // 32
};                                                                                                        // 33
                                                                                                          // 34
if (document.addEventListener) {                                                                          // 35
  document.addEventListener('DOMContentLoaded', ready, false);                                            // 36
                                                                                                          // 37
  if (Meteor.isCordova) {                                                                                 // 38
    awaitingEventsCount++;                                                                                // 39
    document.addEventListener('deviceready', ready, false);                                               // 40
  }                                                                                                       // 41
                                                                                                          // 42
  window.addEventListener('load', ready, false);                                                          // 43
} else {                                                                                                  // 44
  document.attachEvent('onreadystatechange', function () {                                                // 45
    if (document.readyState === "complete")                                                               // 46
      ready();                                                                                            // 47
  });                                                                                                     // 48
  window.attachEvent('load', ready);                                                                      // 49
}                                                                                                         // 50
                                                                                                          // 51
/**                                                                                                       // 52
 * @summary Run code when a client or a server starts.                                                    // 53
 * @locus Anywhere                                                                                        // 54
 * @param {Function} func A function to run on startup.                                                   // 55
 */                                                                                                       // 56
Meteor.startup = function (cb) {                                                                          // 57
  var doScroll = !document.addEventListener &&                                                            // 58
    document.documentElement.doScroll;                                                                    // 59
                                                                                                          // 60
  if (!doScroll || window !== top) {                                                                      // 61
    if (loaded)                                                                                           // 62
      cb();                                                                                               // 63
    else                                                                                                  // 64
      queue.push(cb);                                                                                     // 65
  } else {                                                                                                // 66
    try { doScroll('left'); }                                                                             // 67
    catch (e) {                                                                                           // 68
      setTimeout(function() { Meteor.startup(cb); }, 50);                                                 // 69
      return;                                                                                             // 70
    };                                                                                                    // 71
    cb();                                                                                                 // 72
  }                                                                                                       // 73
};                                                                                                        // 74
                                                                                                          // 75
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/debug.js                                                                               //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
var suppress = 0;                                                                                         // 1
                                                                                                          // 2
// replacement for console.log. This is a temporary API. We should                                        // 3
// provide a real logging API soon (possibly just a polyfill for                                          // 4
// console?)                                                                                              // 5
//                                                                                                        // 6
// NOTE: this is used on the server to print the warning about                                            // 7
// having autopublish enabled when you probably meant to turn it                                          // 8
// off. it's not really the proper use of something called                                                // 9
// _debug. the intent is for this message to go to the terminal and                                       // 10
// be very visible. if you change _debug to go someplace else, etc,                                       // 11
// please fix the autopublish code to do something reasonable.                                            // 12
//                                                                                                        // 13
Meteor._debug = function (/* arguments */) {                                                              // 14
  if (suppress) {                                                                                         // 15
    suppress--;                                                                                           // 16
    return;                                                                                               // 17
  }                                                                                                       // 18
  if (typeof console !== 'undefined' &&                                                                   // 19
      typeof console.log !== 'undefined') {                                                               // 20
    if (arguments.length == 0) { // IE Companion breaks otherwise                                         // 21
      // IE10 PP4 requires at least one argument                                                          // 22
      console.log('');                                                                                    // 23
    } else {                                                                                              // 24
      // IE doesn't have console.log.apply, it's not a real Object.                                       // 25
      // http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9                  // 26
      // http://patik.com/blog/complete-cross-browser-console-log/                                        // 27
      if (typeof console.log.apply === "function") {                                                      // 28
        // Most browsers                                                                                  // 29
                                                                                                          // 30
        // Chrome and Safari only hyperlink URLs to source files in first argument of                     // 31
        // console.log, so try to call it with one argument if possible.                                  // 32
        // Approach taken here: If all arguments are strings, join them on space.                         // 33
        // See https://github.com/meteor/meteor/pull/732#issuecomment-13975991                            // 34
        var allArgumentsOfTypeString = true;                                                              // 35
        for (var i = 0; i < arguments.length; i++)                                                        // 36
          if (typeof arguments[i] !== "string")                                                           // 37
            allArgumentsOfTypeString = false;                                                             // 38
                                                                                                          // 39
        if (allArgumentsOfTypeString)                                                                     // 40
          console.log.apply(console, [Array.prototype.join.call(arguments, " ")]);                        // 41
        else                                                                                              // 42
          console.log.apply(console, arguments);                                                          // 43
                                                                                                          // 44
      } else if (typeof Function.prototype.bind === "function") {                                         // 45
        // IE9                                                                                            // 46
        var log = Function.prototype.bind.call(console.log, console);                                     // 47
        log.apply(console, arguments);                                                                    // 48
      } else {                                                                                            // 49
        // IE8                                                                                            // 50
        Function.prototype.call.call(console.log, console, Array.prototype.slice.call(arguments));        // 51
      }                                                                                                   // 52
    }                                                                                                     // 53
  }                                                                                                       // 54
};                                                                                                        // 55
                                                                                                          // 56
// Suppress the next 'count' Meteor._debug messsages. Use this to                                         // 57
// stop tests from spamming the console.                                                                  // 58
//                                                                                                        // 59
Meteor._suppress_log = function (count) {                                                                 // 60
  suppress += count;                                                                                      // 61
};                                                                                                        // 62
                                                                                                          // 63
Meteor._supressed_log_expected = function () {                                                            // 64
  return suppress !== 0;                                                                                  // 65
};                                                                                                        // 66
                                                                                                          // 67
                                                                                                          // 68
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/dynamics_browser.js                                                                    //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
// Simple implementation of dynamic scoping, for use in browsers                                          // 1
                                                                                                          // 2
var nextSlot = 0;                                                                                         // 3
var currentValues = [];                                                                                   // 4
                                                                                                          // 5
Meteor.EnvironmentVariable = function () {                                                                // 6
  this.slot = nextSlot++;                                                                                 // 7
};                                                                                                        // 8
                                                                                                          // 9
_.extend(Meteor.EnvironmentVariable.prototype, {                                                          // 10
  get: function () {                                                                                      // 11
    return currentValues[this.slot];                                                                      // 12
  },                                                                                                      // 13
                                                                                                          // 14
  getOrNullIfOutsideFiber: function () {                                                                  // 15
    return this.get();                                                                                    // 16
  },                                                                                                      // 17
                                                                                                          // 18
  withValue: function (value, func) {                                                                     // 19
    var saved = currentValues[this.slot];                                                                 // 20
    try {                                                                                                 // 21
      currentValues[this.slot] = value;                                                                   // 22
      var ret = func();                                                                                   // 23
    } finally {                                                                                           // 24
      currentValues[this.slot] = saved;                                                                   // 25
    }                                                                                                     // 26
    return ret;                                                                                           // 27
  }                                                                                                       // 28
});                                                                                                       // 29
                                                                                                          // 30
Meteor.bindEnvironment = function (func, onException, _this) {                                            // 31
  // needed in order to be able to create closures inside func and                                        // 32
  // have the closed variables not change back to their original                                          // 33
  // values                                                                                               // 34
  var boundValues = _.clone(currentValues);                                                               // 35
                                                                                                          // 36
  if (!onException || typeof(onException) === 'string') {                                                 // 37
    var description = onException || "callback of async function";                                        // 38
    onException = function (error) {                                                                      // 39
      Meteor._debug(                                                                                      // 40
        "Exception in " + description + ":",                                                              // 41
        error && error.stack || error                                                                     // 42
      );                                                                                                  // 43
    };                                                                                                    // 44
  }                                                                                                       // 45
                                                                                                          // 46
  return function (/* arguments */) {                                                                     // 47
    var savedValues = currentValues;                                                                      // 48
    try {                                                                                                 // 49
      currentValues = boundValues;                                                                        // 50
      var ret = func.apply(_this, _.toArray(arguments));                                                  // 51
    } catch (e) {                                                                                         // 52
      // note: callback-hook currently relies on the fact that if onException                             // 53
      // throws in the browser, the wrapped call throws.                                                  // 54
      onException(e);                                                                                     // 55
    } finally {                                                                                           // 56
      currentValues = savedValues;                                                                        // 57
    }                                                                                                     // 58
    return ret;                                                                                           // 59
  };                                                                                                      // 60
};                                                                                                        // 61
                                                                                                          // 62
Meteor._nodeCodeMustBeInFiber = function () {                                                             // 63
  // no-op on browser                                                                                     // 64
};                                                                                                        // 65
                                                                                                          // 66
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/meteor/url_common.js                                                                          //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
/**                                                                                                       // 1
 * @summary Generate an absolute URL pointing to the application. The server reads from the `ROOT_URL` environment variable to determine where it is running. This is taken care of automatically for apps deployed with `meteor deploy`, but must be provided when using `meteor build`.
 * @locus Anywhere                                                                                        // 3
 * @param {String} [path] A path to append to the root URL. Do not include a leading "`/`".               // 4
 * @param {Object} [options]                                                                              // 5
 * @param {Boolean} options.secure Create an HTTPS URL.                                                   // 6
 * @param {Boolean} options.replaceLocalhost Replace localhost with 127.0.0.1. Useful for services that don't recognize localhost as a domain name.
 * @param {String} options.rootUrl Override the default ROOT_URL from the server environment. For example: "`http://foo.example.com`"
 */                                                                                                       // 9
Meteor.absoluteUrl = function (path, options) {                                                           // 10
  // path is optional                                                                                     // 11
  if (!options && typeof path === 'object') {                                                             // 12
    options = path;                                                                                       // 13
    path = undefined;                                                                                     // 14
  }                                                                                                       // 15
  // merge options with defaults                                                                          // 16
  options = _.extend({}, Meteor.absoluteUrl.defaultOptions, options || {});                               // 17
                                                                                                          // 18
  var url = options.rootUrl;                                                                              // 19
  if (!url)                                                                                               // 20
    throw new Error("Must pass options.rootUrl or set ROOT_URL in the server environment");               // 21
                                                                                                          // 22
  if (!/^http[s]?:\/\//i.test(url)) // url starts with 'http://' or 'https://'                            // 23
    url = 'http://' + url; // we will later fix to https if options.secure is set                         // 24
                                                                                                          // 25
  if (!/\/$/.test(url)) // url ends with '/'                                                              // 26
    url += '/';                                                                                           // 27
                                                                                                          // 28
  if (path)                                                                                               // 29
    url += path;                                                                                          // 30
                                                                                                          // 31
  // turn http to https if secure option is set, and we're not talking                                    // 32
  // to localhost.                                                                                        // 33
  if (options.secure &&                                                                                   // 34
      /^http:/.test(url) && // url starts with 'http:'                                                    // 35
      !/http:\/\/localhost[:\/]/.test(url) && // doesn't match localhost                                  // 36
      !/http:\/\/127\.0\.0\.1[:\/]/.test(url)) // or 127.0.0.1                                            // 37
    url = url.replace(/^http:/, 'https:');                                                                // 38
                                                                                                          // 39
  if (options.replaceLocalhost)                                                                           // 40
    url = url.replace(/^http:\/\/localhost([:\/].*)/, 'http://127.0.0.1$1');                              // 41
                                                                                                          // 42
  return url;                                                                                             // 43
};                                                                                                        // 44
                                                                                                          // 45
// allow later packages to override default options                                                       // 46
Meteor.absoluteUrl.defaultOptions = { };                                                                  // 47
if (typeof __meteor_runtime_config__ === "object" &&                                                      // 48
    __meteor_runtime_config__.ROOT_URL)                                                                   // 49
  Meteor.absoluteUrl.defaultOptions.rootUrl = __meteor_runtime_config__.ROOT_URL;                         // 50
                                                                                                          // 51
                                                                                                          // 52
Meteor._relativeToSiteRootUrl = function (link) {                                                         // 53
  if (typeof __meteor_runtime_config__ === "object" &&                                                    // 54
      link.substr(0, 1) === "/")                                                                          // 55
    link = (__meteor_runtime_config__.ROOT_URL_PATH_PREFIX || "") + link;                                 // 56
  return link;                                                                                            // 57
};                                                                                                        // 58
                                                                                                          // 59
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.meteor = {
  Meteor: Meteor
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

/* Package-scope variables */
var Base64;

(function () {

//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
// packages/base64/base64.js                                                            //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////
                                                                                        //
// Base 64 encoding                                                                     // 1
                                                                                        // 2
var BASE_64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // 3
                                                                                        // 4
var BASE_64_VALS = {};                                                                  // 5
                                                                                        // 6
for (var i = 0; i < BASE_64_CHARS.length; i++) {                                        // 7
  BASE_64_VALS[BASE_64_CHARS.charAt(i)] = i;                                            // 8
};                                                                                      // 9
                                                                                        // 10
Base64 = {};                                                                            // 11
                                                                                        // 12
Base64.encode = function (array) {                                                      // 13
                                                                                        // 14
  if (typeof array === "string") {                                                      // 15
    var str = array;                                                                    // 16
    array = Base64.newBinary(str.length);                                               // 17
    for (var i = 0; i < str.length; i++) {                                              // 18
      var ch = str.charCodeAt(i);                                                       // 19
      if (ch > 0xFF) {                                                                  // 20
        throw new Error(                                                                // 21
          "Not ascii. Base64.encode can only take ascii strings.");                     // 22
      }                                                                                 // 23
      array[i] = ch;                                                                    // 24
    }                                                                                   // 25
  }                                                                                     // 26
                                                                                        // 27
  var answer = [];                                                                      // 28
  var a = null;                                                                         // 29
  var b = null;                                                                         // 30
  var c = null;                                                                         // 31
  var d = null;                                                                         // 32
  for (var i = 0; i < array.length; i++) {                                              // 33
    switch (i % 3) {                                                                    // 34
    case 0:                                                                             // 35
      a = (array[i] >> 2) & 0x3F;                                                       // 36
      b = (array[i] & 0x03) << 4;                                                       // 37
      break;                                                                            // 38
    case 1:                                                                             // 39
      b = b | (array[i] >> 4) & 0xF;                                                    // 40
      c = (array[i] & 0xF) << 2;                                                        // 41
      break;                                                                            // 42
    case 2:                                                                             // 43
      c = c | (array[i] >> 6) & 0x03;                                                   // 44
      d = array[i] & 0x3F;                                                              // 45
      answer.push(getChar(a));                                                          // 46
      answer.push(getChar(b));                                                          // 47
      answer.push(getChar(c));                                                          // 48
      answer.push(getChar(d));                                                          // 49
      a = null;                                                                         // 50
      b = null;                                                                         // 51
      c = null;                                                                         // 52
      d = null;                                                                         // 53
      break;                                                                            // 54
    }                                                                                   // 55
  }                                                                                     // 56
  if (a != null) {                                                                      // 57
    answer.push(getChar(a));                                                            // 58
    answer.push(getChar(b));                                                            // 59
    if (c == null)                                                                      // 60
      answer.push('=');                                                                 // 61
    else                                                                                // 62
      answer.push(getChar(c));                                                          // 63
    if (d == null)                                                                      // 64
      answer.push('=');                                                                 // 65
  }                                                                                     // 66
  return answer.join("");                                                               // 67
};                                                                                      // 68
                                                                                        // 69
var getChar = function (val) {                                                          // 70
  return BASE_64_CHARS.charAt(val);                                                     // 71
};                                                                                      // 72
                                                                                        // 73
var getVal = function (ch) {                                                            // 74
  if (ch === '=') {                                                                     // 75
    return -1;                                                                          // 76
  }                                                                                     // 77
  return BASE_64_VALS[ch];                                                              // 78
};                                                                                      // 79
                                                                                        // 80
// XXX This is a weird place for this to live, but it's used both by                    // 81
// this package and 'ejson', and we can't put it in 'ejson' without                     // 82
// introducing a circular dependency. It should probably be in its own                  // 83
// package or as a helper in a package that both 'base64' and 'ejson'                   // 84
// use.                                                                                 // 85
Base64.newBinary = function (len) {                                                     // 86
  if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {        // 87
    var ret = [];                                                                       // 88
    for (var i = 0; i < len; i++) {                                                     // 89
      ret.push(0);                                                                      // 90
    }                                                                                   // 91
    ret.$Uint8ArrayPolyfill = true;                                                     // 92
    return ret;                                                                         // 93
  }                                                                                     // 94
  return new Uint8Array(new ArrayBuffer(len));                                          // 95
};                                                                                      // 96
                                                                                        // 97
Base64.decode = function (str) {                                                        // 98
  var len = Math.floor((str.length*3)/4);                                               // 99
  if (str.charAt(str.length - 1) == '=') {                                              // 100
    len--;                                                                              // 101
    if (str.charAt(str.length - 2) == '=')                                              // 102
      len--;                                                                            // 103
  }                                                                                     // 104
  var arr = Base64.newBinary(len);                                                      // 105
                                                                                        // 106
  var one = null;                                                                       // 107
  var two = null;                                                                       // 108
  var three = null;                                                                     // 109
                                                                                        // 110
  var j = 0;                                                                            // 111
                                                                                        // 112
  for (var i = 0; i < str.length; i++) {                                                // 113
    var c = str.charAt(i);                                                              // 114
    var v = getVal(c);                                                                  // 115
    switch (i % 4) {                                                                    // 116
    case 0:                                                                             // 117
      if (v < 0)                                                                        // 118
        throw new Error('invalid base64 string');                                       // 119
      one = v << 2;                                                                     // 120
      break;                                                                            // 121
    case 1:                                                                             // 122
      if (v < 0)                                                                        // 123
        throw new Error('invalid base64 string');                                       // 124
      one = one | (v >> 4);                                                             // 125
      arr[j++] = one;                                                                   // 126
      two = (v & 0x0F) << 4;                                                            // 127
      break;                                                                            // 128
    case 2:                                                                             // 129
      if (v >= 0) {                                                                     // 130
        two = two | (v >> 2);                                                           // 131
        arr[j++] = two;                                                                 // 132
        three = (v & 0x03) << 6;                                                        // 133
      }                                                                                 // 134
      break;                                                                            // 135
    case 3:                                                                             // 136
      if (v >= 0) {                                                                     // 137
        arr[j++] = three | v;                                                           // 138
      }                                                                                 // 139
      break;                                                                            // 140
    }                                                                                   // 141
  }                                                                                     // 142
  return arr;                                                                           // 143
};                                                                                      // 144
                                                                                        // 145
//////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.base64 = {
  Base64: Base64
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

/* Package-scope variables */
var JSON;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/json/json_native.js                                                                           //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
// Do we already have a global JSON object? Export it as our JSON object.                                 // 1
if (window.JSON)                                                                                          // 2
  JSON = window.JSON;                                                                                     // 3
                                                                                                          // 4
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                        //
// packages/json/json2.js                                                                                 //
//                                                                                                        //
////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                          //
/*                                                                                                        // 1
    json2.js                                                                                              // 2
    2012-10-08                                                                                            // 3
                                                                                                          // 4
    Public Domain.                                                                                        // 5
                                                                                                          // 6
    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.                                               // 7
                                                                                                          // 8
    See http://www.JSON.org/js.html                                                                       // 9
                                                                                                          // 10
                                                                                                          // 11
    This code should be minified before deployment.                                                       // 12
    See http://javascript.crockford.com/jsmin.html                                                        // 13
                                                                                                          // 14
    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO                            // 15
    NOT CONTROL.                                                                                          // 16
                                                                                                          // 17
                                                                                                          // 18
    This file creates a global JSON object containing two methods: stringify                              // 19
    and parse.                                                                                            // 20
                                                                                                          // 21
        JSON.stringify(value, replacer, space)                                                            // 22
            value       any JavaScript value, usually an object or array.                                 // 23
                                                                                                          // 24
            replacer    an optional parameter that determines how object                                  // 25
                        values are stringified for objects. It can be a                                   // 26
                        function or an array of strings.                                                  // 27
                                                                                                          // 28
            space       an optional parameter that specifies the indentation                              // 29
                        of nested structures. If it is omitted, the text will                             // 30
                        be packed without extra whitespace. If it is a number,                            // 31
                        it will specify the number of spaces to indent at each                            // 32
                        level. If it is a string (such as '\t' or '&nbsp;'),                              // 33
                        it contains the characters used to indent at each level.                          // 34
                                                                                                          // 35
            This method produces a JSON text from a JavaScript value.                                     // 36
                                                                                                          // 37
            When an object value is found, if the object contains a toJSON                                // 38
            method, its toJSON method will be called and the result will be                               // 39
            stringified. A toJSON method does not serialize: it returns the                               // 40
            value represented by the name/value pair that should be serialized,                           // 41
            or undefined if nothing should be serialized. The toJSON method                               // 42
            will be passed the key associated with the value, and this will be                            // 43
            bound to the value                                                                            // 44
                                                                                                          // 45
            For example, this would serialize Dates as ISO strings.                                       // 46
                                                                                                          // 47
                Date.prototype.toJSON = function (key) {                                                  // 48
                    function f(n) {                                                                       // 49
                        // Format integers to have at least two digits.                                   // 50
                        return n < 10 ? '0' + n : n;                                                      // 51
                    }                                                                                     // 52
                                                                                                          // 53
                    return this.getUTCFullYear()   + '-' +                                                // 54
                         f(this.getUTCMonth() + 1) + '-' +                                                // 55
                         f(this.getUTCDate())      + 'T' +                                                // 56
                         f(this.getUTCHours())     + ':' +                                                // 57
                         f(this.getUTCMinutes())   + ':' +                                                // 58
                         f(this.getUTCSeconds())   + 'Z';                                                 // 59
                };                                                                                        // 60
                                                                                                          // 61
            You can provide an optional replacer method. It will be passed the                            // 62
            key and value of each member, with this bound to the containing                               // 63
            object. The value that is returned from your method will be                                   // 64
            serialized. If your method returns undefined, then the member will                            // 65
            be excluded from the serialization.                                                           // 66
                                                                                                          // 67
            If the replacer parameter is an array of strings, then it will be                             // 68
            used to select the members to be serialized. It filters the results                           // 69
            such that only members with keys listed in the replacer array are                             // 70
            stringified.                                                                                  // 71
                                                                                                          // 72
            Values that do not have JSON representations, such as undefined or                            // 73
            functions, will not be serialized. Such values in objects will be                             // 74
            dropped; in arrays they will be replaced with null. You can use                               // 75
            a replacer function to replace those with JSON values.                                        // 76
            JSON.stringify(undefined) returns undefined.                                                  // 77
                                                                                                          // 78
            The optional space parameter produces a stringification of the                                // 79
            value that is filled with line breaks and indentation to make it                              // 80
            easier to read.                                                                               // 81
                                                                                                          // 82
            If the space parameter is a non-empty string, then that string will                           // 83
            be used for indentation. If the space parameter is a number, then                             // 84
            the indentation will be that many spaces.                                                     // 85
                                                                                                          // 86
            Example:                                                                                      // 87
                                                                                                          // 88
            text = JSON.stringify(['e', {pluribus: 'unum'}]);                                             // 89
            // text is '["e",{"pluribus":"unum"}]'                                                        // 90
                                                                                                          // 91
                                                                                                          // 92
            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');                                 // 93
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'                                   // 94
                                                                                                          // 95
            text = JSON.stringify([new Date()], function (key, value) {                                   // 96
                return this[key] instanceof Date ?                                                        // 97
                    'Date(' + this[key] + ')' : value;                                                    // 98
            });                                                                                           // 99
            // text is '["Date(---current time---)"]'                                                     // 100
                                                                                                          // 101
                                                                                                          // 102
        JSON.parse(text, reviver)                                                                         // 103
            This method parses a JSON text to produce an object or array.                                 // 104
            It can throw a SyntaxError exception.                                                         // 105
                                                                                                          // 106
            The optional reviver parameter is a function that can filter and                              // 107
            transform the results. It receives each of the keys and values,                               // 108
            and its return value is used instead of the original value.                                   // 109
            If it returns what it received, then the structure is not modified.                           // 110
            If it returns undefined then the member is deleted.                                           // 111
                                                                                                          // 112
            Example:                                                                                      // 113
                                                                                                          // 114
            // Parse the text. Values that look like ISO date strings will                                // 115
            // be converted to Date objects.                                                              // 116
                                                                                                          // 117
            myData = JSON.parse(text, function (key, value) {                                             // 118
                var a;                                                                                    // 119
                if (typeof value === 'string') {                                                          // 120
                    a =                                                                                   // 121
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);                               // 122
                    if (a) {                                                                              // 123
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],                          // 124
                            +a[5], +a[6]));                                                               // 125
                    }                                                                                     // 126
                }                                                                                         // 127
                return value;                                                                             // 128
            });                                                                                           // 129
                                                                                                          // 130
            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {                           // 131
                var d;                                                                                    // 132
                if (typeof value === 'string' &&                                                          // 133
                        value.slice(0, 5) === 'Date(' &&                                                  // 134
                        value.slice(-1) === ')') {                                                        // 135
                    d = new Date(value.slice(5, -1));                                                     // 136
                    if (d) {                                                                              // 137
                        return d;                                                                         // 138
                    }                                                                                     // 139
                }                                                                                         // 140
                return value;                                                                             // 141
            });                                                                                           // 142
                                                                                                          // 143
                                                                                                          // 144
    This is a reference implementation. You are free to copy, modify, or                                  // 145
    redistribute.                                                                                         // 146
*/                                                                                                        // 147
                                                                                                          // 148
/*jslint evil: true, regexp: true */                                                                      // 149
                                                                                                          // 150
/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,                                      // 151
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,                                            // 152
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,                                      // 153
    lastIndex, length, parse, prototype, push, replace, slice, stringify,                                 // 154
    test, toJSON, toString, valueOf                                                                       // 155
*/                                                                                                        // 156
                                                                                                          // 157
                                                                                                          // 158
// Create a JSON object only if one does not already exist. We create the                                 // 159
// methods in a closure to avoid creating global variables.                                               // 160
                                                                                                          // 161
if (typeof JSON !== 'object') {                                                                           // 162
    JSON = {};                                                                                            // 163
}                                                                                                         // 164
                                                                                                          // 165
(function () {                                                                                            // 166
    'use strict';                                                                                         // 167
                                                                                                          // 168
    function f(n) {                                                                                       // 169
        // Format integers to have at least two digits.                                                   // 170
        return n < 10 ? '0' + n : n;                                                                      // 171
    }                                                                                                     // 172
                                                                                                          // 173
    if (typeof Date.prototype.toJSON !== 'function') {                                                    // 174
                                                                                                          // 175
        Date.prototype.toJSON = function (key) {                                                          // 176
                                                                                                          // 177
            return isFinite(this.valueOf())                                                               // 178
                ? this.getUTCFullYear()     + '-' +                                                       // 179
                    f(this.getUTCMonth() + 1) + '-' +                                                     // 180
                    f(this.getUTCDate())      + 'T' +                                                     // 181
                    f(this.getUTCHours())     + ':' +                                                     // 182
                    f(this.getUTCMinutes())   + ':' +                                                     // 183
                    f(this.getUTCSeconds())   + 'Z'                                                       // 184
                : null;                                                                                   // 185
        };                                                                                                // 186
                                                                                                          // 187
        String.prototype.toJSON      =                                                                    // 188
            Number.prototype.toJSON  =                                                                    // 189
            Boolean.prototype.toJSON = function (key) {                                                   // 190
                return this.valueOf();                                                                    // 191
            };                                                                                            // 192
    }                                                                                                     // 193
                                                                                                          // 194
    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,                                                                                              // 197
        indent,                                                                                           // 198
        meta = {    // table of character substitutions                                                   // 199
            '\b': '\\b',                                                                                  // 200
            '\t': '\\t',                                                                                  // 201
            '\n': '\\n',                                                                                  // 202
            '\f': '\\f',                                                                                  // 203
            '\r': '\\r',                                                                                  // 204
            '"' : '\\"',                                                                                  // 205
            '\\': '\\\\'                                                                                  // 206
        },                                                                                                // 207
        rep;                                                                                              // 208
                                                                                                          // 209
                                                                                                          // 210
    function quote(string) {                                                                              // 211
                                                                                                          // 212
// If the string contains no control characters, no quote characters, and no                              // 213
// backslash characters, then we can safely slap some quotes around it.                                   // 214
// Otherwise we must also replace the offending characters with safe escape                               // 215
// sequences.                                                                                             // 216
                                                                                                          // 217
        escapable.lastIndex = 0;                                                                          // 218
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {                    // 219
            var c = meta[a];                                                                              // 220
            return typeof c === 'string'                                                                  // 221
                ? c                                                                                       // 222
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                              // 223
        }) + '"' : '"' + string + '"';                                                                    // 224
    }                                                                                                     // 225
                                                                                                          // 226
                                                                                                          // 227
    function str(key, holder) {                                                                           // 228
                                                                                                          // 229
// Produce a string from holder[key].                                                                     // 230
                                                                                                          // 231
        var i,          // The loop counter.                                                              // 232
            k,          // The member key.                                                                // 233
            v,          // The member value.                                                              // 234
            length,                                                                                       // 235
            mind = gap,                                                                                   // 236
            partial,                                                                                      // 237
            value = holder[key];                                                                          // 238
                                                                                                          // 239
// If the value has a toJSON method, call it to obtain a replacement value.                               // 240
                                                                                                          // 241
        if (value && typeof value === 'object' &&                                                         // 242
                typeof value.toJSON === 'function') {                                                     // 243
            value = value.toJSON(key);                                                                    // 244
        }                                                                                                 // 245
                                                                                                          // 246
// If we were called with a replacer function, then call the replacer to                                  // 247
// obtain a replacement value.                                                                            // 248
                                                                                                          // 249
        if (typeof rep === 'function') {                                                                  // 250
            value = rep.call(holder, key, value);                                                         // 251
        }                                                                                                 // 252
                                                                                                          // 253
// What happens next depends on the value's type.                                                         // 254
                                                                                                          // 255
        switch (typeof value) {                                                                           // 256
        case 'string':                                                                                    // 257
            return quote(value);                                                                          // 258
                                                                                                          // 259
        case 'number':                                                                                    // 260
                                                                                                          // 261
// JSON numbers must be finite. Encode non-finite numbers as null.                                        // 262
                                                                                                          // 263
            return isFinite(value) ? String(value) : 'null';                                              // 264
                                                                                                          // 265
        case 'boolean':                                                                                   // 266
        case 'null':                                                                                      // 267
                                                                                                          // 268
// If the value is a boolean or null, convert it to a string. Note:                                       // 269
// typeof null does not produce 'null'. The case is included here in                                      // 270
// the remote chance that this gets fixed someday.                                                        // 271
                                                                                                          // 272
            return String(value);                                                                         // 273
                                                                                                          // 274
// If the type is 'object', we might be dealing with an object or an array or                             // 275
// null.                                                                                                  // 276
                                                                                                          // 277
        case 'object':                                                                                    // 278
                                                                                                          // 279
// Due to a specification blunder in ECMAScript, typeof null is 'object',                                 // 280
// so watch out for that case.                                                                            // 281
                                                                                                          // 282
            if (!value) {                                                                                 // 283
                return 'null';                                                                            // 284
            }                                                                                             // 285
                                                                                                          // 286
// Make an array to hold the partial results of stringifying this object value.                           // 287
                                                                                                          // 288
            gap += indent;                                                                                // 289
            partial = [];                                                                                 // 290
                                                                                                          // 291
// Is the value an array?                                                                                 // 292
                                                                                                          // 293
            if (Object.prototype.toString.apply(value) === '[object Array]') {                            // 294
                                                                                                          // 295
// The value is an array. Stringify every element. Use null as a placeholder                              // 296
// for non-JSON values.                                                                                   // 297
                                                                                                          // 298
                length = value.length;                                                                    // 299
                for (i = 0; i < length; i += 1) {                                                         // 300
                    partial[i] = str(i, value) || 'null';                                                 // 301
                }                                                                                         // 302
                                                                                                          // 303
// Join all of the elements together, separated with commas, and wrap them in                             // 304
// brackets.                                                                                              // 305
                                                                                                          // 306
                v = partial.length === 0                                                                  // 307
                    ? '[]'                                                                                // 308
                    : gap                                                                                 // 309
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'                         // 310
                    : '[' + partial.join(',') + ']';                                                      // 311
                gap = mind;                                                                               // 312
                return v;                                                                                 // 313
            }                                                                                             // 314
                                                                                                          // 315
// If the replacer is an array, use it to select the members to be stringified.                           // 316
                                                                                                          // 317
            if (rep && typeof rep === 'object') {                                                         // 318
                length = rep.length;                                                                      // 319
                for (i = 0; i < length; i += 1) {                                                         // 320
                    if (typeof rep[i] === 'string') {                                                     // 321
                        k = rep[i];                                                                       // 322
                        v = str(k, value);                                                                // 323
                        if (v) {                                                                          // 324
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                              // 325
                        }                                                                                 // 326
                    }                                                                                     // 327
                }                                                                                         // 328
            } else {                                                                                      // 329
                                                                                                          // 330
// Otherwise, iterate through all of the keys in the object.                                              // 331
                                                                                                          // 332
                for (k in value) {                                                                        // 333
                    if (Object.prototype.hasOwnProperty.call(value, k)) {                                 // 334
                        v = str(k, value);                                                                // 335
                        if (v) {                                                                          // 336
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);                              // 337
                        }                                                                                 // 338
                    }                                                                                     // 339
                }                                                                                         // 340
            }                                                                                             // 341
                                                                                                          // 342
// Join all of the member texts together, separated with commas,                                          // 343
// and wrap them in braces.                                                                               // 344
                                                                                                          // 345
            v = partial.length === 0                                                                      // 346
                ? '{}'                                                                                    // 347
                : gap                                                                                     // 348
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'                             // 349
                : '{' + partial.join(',') + '}';                                                          // 350
            gap = mind;                                                                                   // 351
            return v;                                                                                     // 352
        }                                                                                                 // 353
    }                                                                                                     // 354
                                                                                                          // 355
// If the JSON object does not yet have a stringify method, give it one.                                  // 356
                                                                                                          // 357
    if (typeof JSON.stringify !== 'function') {                                                           // 358
        JSON.stringify = function (value, replacer, space) {                                              // 359
                                                                                                          // 360
// The stringify method takes a value and an optional replacer, and an optional                           // 361
// space parameter, and returns a JSON text. The replacer can be a function                               // 362
// that can replace values, or an array of strings that will select the keys.                             // 363
// A default replacer method can be provided. Use of the space parameter can                              // 364
// produce text that is more easily readable.                                                             // 365
                                                                                                          // 366
            var i;                                                                                        // 367
            gap = '';                                                                                     // 368
            indent = '';                                                                                  // 369
                                                                                                          // 370
// If the space parameter is a number, make an indent string containing that                              // 371
// many spaces.                                                                                           // 372
                                                                                                          // 373
            if (typeof space === 'number') {                                                              // 374
                for (i = 0; i < space; i += 1) {                                                          // 375
                    indent += ' ';                                                                        // 376
                }                                                                                         // 377
                                                                                                          // 378
// If the space parameter is a string, it will be used as the indent string.                              // 379
                                                                                                          // 380
            } else if (typeof space === 'string') {                                                       // 381
                indent = space;                                                                           // 382
            }                                                                                             // 383
                                                                                                          // 384
// If there is a replacer, it must be a function or an array.                                             // 385
// Otherwise, throw an error.                                                                             // 386
                                                                                                          // 387
            rep = replacer;                                                                               // 388
            if (replacer && typeof replacer !== 'function' &&                                             // 389
                    (typeof replacer !== 'object' ||                                                      // 390
                    typeof replacer.length !== 'number')) {                                               // 391
                throw new Error('JSON.stringify');                                                        // 392
            }                                                                                             // 393
                                                                                                          // 394
// Make a fake root object containing our value under the key of ''.                                      // 395
// Return the result of stringifying the value.                                                           // 396
                                                                                                          // 397
            return str('', {'': value});                                                                  // 398
        };                                                                                                // 399
    }                                                                                                     // 400
                                                                                                          // 401
                                                                                                          // 402
// If the JSON object does not yet have a parse method, give it one.                                      // 403
                                                                                                          // 404
    if (typeof JSON.parse !== 'function') {                                                               // 405
        JSON.parse = function (text, reviver) {                                                           // 406
                                                                                                          // 407
// The parse method takes a text and an optional reviver function, and returns                            // 408
// a JavaScript value if the text is a valid JSON text.                                                   // 409
                                                                                                          // 410
            var j;                                                                                        // 411
                                                                                                          // 412
            function walk(holder, key) {                                                                  // 413
                                                                                                          // 414
// The walk method is used to recursively walk the resulting structure so                                 // 415
// that modifications can be made.                                                                        // 416
                                                                                                          // 417
                var k, v, value = holder[key];                                                            // 418
                if (value && typeof value === 'object') {                                                 // 419
                    for (k in value) {                                                                    // 420
                        if (Object.prototype.hasOwnProperty.call(value, k)) {                             // 421
                            v = walk(value, k);                                                           // 422
                            if (v !== undefined) {                                                        // 423
                                value[k] = v;                                                             // 424
                            } else {                                                                      // 425
                                delete value[k];                                                          // 426
                            }                                                                             // 427
                        }                                                                                 // 428
                    }                                                                                     // 429
                }                                                                                         // 430
                return reviver.call(holder, key, value);                                                  // 431
            }                                                                                             // 432
                                                                                                          // 433
                                                                                                          // 434
// Parsing happens in four stages. In the first stage, we replace certain                                 // 435
// Unicode characters with escape sequences. JavaScript handles many characters                           // 436
// incorrectly, either silently deleting them, or treating them as line endings.                          // 437
                                                                                                          // 438
            text = String(text);                                                                          // 439
            cx.lastIndex = 0;                                                                             // 440
            if (cx.test(text)) {                                                                          // 441
                text = text.replace(cx, function (a) {                                                    // 442
                    return '\\u' +                                                                        // 443
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                                // 444
                });                                                                                       // 445
            }                                                                                             // 446
                                                                                                          // 447
// In the second stage, we run the text against regular expressions that look                             // 448
// for non-JSON patterns. We are especially concerned with '()' and 'new'                                 // 449
// because they can cause invocation, and '=' because it can cause mutation.                              // 450
// But just to be safe, we want to reject all unexpected forms.                                           // 451
                                                                                                          // 452
// We split the second stage into 4 regexp operations in order to work around                             // 453
// crippling inefficiencies in IE's and Safari's regexp engines. First we                                 // 454
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we                           // 455
// replace all simple value tokens with ']' characters. Third, we delete all                              // 456
// open brackets that follow a colon or comma or that begin the text. Finally,                            // 457
// we look to see that the remaining characters are only whitespace or ']' or                             // 458
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.                               // 459
                                                                                                          // 460
            if (/^[\],:{}\s]*$/                                                                           // 461
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')                        // 462
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']') // 463
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {                                          // 464
                                                                                                          // 465
// In the third stage we use the eval function to compile the text into a                                 // 466
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity                             // 467
// in JavaScript: it can begin a block or an object literal. We wrap the text                             // 468
// in parens to eliminate the ambiguity.                                                                  // 469
                                                                                                          // 470
                j = eval('(' + text + ')');                                                               // 471
                                                                                                          // 472
// In the optional fourth stage, we recursively walk the new structure, passing                           // 473
// each name/value pair to a reviver function for possible transformation.                                // 474
                                                                                                          // 475
                return typeof reviver === 'function'                                                      // 476
                    ? walk({'': j}, '')                                                                   // 477
                    : j;                                                                                  // 478
            }                                                                                             // 479
                                                                                                          // 480
// If the text is not JSON parseable, then a SyntaxError is thrown.                                       // 481
                                                                                                          // 482
            throw new SyntaxError('JSON.parse');                                                          // 483
        };                                                                                                // 484
    }                                                                                                     // 485
}());                                                                                                     // 486
                                                                                                          // 487
////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.json = {
  JSON: JSON
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var JSON = Package.json.JSON;
var _ = Package.underscore._;
var Base64 = Package.base64.Base64;

/* Package-scope variables */
var EJSON, EJSONTest;

(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                   //
// packages/ejson/ejson.js                                                                                           //
//                                                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                     //
/**                                                                                                                  // 1
 * @namespace                                                                                                        // 2
 * @summary Namespace for EJSON functions                                                                            // 3
 */                                                                                                                  // 4
EJSON = {};                                                                                                          // 5
EJSONTest = {};                                                                                                      // 6
                                                                                                                     // 7
                                                                                                                     // 8
                                                                                                                     // 9
// Custom type interface definition                                                                                  // 10
/**                                                                                                                  // 11
 * @class CustomType                                                                                                 // 12
 * @instanceName customType                                                                                          // 13
 * @memberOf EJSON                                                                                                   // 14
 * @summary The interface that a class must satisfy to be able to become an                                          // 15
 * EJSON custom type via EJSON.addType.                                                                              // 16
 */                                                                                                                  // 17
                                                                                                                     // 18
/**                                                                                                                  // 19
 * @function typeName                                                                                                // 20
 * @memberOf EJSON.CustomType                                                                                        // 21
 * @summary Return the tag used to identify this type.  This must match the tag used to register this type with [`EJSON.addType`](#ejson_add_type).
 * @locus Anywhere                                                                                                   // 23
 * @instance                                                                                                         // 24
 */                                                                                                                  // 25
                                                                                                                     // 26
/**                                                                                                                  // 27
 * @function toJSONValue                                                                                             // 28
 * @memberOf EJSON.CustomType                                                                                        // 29
 * @summary Serialize this instance into a JSON-compatible value.                                                    // 30
 * @locus Anywhere                                                                                                   // 31
 * @instance                                                                                                         // 32
 */                                                                                                                  // 33
                                                                                                                     // 34
/**                                                                                                                  // 35
 * @function clone                                                                                                   // 36
 * @memberOf EJSON.CustomType                                                                                        // 37
 * @summary Return a value `r` such that `this.equals(r)` is true, and modifications to `r` do not affect `this` and vice versa.
 * @locus Anywhere                                                                                                   // 39
 * @instance                                                                                                         // 40
 */                                                                                                                  // 41
                                                                                                                     // 42
/**                                                                                                                  // 43
 * @function equals                                                                                                  // 44
 * @memberOf EJSON.CustomType                                                                                        // 45
 * @summary Return `true` if `other` has a value equal to `this`; `false` otherwise.                                 // 46
 * @locus Anywhere                                                                                                   // 47
 * @param {Object} other Another object to compare this to.                                                          // 48
 * @instance                                                                                                         // 49
 */                                                                                                                  // 50
                                                                                                                     // 51
                                                                                                                     // 52
var customTypes = {};                                                                                                // 53
// Add a custom type, using a method of your choice to get to and                                                    // 54
// from a basic JSON-able representation.  The factory argument                                                      // 55
// is a function of JSON-able --> your object                                                                        // 56
// The type you add must have:                                                                                       // 57
// - A toJSONValue() method, so that Meteor can serialize it                                                         // 58
// - a typeName() method, to show how to look it up in our type table.                                               // 59
// It is okay if these methods are monkey-patched on.                                                                // 60
// EJSON.clone will use toJSONValue and the given factory to produce                                                 // 61
// a clone, but you may specify a method clone() that will be                                                        // 62
// used instead.                                                                                                     // 63
// Similarly, EJSON.equals will use toJSONValue to make comparisons,                                                 // 64
// but you may provide a method equals() instead.                                                                    // 65
/**                                                                                                                  // 66
 * @summary Add a custom datatype to EJSON.                                                                          // 67
 * @locus Anywhere                                                                                                   // 68
 * @param {String} name A tag for your custom type; must be unique among custom data types defined in your project, and must match the result of your type's `typeName` method.
 * @param {Function} factory A function that deserializes a JSON-compatible value into an instance of your type.  This should match the serialization performed by your type's `toJSONValue` method.
 */                                                                                                                  // 71
EJSON.addType = function (name, factory) {                                                                           // 72
  if (_.has(customTypes, name))                                                                                      // 73
    throw new Error("Type " + name + " already present");                                                            // 74
  customTypes[name] = factory;                                                                                       // 75
};                                                                                                                   // 76
                                                                                                                     // 77
var isInfOrNan = function (obj) {                                                                                    // 78
  return _.isNaN(obj) || obj === Infinity || obj === -Infinity;                                                      // 79
};                                                                                                                   // 80
                                                                                                                     // 81
var builtinConverters = [                                                                                            // 82
  { // Date                                                                                                          // 83
    matchJSONValue: function (obj) {                                                                                 // 84
      return _.has(obj, '$date') && _.size(obj) === 1;                                                               // 85
    },                                                                                                               // 86
    matchObject: function (obj) {                                                                                    // 87
      return obj instanceof Date;                                                                                    // 88
    },                                                                                                               // 89
    toJSONValue: function (obj) {                                                                                    // 90
      return {$date: obj.getTime()};                                                                                 // 91
    },                                                                                                               // 92
    fromJSONValue: function (obj) {                                                                                  // 93
      return new Date(obj.$date);                                                                                    // 94
    }                                                                                                                // 95
  },                                                                                                                 // 96
  { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'                                          // 97
    // which we match.)                                                                                              // 98
    matchJSONValue: function (obj) {                                                                                 // 99
      return _.has(obj, '$InfNaN') && _.size(obj) === 1;                                                             // 100
    },                                                                                                               // 101
    matchObject: isInfOrNan,                                                                                         // 102
    toJSONValue: function (obj) {                                                                                    // 103
      var sign;                                                                                                      // 104
      if (_.isNaN(obj))                                                                                              // 105
        sign = 0;                                                                                                    // 106
      else if (obj === Infinity)                                                                                     // 107
        sign = 1;                                                                                                    // 108
      else                                                                                                           // 109
        sign = -1;                                                                                                   // 110
      return {$InfNaN: sign};                                                                                        // 111
    },                                                                                                               // 112
    fromJSONValue: function (obj) {                                                                                  // 113
      return obj.$InfNaN/0;                                                                                          // 114
    }                                                                                                                // 115
  },                                                                                                                 // 116
  { // Binary                                                                                                        // 117
    matchJSONValue: function (obj) {                                                                                 // 118
      return _.has(obj, '$binary') && _.size(obj) === 1;                                                             // 119
    },                                                                                                               // 120
    matchObject: function (obj) {                                                                                    // 121
      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array                                          // 122
        || (obj && _.has(obj, '$Uint8ArrayPolyfill'));                                                               // 123
    },                                                                                                               // 124
    toJSONValue: function (obj) {                                                                                    // 125
      return {$binary: Base64.encode(obj)};                                                                          // 126
    },                                                                                                               // 127
    fromJSONValue: function (obj) {                                                                                  // 128
      return Base64.decode(obj.$binary);                                                                             // 129
    }                                                                                                                // 130
  },                                                                                                                 // 131
  { // Escaping one level                                                                                            // 132
    matchJSONValue: function (obj) {                                                                                 // 133
      return _.has(obj, '$escape') && _.size(obj) === 1;                                                             // 134
    },                                                                                                               // 135
    matchObject: function (obj) {                                                                                    // 136
      if (_.isEmpty(obj) || _.size(obj) > 2) {                                                                       // 137
        return false;                                                                                                // 138
      }                                                                                                              // 139
      return _.any(builtinConverters, function (converter) {                                                         // 140
        return converter.matchJSONValue(obj);                                                                        // 141
      });                                                                                                            // 142
    },                                                                                                               // 143
    toJSONValue: function (obj) {                                                                                    // 144
      var newObj = {};                                                                                               // 145
      _.each(obj, function (value, key) {                                                                            // 146
        newObj[key] = EJSON.toJSONValue(value);                                                                      // 147
      });                                                                                                            // 148
      return {$escape: newObj};                                                                                      // 149
    },                                                                                                               // 150
    fromJSONValue: function (obj) {                                                                                  // 151
      var newObj = {};                                                                                               // 152
      _.each(obj.$escape, function (value, key) {                                                                    // 153
        newObj[key] = EJSON.fromJSONValue(value);                                                                    // 154
      });                                                                                                            // 155
      return newObj;                                                                                                 // 156
    }                                                                                                                // 157
  },                                                                                                                 // 158
  { // Custom                                                                                                        // 159
    matchJSONValue: function (obj) {                                                                                 // 160
      return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;                                       // 161
    },                                                                                                               // 162
    matchObject: function (obj) {                                                                                    // 163
      return EJSON._isCustomType(obj);                                                                               // 164
    },                                                                                                               // 165
    toJSONValue: function (obj) {                                                                                    // 166
      var jsonValue = Meteor._noYieldsAllowed(function () {                                                          // 167
        return obj.toJSONValue();                                                                                    // 168
      });                                                                                                            // 169
      return {$type: obj.typeName(), $value: jsonValue};                                                             // 170
    },                                                                                                               // 171
    fromJSONValue: function (obj) {                                                                                  // 172
      var typeName = obj.$type;                                                                                      // 173
      if (!_.has(customTypes, typeName))                                                                             // 174
        throw new Error("Custom EJSON type " + typeName + " is not defined");                                        // 175
      var converter = customTypes[typeName];                                                                         // 176
      return Meteor._noYieldsAllowed(function () {                                                                   // 177
        return converter(obj.$value);                                                                                // 178
      });                                                                                                            // 179
    }                                                                                                                // 180
  }                                                                                                                  // 181
];                                                                                                                   // 182
                                                                                                                     // 183
EJSON._isCustomType = function (obj) {                                                                               // 184
  return obj &&                                                                                                      // 185
    typeof obj.toJSONValue === 'function' &&                                                                         // 186
    typeof obj.typeName === 'function' &&                                                                            // 187
    _.has(customTypes, obj.typeName());                                                                              // 188
};                                                                                                                   // 189
                                                                                                                     // 190
                                                                                                                     // 191
// for both arrays and objects, in-place modification.                                                               // 192
var adjustTypesToJSONValue =                                                                                         // 193
EJSON._adjustTypesToJSONValue = function (obj) {                                                                     // 194
  // Is it an atom that we need to adjust?                                                                           // 195
  if (obj === null)                                                                                                  // 196
    return null;                                                                                                     // 197
  var maybeChanged = toJSONValueHelper(obj);                                                                         // 198
  if (maybeChanged !== undefined)                                                                                    // 199
    return maybeChanged;                                                                                             // 200
                                                                                                                     // 201
  // Other atoms are unchanged.                                                                                      // 202
  if (typeof obj !== 'object')                                                                                       // 203
    return obj;                                                                                                      // 204
                                                                                                                     // 205
  // Iterate over array or object structure.                                                                         // 206
  _.each(obj, function (value, key) {                                                                                // 207
    if (typeof value !== 'object' && value !== undefined &&                                                          // 208
        !isInfOrNan(value))                                                                                          // 209
      return; // continue                                                                                            // 210
                                                                                                                     // 211
    var changed = toJSONValueHelper(value);                                                                          // 212
    if (changed) {                                                                                                   // 213
      obj[key] = changed;                                                                                            // 214
      return; // on to the next key                                                                                  // 215
    }                                                                                                                // 216
    // if we get here, value is an object but not adjustable                                                         // 217
    // at this level.  recurse.                                                                                      // 218
    adjustTypesToJSONValue(value);                                                                                   // 219
  });                                                                                                                // 220
  return obj;                                                                                                        // 221
};                                                                                                                   // 222
                                                                                                                     // 223
// Either return the JSON-compatible version of the argument, or undefined (if                                       // 224
// the item isn't itself replaceable, but maybe some fields in it are)                                               // 225
var toJSONValueHelper = function (item) {                                                                            // 226
  for (var i = 0; i < builtinConverters.length; i++) {                                                               // 227
    var converter = builtinConverters[i];                                                                            // 228
    if (converter.matchObject(item)) {                                                                               // 229
      return converter.toJSONValue(item);                                                                            // 230
    }                                                                                                                // 231
  }                                                                                                                  // 232
  return undefined;                                                                                                  // 233
};                                                                                                                   // 234
                                                                                                                     // 235
/**                                                                                                                  // 236
 * @summary Serialize an EJSON-compatible value into its plain JSON representation.                                  // 237
 * @locus Anywhere                                                                                                   // 238
 * @param {EJSON} val A value to serialize to plain JSON.                                                            // 239
 */                                                                                                                  // 240
EJSON.toJSONValue = function (item) {                                                                                // 241
  var changed = toJSONValueHelper(item);                                                                             // 242
  if (changed !== undefined)                                                                                         // 243
    return changed;                                                                                                  // 244
  if (typeof item === 'object') {                                                                                    // 245
    item = EJSON.clone(item);                                                                                        // 246
    adjustTypesToJSONValue(item);                                                                                    // 247
  }                                                                                                                  // 248
  return item;                                                                                                       // 249
};                                                                                                                   // 250
                                                                                                                     // 251
// for both arrays and objects. Tries its best to just                                                               // 252
// use the object you hand it, but may return something                                                              // 253
// different if the object you hand it itself needs changing.                                                        // 254
//                                                                                                                   // 255
var adjustTypesFromJSONValue =                                                                                       // 256
EJSON._adjustTypesFromJSONValue = function (obj) {                                                                   // 257
  if (obj === null)                                                                                                  // 258
    return null;                                                                                                     // 259
  var maybeChanged = fromJSONValueHelper(obj);                                                                       // 260
  if (maybeChanged !== obj)                                                                                          // 261
    return maybeChanged;                                                                                             // 262
                                                                                                                     // 263
  // Other atoms are unchanged.                                                                                      // 264
  if (typeof obj !== 'object')                                                                                       // 265
    return obj;                                                                                                      // 266
                                                                                                                     // 267
  _.each(obj, function (value, key) {                                                                                // 268
    if (typeof value === 'object') {                                                                                 // 269
      var changed = fromJSONValueHelper(value);                                                                      // 270
      if (value !== changed) {                                                                                       // 271
        obj[key] = changed;                                                                                          // 272
        return;                                                                                                      // 273
      }                                                                                                              // 274
      // if we get here, value is an object but not adjustable                                                       // 275
      // at this level.  recurse.                                                                                    // 276
      adjustTypesFromJSONValue(value);                                                                               // 277
    }                                                                                                                // 278
  });                                                                                                                // 279
  return obj;                                                                                                        // 280
};                                                                                                                   // 281
                                                                                                                     // 282
// Either return the argument changed to have the non-json                                                           // 283
// rep of itself (the Object version) or the argument itself.                                                        // 284
                                                                                                                     // 285
// DOES NOT RECURSE.  For actually getting the fully-changed value, use                                              // 286
// EJSON.fromJSONValue                                                                                               // 287
var fromJSONValueHelper = function (value) {                                                                         // 288
  if (typeof value === 'object' && value !== null) {                                                                 // 289
    if (_.size(value) <= 2                                                                                           // 290
        && _.all(value, function (v, k) {                                                                            // 291
          return typeof k === 'string' && k.substr(0, 1) === '$';                                                    // 292
        })) {                                                                                                        // 293
      for (var i = 0; i < builtinConverters.length; i++) {                                                           // 294
        var converter = builtinConverters[i];                                                                        // 295
        if (converter.matchJSONValue(value)) {                                                                       // 296
          return converter.fromJSONValue(value);                                                                     // 297
        }                                                                                                            // 298
      }                                                                                                              // 299
    }                                                                                                                // 300
  }                                                                                                                  // 301
  return value;                                                                                                      // 302
};                                                                                                                   // 303
                                                                                                                     // 304
/**                                                                                                                  // 305
 * @summary Deserialize an EJSON value from its plain JSON representation.                                           // 306
 * @locus Anywhere                                                                                                   // 307
 * @param {JSONCompatible} val A value to deserialize into EJSON.                                                    // 308
 */                                                                                                                  // 309
EJSON.fromJSONValue = function (item) {                                                                              // 310
  var changed = fromJSONValueHelper(item);                                                                           // 311
  if (changed === item && typeof item === 'object') {                                                                // 312
    item = EJSON.clone(item);                                                                                        // 313
    adjustTypesFromJSONValue(item);                                                                                  // 314
    return item;                                                                                                     // 315
  } else {                                                                                                           // 316
    return changed;                                                                                                  // 317
  }                                                                                                                  // 318
};                                                                                                                   // 319
                                                                                                                     // 320
/**                                                                                                                  // 321
 * @summary Serialize a value to a string.                                                                           // 322
                                                                                                                     // 323
For EJSON values, the serialization fully represents the value. For non-EJSON values, serializes the same way as `JSON.stringify`.
 * @locus Anywhere                                                                                                   // 325
 * @param {EJSON} val A value to stringify.                                                                          // 326
 * @param {Object} [options]                                                                                         // 327
 * @param {Boolean | Integer | String} options.indent Indents objects and arrays for easy readability.  When `true`, indents by 2 spaces; when an integer, indents by that number of spaces; and when a string, uses the string as the indentation pattern.
 * @param {Boolean} options.canonical When `true`, stringifies keys in an object in sorted order.                    // 329
 */                                                                                                                  // 330
EJSON.stringify = function (item, options) {                                                                         // 331
  var json = EJSON.toJSONValue(item);                                                                                // 332
  if (options && (options.canonical || options.indent)) {                                                            // 333
    return EJSON._canonicalStringify(json, options);                                                                 // 334
  } else {                                                                                                           // 335
    return JSON.stringify(json);                                                                                     // 336
  }                                                                                                                  // 337
};                                                                                                                   // 338
                                                                                                                     // 339
/**                                                                                                                  // 340
 * @summary Parse a string into an EJSON value. Throws an error if the string is not valid EJSON.                    // 341
 * @locus Anywhere                                                                                                   // 342
 * @param {String} str A string to parse into an EJSON value.                                                        // 343
 */                                                                                                                  // 344
EJSON.parse = function (item) {                                                                                      // 345
  if (typeof item !== 'string')                                                                                      // 346
    throw new Error("EJSON.parse argument should be a string");                                                      // 347
  return EJSON.fromJSONValue(JSON.parse(item));                                                                      // 348
};                                                                                                                   // 349
                                                                                                                     // 350
/**                                                                                                                  // 351
 * @summary Returns true if `x` is a buffer of binary data, as returned from [`EJSON.newBinary`](#ejson_new_binary). // 352
 * @param {Object} x The variable to check.                                                                          // 353
 * @locus Anywhere                                                                                                   // 354
 */                                                                                                                  // 355
EJSON.isBinary = function (obj) {                                                                                    // 356
  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||                                      // 357
    (obj && obj.$Uint8ArrayPolyfill));                                                                               // 358
};                                                                                                                   // 359
                                                                                                                     // 360
/**                                                                                                                  // 361
 * @summary Return true if `a` and `b` are equal to each other.  Return false otherwise.  Uses the `equals` method on `a` if present, otherwise performs a deep comparison.
 * @locus Anywhere                                                                                                   // 363
 * @param {EJSON} a                                                                                                  // 364
 * @param {EJSON} b                                                                                                  // 365
 * @param {Object} [options]                                                                                         // 366
 * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order, if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}` is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The default is `false`.
 */                                                                                                                  // 368
EJSON.equals = function (a, b, options) {                                                                            // 369
  var i;                                                                                                             // 370
  var keyOrderSensitive = !!(options && options.keyOrderSensitive);                                                  // 371
  if (a === b)                                                                                                       // 372
    return true;                                                                                                     // 373
  if (_.isNaN(a) && _.isNaN(b))                                                                                      // 374
    return true; // This differs from the IEEE spec for NaN equality, b/c we don't want                              // 375
                 // anything ever with a NaN to be poisoned from becoming equal to anything.                         // 376
  if (!a || !b) // if either one is falsy, they'd have to be === to be equal                                         // 377
    return false;                                                                                                    // 378
  if (!(typeof a === 'object' && typeof b === 'object'))                                                             // 379
    return false;                                                                                                    // 380
  if (a instanceof Date && b instanceof Date)                                                                        // 381
    return a.valueOf() === b.valueOf();                                                                              // 382
  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {                                                                      // 383
    if (a.length !== b.length)                                                                                       // 384
      return false;                                                                                                  // 385
    for (i = 0; i < a.length; i++) {                                                                                 // 386
      if (a[i] !== b[i])                                                                                             // 387
        return false;                                                                                                // 388
    }                                                                                                                // 389
    return true;                                                                                                     // 390
  }                                                                                                                  // 391
  if (typeof (a.equals) === 'function')                                                                              // 392
    return a.equals(b, options);                                                                                     // 393
  if (typeof (b.equals) === 'function')                                                                              // 394
    return b.equals(a, options);                                                                                     // 395
  if (a instanceof Array) {                                                                                          // 396
    if (!(b instanceof Array))                                                                                       // 397
      return false;                                                                                                  // 398
    if (a.length !== b.length)                                                                                       // 399
      return false;                                                                                                  // 400
    for (i = 0; i < a.length; i++) {                                                                                 // 401
      if (!EJSON.equals(a[i], b[i], options))                                                                        // 402
        return false;                                                                                                // 403
    }                                                                                                                // 404
    return true;                                                                                                     // 405
  }                                                                                                                  // 406
  // fallback for custom types that don't implement their own equals                                                 // 407
  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {                                                         // 408
    case 1: return false;                                                                                            // 409
    case 2: return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));                                         // 410
  }                                                                                                                  // 411
  // fall back to structural equality of objects                                                                     // 412
  var ret;                                                                                                           // 413
  if (keyOrderSensitive) {                                                                                           // 414
    var bKeys = [];                                                                                                  // 415
    _.each(b, function (val, x) {                                                                                    // 416
        bKeys.push(x);                                                                                               // 417
    });                                                                                                              // 418
    i = 0;                                                                                                           // 419
    ret = _.all(a, function (val, x) {                                                                               // 420
      if (i >= bKeys.length) {                                                                                       // 421
        return false;                                                                                                // 422
      }                                                                                                              // 423
      if (x !== bKeys[i]) {                                                                                          // 424
        return false;                                                                                                // 425
      }                                                                                                              // 426
      if (!EJSON.equals(val, b[bKeys[i]], options)) {                                                                // 427
        return false;                                                                                                // 428
      }                                                                                                              // 429
      i++;                                                                                                           // 430
      return true;                                                                                                   // 431
    });                                                                                                              // 432
    return ret && i === bKeys.length;                                                                                // 433
  } else {                                                                                                           // 434
    i = 0;                                                                                                           // 435
    ret = _.all(a, function (val, key) {                                                                             // 436
      if (!_.has(b, key)) {                                                                                          // 437
        return false;                                                                                                // 438
      }                                                                                                              // 439
      if (!EJSON.equals(val, b[key], options)) {                                                                     // 440
        return false;                                                                                                // 441
      }                                                                                                              // 442
      i++;                                                                                                           // 443
      return true;                                                                                                   // 444
    });                                                                                                              // 445
    return ret && _.size(b) === i;                                                                                   // 446
  }                                                                                                                  // 447
};                                                                                                                   // 448
                                                                                                                     // 449
/**                                                                                                                  // 450
 * @summary Return a deep copy of `val`.                                                                             // 451
 * @locus Anywhere                                                                                                   // 452
 * @param {EJSON} val A value to copy.                                                                               // 453
 */                                                                                                                  // 454
EJSON.clone = function (v) {                                                                                         // 455
  var ret;                                                                                                           // 456
  if (typeof v !== "object")                                                                                         // 457
    return v;                                                                                                        // 458
  if (v === null)                                                                                                    // 459
    return null; // null has typeof "object"                                                                         // 460
  if (v instanceof Date)                                                                                             // 461
    return new Date(v.getTime());                                                                                    // 462
  // RegExps are not really EJSON elements (eg we don't define a serialization                                       // 463
  // for them), but they're immutable anyway, so we can support them in clone.                                       // 464
  if (v instanceof RegExp)                                                                                           // 465
    return v;                                                                                                        // 466
  if (EJSON.isBinary(v)) {                                                                                           // 467
    ret = EJSON.newBinary(v.length);                                                                                 // 468
    for (var i = 0; i < v.length; i++) {                                                                             // 469
      ret[i] = v[i];                                                                                                 // 470
    }                                                                                                                // 471
    return ret;                                                                                                      // 472
  }                                                                                                                  // 473
  // XXX: Use something better than underscore's isArray                                                             // 474
  if (_.isArray(v) || _.isArguments(v)) {                                                                            // 475
    // For some reason, _.map doesn't work in this context on Opera (weird test                                      // 476
    // failures).                                                                                                    // 477
    ret = [];                                                                                                        // 478
    for (i = 0; i < v.length; i++)                                                                                   // 479
      ret[i] = EJSON.clone(v[i]);                                                                                    // 480
    return ret;                                                                                                      // 481
  }                                                                                                                  // 482
  // handle general user-defined typed Objects if they have a clone method                                           // 483
  if (typeof v.clone === 'function') {                                                                               // 484
    return v.clone();                                                                                                // 485
  }                                                                                                                  // 486
  // handle other custom types                                                                                       // 487
  if (EJSON._isCustomType(v)) {                                                                                      // 488
    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);                                             // 489
  }                                                                                                                  // 490
  // handle other objects                                                                                            // 491
  ret = {};                                                                                                          // 492
  _.each(v, function (value, key) {                                                                                  // 493
    ret[key] = EJSON.clone(value);                                                                                   // 494
  });                                                                                                                // 495
  return ret;                                                                                                        // 496
};                                                                                                                   // 497
                                                                                                                     // 498
/**                                                                                                                  // 499
 * @summary Allocate a new buffer of binary data that EJSON can serialize.                                           // 500
 * @locus Anywhere                                                                                                   // 501
 * @param {Number} size The number of bytes of binary data to allocate.                                              // 502
 */                                                                                                                  // 503
// EJSON.newBinary is the public documented API for this functionality,                                              // 504
// but the implementation is in the 'base64' package to avoid                                                        // 505
// introducing a circular dependency. (If the implementation were here,                                              // 506
// then 'base64' would have to use EJSON.newBinary, and 'ejson' would                                                // 507
// also have to use 'base64'.)                                                                                       // 508
EJSON.newBinary = Base64.newBinary;                                                                                  // 509
                                                                                                                     // 510
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                   //
// packages/ejson/stringify.js                                                                                       //
//                                                                                                                   //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                     //
// Based on json2.js from https://github.com/douglascrockford/JSON-js                                                // 1
//                                                                                                                   // 2
//    json2.js                                                                                                       // 3
//    2012-10-08                                                                                                     // 4
//                                                                                                                   // 5
//    Public Domain.                                                                                                 // 6
//                                                                                                                   // 7
//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.                                                        // 8
                                                                                                                     // 9
function quote(string) {                                                                                             // 10
  return JSON.stringify(string);                                                                                     // 11
}                                                                                                                    // 12
                                                                                                                     // 13
var str = function (key, holder, singleIndent, outerIndent, canonical) {                                             // 14
                                                                                                                     // 15
  // Produce a string from holder[key].                                                                              // 16
                                                                                                                     // 17
  var i;          // The loop counter.                                                                               // 18
  var k;          // The member key.                                                                                 // 19
  var v;          // The member value.                                                                               // 20
  var length;                                                                                                        // 21
  var innerIndent = outerIndent;                                                                                     // 22
  var partial;                                                                                                       // 23
  var value = holder[key];                                                                                           // 24
                                                                                                                     // 25
  // What happens next depends on the value's type.                                                                  // 26
                                                                                                                     // 27
  switch (typeof value) {                                                                                            // 28
  case 'string':                                                                                                     // 29
    return quote(value);                                                                                             // 30
  case 'number':                                                                                                     // 31
    // JSON numbers must be finite. Encode non-finite numbers as null.                                               // 32
    return isFinite(value) ? String(value) : 'null';                                                                 // 33
  case 'boolean':                                                                                                    // 34
    return String(value);                                                                                            // 35
  // If the type is 'object', we might be dealing with an object or an array or                                      // 36
  // null.                                                                                                           // 37
  case 'object':                                                                                                     // 38
    // Due to a specification blunder in ECMAScript, typeof null is 'object',                                        // 39
    // so watch out for that case.                                                                                   // 40
    if (!value) {                                                                                                    // 41
      return 'null';                                                                                                 // 42
    }                                                                                                                // 43
    // Make an array to hold the partial results of stringifying this object value.                                  // 44
    innerIndent = outerIndent + singleIndent;                                                                        // 45
    partial = [];                                                                                                    // 46
                                                                                                                     // 47
    // Is the value an array?                                                                                        // 48
    if (_.isArray(value) || _.isArguments(value)) {                                                                  // 49
                                                                                                                     // 50
      // The value is an array. Stringify every element. Use null as a placeholder                                   // 51
      // for non-JSON values.                                                                                        // 52
                                                                                                                     // 53
      length = value.length;                                                                                         // 54
      for (i = 0; i < length; i += 1) {                                                                              // 55
        partial[i] = str(i, value, singleIndent, innerIndent, canonical) || 'null';                                  // 56
      }                                                                                                              // 57
                                                                                                                     // 58
      // Join all of the elements together, separated with commas, and wrap them in                                  // 59
      // brackets.                                                                                                   // 60
                                                                                                                     // 61
      if (partial.length === 0) {                                                                                    // 62
        v = '[]';                                                                                                    // 63
      } else if (innerIndent) {                                                                                      // 64
        v = '[\n' + innerIndent + partial.join(',\n' + innerIndent) + '\n' + outerIndent + ']';                      // 65
      } else {                                                                                                       // 66
        v = '[' + partial.join(',') + ']';                                                                           // 67
      }                                                                                                              // 68
      return v;                                                                                                      // 69
    }                                                                                                                // 70
                                                                                                                     // 71
                                                                                                                     // 72
    // Iterate through all of the keys in the object.                                                                // 73
    var keys = _.keys(value);                                                                                        // 74
    if (canonical)                                                                                                   // 75
      keys = keys.sort();                                                                                            // 76
    _.each(keys, function (k) {                                                                                      // 77
      v = str(k, value, singleIndent, innerIndent, canonical);                                                       // 78
      if (v) {                                                                                                       // 79
        partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);                                                     // 80
      }                                                                                                              // 81
    });                                                                                                              // 82
                                                                                                                     // 83
                                                                                                                     // 84
    // Join all of the member texts together, separated with commas,                                                 // 85
    // and wrap them in braces.                                                                                      // 86
                                                                                                                     // 87
    if (partial.length === 0) {                                                                                      // 88
      v = '{}';                                                                                                      // 89
    } else if (innerIndent) {                                                                                        // 90
      v = '{\n' + innerIndent + partial.join(',\n' + innerIndent) + '\n' + outerIndent + '}';                        // 91
    } else {                                                                                                         // 92
      v = '{' + partial.join(',') + '}';                                                                             // 93
    }                                                                                                                // 94
    return v;                                                                                                        // 95
  }                                                                                                                  // 96
}                                                                                                                    // 97
                                                                                                                     // 98
// If the JSON object does not yet have a stringify method, give it one.                                             // 99
                                                                                                                     // 100
EJSON._canonicalStringify = function (value, options) {                                                              // 101
  // Make a fake root object containing our value under the key of ''.                                               // 102
  // Return the result of stringifying the value.                                                                    // 103
  options = _.extend({                                                                                               // 104
    indent: "",                                                                                                      // 105
    canonical: false                                                                                                 // 106
  }, options);                                                                                                       // 107
  if (options.indent === true) {                                                                                     // 108
    options.indent = "  ";                                                                                           // 109
  } else if (typeof options.indent === 'number') {                                                                   // 110
    var newIndent = "";                                                                                              // 111
    for (var i = 0; i < options.indent; i++) {                                                                       // 112
      newIndent += ' ';                                                                                              // 113
    }                                                                                                                // 114
    options.indent = newIndent;                                                                                      // 115
  }                                                                                                                  // 116
  return str('', {'': value}, options.indent, "", options.canonical);                                                // 117
};                                                                                                                   // 118
                                                                                                                     // 119
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.ejson = {
  EJSON: EJSON,
  EJSONTest: EJSONTest
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var check, Match;

(function () {

///////////////////////////////////////////////////////////////////////////////////
//                                                                               //
// packages/check/match.js                                                       //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////
                                                                                 //
// XXX docs                                                                      // 1
                                                                                 // 2
// Things we explicitly do NOT support:                                          // 3
//    - heterogenous arrays                                                      // 4
                                                                                 // 5
var currentArgumentChecker = new Meteor.EnvironmentVariable;                     // 6
                                                                                 // 7
/**                                                                              // 8
 * @summary Check that a value matches a [pattern](#matchpatterns).              // 9
 * If the value does not match the pattern, throw a `Match.Error`.               // 10
 *                                                                               // 11
 * Particularly useful to assert that arguments to a function have the right     // 12
 * types and structure.                                                          // 13
 * @locus Anywhere                                                               // 14
 * @param {Any} value The value to check                                         // 15
 * @param {MatchPattern} pattern The pattern to match                            // 16
 * `value` against                                                               // 17
 */                                                                              // 18
check = function (value, pattern) {                                              // 19
  // Record that check got called, if somebody cared.                            // 20
  //                                                                             // 21
  // We use getOrNullIfOutsideFiber so that it's OK to call check()              // 22
  // from non-Fiber server contexts; the downside is that if you forget to       // 23
  // bindEnvironment on some random callback in your method/publisher,           // 24
  // it might not find the argumentChecker and you'll get an error about         // 25
  // not checking an argument that it looks like you're checking (instead        // 26
  // of just getting a "Node code must run in a Fiber" error).                   // 27
  var argChecker = currentArgumentChecker.getOrNullIfOutsideFiber();             // 28
  if (argChecker)                                                                // 29
    argChecker.checking(value);                                                  // 30
  try {                                                                          // 31
    checkSubtree(value, pattern);                                                // 32
  } catch (err) {                                                                // 33
    if ((err instanceof Match.Error) && err.path)                                // 34
      err.message += " in field " + err.path;                                    // 35
    throw err;                                                                   // 36
  }                                                                              // 37
};                                                                               // 38
                                                                                 // 39
/**                                                                              // 40
 * @namespace Match                                                              // 41
 * @summary The namespace for all Match types and methods.                       // 42
 */                                                                              // 43
Match = {                                                                        // 44
  Optional: function (pattern) {                                                 // 45
    return new Optional(pattern);                                                // 46
  },                                                                             // 47
  OneOf: function (/*arguments*/) {                                              // 48
    return new OneOf(_.toArray(arguments));                                      // 49
  },                                                                             // 50
  Any: ['__any__'],                                                              // 51
  Where: function (condition) {                                                  // 52
    return new Where(condition);                                                 // 53
  },                                                                             // 54
  ObjectIncluding: function (pattern) {                                          // 55
    return new ObjectIncluding(pattern);                                         // 56
  },                                                                             // 57
  ObjectWithValues: function (pattern) {                                         // 58
    return new ObjectWithValues(pattern);                                        // 59
  },                                                                             // 60
  // Matches only signed 32-bit integers                                         // 61
  Integer: ['__integer__'],                                                      // 62
                                                                                 // 63
  // XXX matchers should know how to describe themselves for errors              // 64
  Error: Meteor.makeErrorType("Match.Error", function (msg) {                    // 65
    this.message = "Match error: " + msg;                                        // 66
    // The path of the value that failed to match. Initially empty, this gets    // 67
    // populated by catching and rethrowing the exception as it goes back up the // 68
    // stack.                                                                    // 69
    // E.g.: "vals[3].entity.created"                                            // 70
    this.path = "";                                                              // 71
    // If this gets sent over DDP, don't give full internal details but at least // 72
    // provide something better than 500 Internal server error.                  // 73
    this.sanitizedError = new Meteor.Error(400, "Match failed");                 // 74
  }),                                                                            // 75
                                                                                 // 76
  // Tests to see if value matches pattern. Unlike check, it merely returns true // 77
  // or false (unless an error other than Match.Error was thrown). It does not   // 78
  // interact with _failIfArgumentsAreNotAllChecked.                             // 79
  // XXX maybe also implement a Match.match which returns more information about // 80
  //     failures but without using exception handling or doing what check()     // 81
  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion  // 82
                                                                                 // 83
  /**                                                                            // 84
   * @summary Returns true if the value matches the pattern.                     // 85
   * @locus Anywhere                                                             // 86
   * @param {Any} value The value to check                                       // 87
   * @param {MatchPattern} pattern The pattern to match `value` against          // 88
   */                                                                            // 89
  test: function (value, pattern) {                                              // 90
    try {                                                                        // 91
      checkSubtree(value, pattern);                                              // 92
      return true;                                                               // 93
    } catch (e) {                                                                // 94
      if (e instanceof Match.Error)                                              // 95
        return false;                                                            // 96
      // Rethrow other errors.                                                   // 97
      throw e;                                                                   // 98
    }                                                                            // 99
  },                                                                             // 100
                                                                                 // 101
  // Runs `f.apply(context, args)`. If check() is not called on every element of // 102
  // `args` (either directly or in the first level of an array), throws an error // 103
  // (using `description` in the message).                                       // 104
  //                                                                             // 105
  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {   // 106
    var argChecker = new ArgumentChecker(args, description);                     // 107
    var result = currentArgumentChecker.withValue(argChecker, function () {      // 108
      return f.apply(context, args);                                             // 109
    });                                                                          // 110
    // If f didn't itself throw, make sure it checked all of its arguments.      // 111
    argChecker.throwUnlessAllArgumentsHaveBeenChecked();                         // 112
    return result;                                                               // 113
  }                                                                              // 114
};                                                                               // 115
                                                                                 // 116
var Optional = function (pattern) {                                              // 117
  this.pattern = pattern;                                                        // 118
};                                                                               // 119
                                                                                 // 120
var OneOf = function (choices) {                                                 // 121
  if (_.isEmpty(choices))                                                        // 122
    throw new Error("Must provide at least one choice to Match.OneOf");          // 123
  this.choices = choices;                                                        // 124
};                                                                               // 125
                                                                                 // 126
var Where = function (condition) {                                               // 127
  this.condition = condition;                                                    // 128
};                                                                               // 129
                                                                                 // 130
var ObjectIncluding = function (pattern) {                                       // 131
  this.pattern = pattern;                                                        // 132
};                                                                               // 133
                                                                                 // 134
var ObjectWithValues = function (pattern) {                                      // 135
  this.pattern = pattern;                                                        // 136
};                                                                               // 137
                                                                                 // 138
var typeofChecks = [                                                             // 139
  [String, "string"],                                                            // 140
  [Number, "number"],                                                            // 141
  [Boolean, "boolean"],                                                          // 142
  // While we don't allow undefined in EJSON, this is good for optional          // 143
  // arguments with OneOf.                                                       // 144
  [undefined, "undefined"]                                                       // 145
];                                                                               // 146
                                                                                 // 147
var checkSubtree = function (value, pattern) {                                   // 148
  // Match anything!                                                             // 149
  if (pattern === Match.Any)                                                     // 150
    return;                                                                      // 151
                                                                                 // 152
  // Basic atomic types.                                                         // 153
  // Do not match boxed objects (e.g. String, Boolean)                           // 154
  for (var i = 0; i < typeofChecks.length; ++i) {                                // 155
    if (pattern === typeofChecks[i][0]) {                                        // 156
      if (typeof value === typeofChecks[i][1])                                   // 157
        return;                                                                  // 158
      throw new Match.Error("Expected " + typeofChecks[i][1] + ", got " +        // 159
                            typeof value);                                       // 160
    }                                                                            // 161
  }                                                                              // 162
  if (pattern === null) {                                                        // 163
    if (value === null)                                                          // 164
      return;                                                                    // 165
    throw new Match.Error("Expected null, got " + EJSON.stringify(value));       // 166
  }                                                                              // 167
                                                                                 // 168
  // Strings and numbers match literally.  Goes well with Match.OneOf.           // 169
  if (typeof pattern === "string" || typeof pattern === "number") {              // 170
    if (value === pattern)                                                       // 171
      return;                                                                    // 172
    throw new Match.Error("Expected " + pattern + ", got " +                     // 173
                          EJSON.stringify(value));                               // 174
  }                                                                              // 175
                                                                                 // 176
  // Match.Integer is special type encoded with array                            // 177
  if (pattern === Match.Integer) {                                               // 178
    // There is no consistent and reliable way to check if variable is a 64-bit  // 179
    // integer. One of the popular solutions is to get reminder of division by 1 // 180
    // but this method fails on really large floats with big precision.          // 181
    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8                               // 182
    // Bitwise operators work consistantly but always cast variable to 32-bit    // 183
    // signed integer according to JavaScript specs.                             // 184
    if (typeof value === "number" && (value | 0) === value)                      // 185
      return                                                                     // 186
    throw new Match.Error("Expected Integer, got "                               // 187
                + (value instanceof Object ? EJSON.stringify(value) : value));   // 188
  }                                                                              // 189
                                                                                 // 190
  // "Object" is shorthand for Match.ObjectIncluding({});                        // 191
  if (pattern === Object)                                                        // 192
    pattern = Match.ObjectIncluding({});                                         // 193
                                                                                 // 194
  // Array (checked AFTER Any, which is implemented as an Array).                // 195
  if (pattern instanceof Array) {                                                // 196
    if (pattern.length !== 1)                                                    // 197
      throw Error("Bad pattern: arrays must have one type element" +             // 198
                  EJSON.stringify(pattern));                                     // 199
    if (!_.isArray(value) && !_.isArguments(value)) {                            // 200
      throw new Match.Error("Expected array, got " + EJSON.stringify(value));    // 201
    }                                                                            // 202
                                                                                 // 203
    _.each(value, function (valueElement, index) {                               // 204
      try {                                                                      // 205
        checkSubtree(valueElement, pattern[0]);                                  // 206
      } catch (err) {                                                            // 207
        if (err instanceof Match.Error) {                                        // 208
          err.path = _prependPath(index, err.path);                              // 209
        }                                                                        // 210
        throw err;                                                               // 211
      }                                                                          // 212
    });                                                                          // 213
    return;                                                                      // 214
  }                                                                              // 215
                                                                                 // 216
  // Arbitrary validation checks. The condition can return false or throw a      // 217
  // Match.Error (ie, it can internally use check()) to fail.                    // 218
  if (pattern instanceof Where) {                                                // 219
    if (pattern.condition(value))                                                // 220
      return;                                                                    // 221
    // XXX this error is terrible                                                // 222
    throw new Match.Error("Failed Match.Where validation");                      // 223
  }                                                                              // 224
                                                                                 // 225
                                                                                 // 226
  if (pattern instanceof Optional)                                               // 227
    pattern = Match.OneOf(undefined, pattern.pattern);                           // 228
                                                                                 // 229
  if (pattern instanceof OneOf) {                                                // 230
    for (var i = 0; i < pattern.choices.length; ++i) {                           // 231
      try {                                                                      // 232
        checkSubtree(value, pattern.choices[i]);                                 // 233
        // No error? Yay, return.                                                // 234
        return;                                                                  // 235
      } catch (err) {                                                            // 236
        // Other errors should be thrown. Match errors just mean try another     // 237
        // choice.                                                               // 238
        if (!(err instanceof Match.Error))                                       // 239
          throw err;                                                             // 240
      }                                                                          // 241
    }                                                                            // 242
    // XXX this error is terrible                                                // 243
    throw new Match.Error("Failed Match.OneOf or Match.Optional validation");    // 244
  }                                                                              // 245
                                                                                 // 246
  // A function that isn't something we special-case is assumed to be a          // 247
  // constructor.                                                                // 248
  if (pattern instanceof Function) {                                             // 249
    if (value instanceof pattern)                                                // 250
      return;                                                                    // 251
    throw new Match.Error("Expected " + (pattern.name ||                         // 252
                                         "particular constructor"));             // 253
  }                                                                              // 254
                                                                                 // 255
  var unknownKeysAllowed = false;                                                // 256
  var unknownKeyPattern;                                                         // 257
  if (pattern instanceof ObjectIncluding) {                                      // 258
    unknownKeysAllowed = true;                                                   // 259
    pattern = pattern.pattern;                                                   // 260
  }                                                                              // 261
  if (pattern instanceof ObjectWithValues) {                                     // 262
    unknownKeysAllowed = true;                                                   // 263
    unknownKeyPattern = [pattern.pattern];                                       // 264
    pattern = {};  // no required keys                                           // 265
  }                                                                              // 266
                                                                                 // 267
  if (typeof pattern !== "object")                                               // 268
    throw Error("Bad pattern: unknown pattern type");                            // 269
                                                                                 // 270
  // An object, with required and optional keys. Note that this does NOT do      // 271
  // structural matches against objects of special types that happen to match    // 272
  // the pattern: this really needs to be a plain old {Object}!                  // 273
  if (typeof value !== 'object')                                                 // 274
    throw new Match.Error("Expected object, got " + typeof value);               // 275
  if (value === null)                                                            // 276
    throw new Match.Error("Expected object, got null");                          // 277
  if (value.constructor !== Object)                                              // 278
    throw new Match.Error("Expected plain object");                              // 279
                                                                                 // 280
  var requiredPatterns = {};                                                     // 281
  var optionalPatterns = {};                                                     // 282
  _.each(pattern, function (subPattern, key) {                                   // 283
    if (subPattern instanceof Optional)                                          // 284
      optionalPatterns[key] = subPattern.pattern;                                // 285
    else                                                                         // 286
      requiredPatterns[key] = subPattern;                                        // 287
  });                                                                            // 288
                                                                                 // 289
  _.each(value, function (subValue, key) {                                       // 290
    try {                                                                        // 291
      if (_.has(requiredPatterns, key)) {                                        // 292
        checkSubtree(subValue, requiredPatterns[key]);                           // 293
        delete requiredPatterns[key];                                            // 294
      } else if (_.has(optionalPatterns, key)) {                                 // 295
        checkSubtree(subValue, optionalPatterns[key]);                           // 296
      } else {                                                                   // 297
        if (!unknownKeysAllowed)                                                 // 298
          throw new Match.Error("Unknown key");                                  // 299
        if (unknownKeyPattern) {                                                 // 300
          checkSubtree(subValue, unknownKeyPattern[0]);                          // 301
        }                                                                        // 302
      }                                                                          // 303
    } catch (err) {                                                              // 304
      if (err instanceof Match.Error)                                            // 305
        err.path = _prependPath(key, err.path);                                  // 306
      throw err;                                                                 // 307
    }                                                                            // 308
  });                                                                            // 309
                                                                                 // 310
  _.each(requiredPatterns, function (subPattern, key) {                          // 311
    throw new Match.Error("Missing key '" + key + "'");                          // 312
  });                                                                            // 313
};                                                                               // 314
                                                                                 // 315
var ArgumentChecker = function (args, description) {                             // 316
  var self = this;                                                               // 317
  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks       // 318
  // against its contents.)                                                      // 319
  self.args = _.clone(args);                                                     // 320
  // Since the common case will be to check arguments in order, and we splice    // 321
  // out arguments when we check them, make it so we splice out from the end     // 322
  // rather than the beginning.                                                  // 323
  self.args.reverse();                                                           // 324
  self.description = description;                                                // 325
};                                                                               // 326
                                                                                 // 327
_.extend(ArgumentChecker.prototype, {                                            // 328
  checking: function (value) {                                                   // 329
    var self = this;                                                             // 330
    if (self._checkingOneValue(value))                                           // 331
      return;                                                                    // 332
    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])   // 333
    // or check([foo, bar], [String]) to count... but only if value wasn't       // 334
    // itself an argument.                                                       // 335
    if (_.isArray(value) || _.isArguments(value)) {                              // 336
      _.each(value, _.bind(self._checkingOneValue, self));                       // 337
    }                                                                            // 338
  },                                                                             // 339
  _checkingOneValue: function (value) {                                          // 340
    var self = this;                                                             // 341
    for (var i = 0; i < self.args.length; ++i) {                                 // 342
      // Is this value one of the arguments? (This can have a false positive if  // 343
      // the argument is an interned primitive, but it's still a good enough     // 344
      // check.)                                                                 // 345
      // (NaN is not === to itself, so we have to check specially.)              // 346
      if (value === self.args[i] || (_.isNaN(value) && _.isNaN(self.args[i]))) { // 347
        self.args.splice(i, 1);                                                  // 348
        return true;                                                             // 349
      }                                                                          // 350
    }                                                                            // 351
    return false;                                                                // 352
  },                                                                             // 353
  throwUnlessAllArgumentsHaveBeenChecked: function () {                          // 354
    var self = this;                                                             // 355
    if (!_.isEmpty(self.args))                                                   // 356
      throw new Error("Did not check() all arguments during " +                  // 357
                      self.description);                                         // 358
  }                                                                              // 359
});                                                                              // 360
                                                                                 // 361
var _jsKeywords = ["do", "if", "in", "for", "let", "new", "try", "var", "case",  // 362
  "else", "enum", "eval", "false", "null", "this", "true", "void", "with",       // 363
  "break", "catch", "class", "const", "super", "throw", "while", "yield",        // 364
  "delete", "export", "import", "public", "return", "static", "switch",          // 365
  "typeof", "default", "extends", "finally", "package", "private", "continue",   // 366
  "debugger", "function", "arguments", "interface", "protected", "implements",   // 367
  "instanceof"];                                                                 // 368
                                                                                 // 369
// Assumes the base of path is already escaped properly                          // 370
// returns key + base                                                            // 371
var _prependPath = function (key, base) {                                        // 372
  if ((typeof key) === "number" || key.match(/^[0-9]+$/))                        // 373
    key = "[" + key + "]";                                                       // 374
  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))  // 375
    key = JSON.stringify([key]);                                                 // 376
                                                                                 // 377
  if (base && base[0] !== "[")                                                   // 378
    return key + '.' + base;                                                     // 379
  return key + base;                                                             // 380
};                                                                               // 381
                                                                                 // 382
                                                                                 // 383
///////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.check = {
  check: check,
  Match: Match
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var Random;

(function () {

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
// packages/random/random.js                                                        //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////
                                                                                    //
// We use cryptographically strong PRNGs (crypto.getRandomBytes() on the server,    // 1
// window.crypto.getRandomValues() in the browser) when available. If these         // 2
// PRNGs fail, we fall back to the Alea PRNG, which is not cryptographically        // 3
// strong, and we seed it with various sources such as the date, Math.random,       // 4
// and window size on the client.  When using crypto.getRandomValues(), our         // 5
// primitive is hexString(), from which we construct fraction(). When using         // 6
// window.crypto.getRandomValues() or alea, the primitive is fraction and we use    // 7
// that to construct hex string.                                                    // 8
                                                                                    // 9
if (Meteor.isServer)                                                                // 10
  var nodeCrypto = Npm.require('crypto');                                           // 11
                                                                                    // 12
// see http://baagoe.org/en/wiki/Better_random_numbers_for_javascript               // 13
// for a full discussion and Alea implementation.                                   // 14
var Alea = function () {                                                            // 15
  function Mash() {                                                                 // 16
    var n = 0xefc8249d;                                                             // 17
                                                                                    // 18
    var mash = function(data) {                                                     // 19
      data = data.toString();                                                       // 20
      for (var i = 0; i < data.length; i++) {                                       // 21
        n += data.charCodeAt(i);                                                    // 22
        var h = 0.02519603282416938 * n;                                            // 23
        n = h >>> 0;                                                                // 24
        h -= n;                                                                     // 25
        h *= n;                                                                     // 26
        n = h >>> 0;                                                                // 27
        h -= n;                                                                     // 28
        n += h * 0x100000000; // 2^32                                               // 29
      }                                                                             // 30
      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32                           // 31
    };                                                                              // 32
                                                                                    // 33
    mash.version = 'Mash 0.9';                                                      // 34
    return mash;                                                                    // 35
  }                                                                                 // 36
                                                                                    // 37
  return (function (args) {                                                         // 38
    var s0 = 0;                                                                     // 39
    var s1 = 0;                                                                     // 40
    var s2 = 0;                                                                     // 41
    var c = 1;                                                                      // 42
                                                                                    // 43
    if (args.length == 0) {                                                         // 44
      args = [+new Date];                                                           // 45
    }                                                                               // 46
    var mash = Mash();                                                              // 47
    s0 = mash(' ');                                                                 // 48
    s1 = mash(' ');                                                                 // 49
    s2 = mash(' ');                                                                 // 50
                                                                                    // 51
    for (var i = 0; i < args.length; i++) {                                         // 52
      s0 -= mash(args[i]);                                                          // 53
      if (s0 < 0) {                                                                 // 54
        s0 += 1;                                                                    // 55
      }                                                                             // 56
      s1 -= mash(args[i]);                                                          // 57
      if (s1 < 0) {                                                                 // 58
        s1 += 1;                                                                    // 59
      }                                                                             // 60
      s2 -= mash(args[i]);                                                          // 61
      if (s2 < 0) {                                                                 // 62
        s2 += 1;                                                                    // 63
      }                                                                             // 64
    }                                                                               // 65
    mash = null;                                                                    // 66
                                                                                    // 67
    var random = function() {                                                       // 68
      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32                   // 69
      s0 = s1;                                                                      // 70
      s1 = s2;                                                                      // 71
      return s2 = t - (c = t | 0);                                                  // 72
    };                                                                              // 73
    random.uint32 = function() {                                                    // 74
      return random() * 0x100000000; // 2^32                                        // 75
    };                                                                              // 76
    random.fract53 = function() {                                                   // 77
      return random() +                                                             // 78
        (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53                // 79
    };                                                                              // 80
    random.version = 'Alea 0.9';                                                    // 81
    random.args = args;                                                             // 82
    return random;                                                                  // 83
                                                                                    // 84
  } (Array.prototype.slice.call(arguments)));                                       // 85
};                                                                                  // 86
                                                                                    // 87
var UNMISTAKABLE_CHARS = "23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz"; // 88
var BASE64_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" +         // 89
  "0123456789-_";                                                                   // 90
                                                                                    // 91
// If seeds are provided, then the alea PRNG will be used, since cryptographic      // 92
// PRNGs (Node crypto and window.crypto.getRandomValues) don't allow us to          // 93
// specify seeds. The caller is responsible for making sure to provide a seed       // 94
// for alea if a csprng is not available.                                           // 95
var RandomGenerator = function (seedArray) {                                        // 96
  var self = this;                                                                  // 97
  if (seedArray !== undefined)                                                      // 98
    self.alea = Alea.apply(null, seedArray);                                        // 99
};                                                                                  // 100
                                                                                    // 101
RandomGenerator.prototype.fraction = function () {                                  // 102
  var self = this;                                                                  // 103
  if (self.alea) {                                                                  // 104
    return self.alea();                                                             // 105
  } else if (nodeCrypto) {                                                          // 106
    var numerator = parseInt(self.hexString(8), 16);                                // 107
    return numerator * 2.3283064365386963e-10; // 2^-32                             // 108
  } else if (typeof window !== "undefined" && window.crypto &&                      // 109
             window.crypto.getRandomValues) {                                       // 110
    var array = new Uint32Array(1);                                                 // 111
    window.crypto.getRandomValues(array);                                           // 112
    return array[0] * 2.3283064365386963e-10; // 2^-32                              // 113
  } else {                                                                          // 114
    throw new Error('No random generator available');                               // 115
  }                                                                                 // 116
};                                                                                  // 117
                                                                                    // 118
RandomGenerator.prototype.hexString = function (digits) {                           // 119
  var self = this;                                                                  // 120
  if (nodeCrypto && ! self.alea) {                                                  // 121
    var numBytes = Math.ceil(digits / 2);                                           // 122
    var bytes;                                                                      // 123
    // Try to get cryptographically strong randomness. Fall back to                 // 124
    // non-cryptographically strong if not available.                               // 125
    try {                                                                           // 126
      bytes = nodeCrypto.randomBytes(numBytes);                                     // 127
    } catch (e) {                                                                   // 128
      // XXX should re-throw any error except insufficient entropy                  // 129
      bytes = nodeCrypto.pseudoRandomBytes(numBytes);                               // 130
    }                                                                               // 131
    var result = bytes.toString("hex");                                             // 132
    // If the number of digits is odd, we'll have generated an extra 4 bits         // 133
    // of randomness, so we need to trim the last digit.                            // 134
    return result.substring(0, digits);                                             // 135
  } else {                                                                          // 136
    var hexDigits = [];                                                             // 137
    for (var i = 0; i < digits; ++i) {                                              // 138
      hexDigits.push(self.choice("0123456789abcdef"));                              // 139
    }                                                                               // 140
    return hexDigits.join('');                                                      // 141
  }                                                                                 // 142
};                                                                                  // 143
                                                                                    // 144
RandomGenerator.prototype._randomString = function (charsCount,                     // 145
                                                    alphabet) {                     // 146
  var self = this;                                                                  // 147
  var digits = [];                                                                  // 148
  for (var i = 0; i < charsCount; i++) {                                            // 149
    digits[i] = self.choice(alphabet);                                              // 150
  }                                                                                 // 151
  return digits.join("");                                                           // 152
};                                                                                  // 153
                                                                                    // 154
RandomGenerator.prototype.id = function (charsCount) {                              // 155
  var self = this;                                                                  // 156
  // 17 characters is around 96 bits of entropy, which is the amount of             // 157
  // state in the Alea PRNG.                                                        // 158
  if (charsCount === undefined)                                                     // 159
    charsCount = 17;                                                                // 160
                                                                                    // 161
  return self._randomString(charsCount, UNMISTAKABLE_CHARS);                        // 162
};                                                                                  // 163
                                                                                    // 164
RandomGenerator.prototype.secret = function (charsCount) {                          // 165
  var self = this;                                                                  // 166
  // Default to 256 bits of entropy, or 43 characters at 6 bits per                 // 167
  // character.                                                                     // 168
  if (charsCount === undefined)                                                     // 169
    charsCount = 43;                                                                // 170
  return self._randomString(charsCount, BASE64_CHARS);                              // 171
};                                                                                  // 172
                                                                                    // 173
RandomGenerator.prototype.choice = function (arrayOrString) {                       // 174
  var index = Math.floor(this.fraction() * arrayOrString.length);                   // 175
  if (typeof arrayOrString === "string")                                            // 176
    return arrayOrString.substr(index, 1);                                          // 177
  else                                                                              // 178
    return arrayOrString[index];                                                    // 179
};                                                                                  // 180
                                                                                    // 181
// instantiate RNG.  Heuristically collect entropy from various sources when a      // 182
// cryptographic PRNG isn't available.                                              // 183
                                                                                    // 184
// client sources                                                                   // 185
var height = (typeof window !== 'undefined' && window.innerHeight) ||               // 186
      (typeof document !== 'undefined'                                              // 187
       && document.documentElement                                                  // 188
       && document.documentElement.clientHeight) ||                                 // 189
      (typeof document !== 'undefined'                                              // 190
       && document.body                                                             // 191
       && document.body.clientHeight) ||                                            // 192
      1;                                                                            // 193
                                                                                    // 194
var width = (typeof window !== 'undefined' && window.innerWidth) ||                 // 195
      (typeof document !== 'undefined'                                              // 196
       && document.documentElement                                                  // 197
       && document.documentElement.clientWidth) ||                                  // 198
      (typeof document !== 'undefined'                                              // 199
       && document.body                                                             // 200
       && document.body.clientWidth) ||                                             // 201
      1;                                                                            // 202
                                                                                    // 203
var agent = (typeof navigator !== 'undefined' && navigator.userAgent) || "";        // 204
                                                                                    // 205
if (nodeCrypto ||                                                                   // 206
    (typeof window !== "undefined" &&                                               // 207
     window.crypto && window.crypto.getRandomValues))                               // 208
  Random = new RandomGenerator();                                                   // 209
else                                                                                // 210
  Random = new RandomGenerator([new Date(), height, width, agent, Math.random()]);  // 211
                                                                                    // 212
Random.createWithSeeds = function () {                                              // 213
  if (arguments.length === 0) {                                                     // 214
    throw new Error('No seeds were provided');                                      // 215
  }                                                                                 // 216
  return new RandomGenerator(arguments);                                            // 217
};                                                                                  // 218
                                                                                    // 219
//////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
// packages/random/deprecated.js                                                    //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////
                                                                                    //
// Before this package existed, we used to use this Meteor.uuid()                   // 1
// implementing the RFC 4122 v4 UUID. It is no longer documented                    // 2
// and will go away.                                                                // 3
// XXX COMPAT WITH 0.5.6                                                            // 4
Meteor.uuid = function () {                                                         // 5
  var HEX_DIGITS = "0123456789abcdef";                                              // 6
  var s = [];                                                                       // 7
  for (var i = 0; i < 36; i++) {                                                    // 8
    s[i] = Random.choice(HEX_DIGITS);                                               // 9
  }                                                                                 // 10
  s[14] = "4";                                                                      // 11
  s[19] = HEX_DIGITS.substr((parseInt(s[19],16) & 0x3) | 0x8, 1);                   // 12
  s[8] = s[13] = s[18] = s[23] = "-";                                               // 13
                                                                                    // 14
  var uuid = s.join("");                                                            // 15
  return uuid;                                                                      // 16
};                                                                                  // 17
                                                                                    // 18
//////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.random = {
  Random: Random
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

/* Package-scope variables */
var Tracker, Deps;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/tracker/tracker.js                                                                                    //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
/////////////////////////////////////////////////////                                                             // 1
// Package docs at http://docs.meteor.com/#tracker //                                                             // 2
/////////////////////////////////////////////////////                                                             // 3
                                                                                                                  // 4
/**                                                                                                               // 5
 * @namespace Tracker                                                                                             // 6
 * @summary The namespace for Tracker-related methods.                                                            // 7
 */                                                                                                               // 8
Tracker = {};                                                                                                     // 9
                                                                                                                  // 10
// http://docs.meteor.com/#tracker_active                                                                         // 11
                                                                                                                  // 12
/**                                                                                                               // 13
 * @summary True if there is a current computation, meaning that dependencies on reactive data sources will be tracked and potentially cause the current computation to be rerun.
 * @locus Client                                                                                                  // 15
 * @type {Boolean}                                                                                                // 16
 */                                                                                                               // 17
Tracker.active = false;                                                                                           // 18
                                                                                                                  // 19
// http://docs.meteor.com/#tracker_currentcomputation                                                             // 20
                                                                                                                  // 21
/**                                                                                                               // 22
 * @summary The current computation, or `null` if there isn't one.  The current computation is the [`Tracker.Computation`](#tracker_computation) object created by the innermost active call to `Tracker.autorun`, and it's the computation that gains dependencies when reactive data sources are accessed.
 * @locus Client                                                                                                  // 24
 * @type {Tracker.Computation}                                                                                    // 25
 */                                                                                                               // 26
Tracker.currentComputation = null;                                                                                // 27
                                                                                                                  // 28
// References to all computations created within the Tracker by id.                                               // 29
// Keeping these references on an underscore property gives more control to                                       // 30
// tooling and packages extending Tracker without increasing the API surface.                                     // 31
// These can used to monkey-patch computations, their functions, use                                              // 32
// computation ids for tracking, etc.                                                                             // 33
Tracker._computations = {};                                                                                       // 34
                                                                                                                  // 35
var setCurrentComputation = function (c) {                                                                        // 36
  Tracker.currentComputation = c;                                                                                 // 37
  Tracker.active = !! c;                                                                                          // 38
};                                                                                                                // 39
                                                                                                                  // 40
var _debugFunc = function () {                                                                                    // 41
  // We want this code to work without Meteor, and also without                                                   // 42
  // "console" (which is technically non-standard and may be missing                                              // 43
  // on some browser we come across, like it was on IE 7).                                                        // 44
  //                                                                                                              // 45
  // Lazy evaluation because `Meteor` does not exist right away.(??)                                              // 46
  return (typeof Meteor !== "undefined" ? Meteor._debug :                                                         // 47
          ((typeof console !== "undefined") && console.error ?                                                    // 48
           function () { console.error.apply(console, arguments); } :                                             // 49
           function () {}));                                                                                      // 50
};                                                                                                                // 51
                                                                                                                  // 52
var _maybeSupressMoreLogs = function (messagesLength) {                                                           // 53
  // Sometimes when running tests, we intentionally supress logs on expected                                      // 54
  // printed errors. Since the current implementation of _throwOrLog can log                                      // 55
  // multiple separate log messages, supress all of them if at least one supress                                  // 56
  // is expected as we still want them to count as one.                                                           // 57
  if (typeof Meteor !== "undefined") {                                                                            // 58
    if (Meteor._supressed_log_expected()) {                                                                       // 59
      Meteor._suppress_log(messagesLength - 1);                                                                   // 60
    }                                                                                                             // 61
  }                                                                                                               // 62
};                                                                                                                // 63
                                                                                                                  // 64
var _throwOrLog = function (from, e) {                                                                            // 65
  if (throwFirstError) {                                                                                          // 66
    throw e;                                                                                                      // 67
  } else {                                                                                                        // 68
    var printArgs = ["Exception from Tracker " + from + " function:"];                                            // 69
    if (e.stack && e.message && e.name) {                                                                         // 70
      var idx = e.stack.indexOf(e.message);                                                                       // 71
      if (idx < 0 || idx > e.name.length + 2) { // check for "Error: "                                            // 72
        // message is not part of the stack                                                                       // 73
        var message = e.name + ": " + e.message;                                                                  // 74
        printArgs.push(message);                                                                                  // 75
      }                                                                                                           // 76
    }                                                                                                             // 77
    printArgs.push(e.stack);                                                                                      // 78
    _maybeSupressMoreLogs(printArgs.length);                                                                      // 79
                                                                                                                  // 80
    for (var i = 0; i < printArgs.length; i++) {                                                                  // 81
      _debugFunc()(printArgs[i]);                                                                                 // 82
    }                                                                                                             // 83
  }                                                                                                               // 84
};                                                                                                                // 85
                                                                                                                  // 86
// Takes a function `f`, and wraps it in a `Meteor._noYieldsAllowed`                                              // 87
// block if we are running on the server. On the client, returns the                                              // 88
// original function (since `Meteor._noYieldsAllowed` is a                                                        // 89
// no-op). This has the benefit of not adding an unnecessary stack                                                // 90
// frame on the client.                                                                                           // 91
var withNoYieldsAllowed = function (f) {                                                                          // 92
  if ((typeof Meteor === 'undefined') || Meteor.isClient) {                                                       // 93
    return f;                                                                                                     // 94
  } else {                                                                                                        // 95
    return function () {                                                                                          // 96
      var args = arguments;                                                                                       // 97
      Meteor._noYieldsAllowed(function () {                                                                       // 98
        f.apply(null, args);                                                                                      // 99
      });                                                                                                         // 100
    };                                                                                                            // 101
  }                                                                                                               // 102
};                                                                                                                // 103
                                                                                                                  // 104
var nextId = 1;                                                                                                   // 105
// computations whose callbacks we should call at flush time                                                      // 106
var pendingComputations = [];                                                                                     // 107
// `true` if a Tracker.flush is scheduled, or if we are in Tracker.flush now                                      // 108
var willFlush = false;                                                                                            // 109
// `true` if we are in Tracker.flush now                                                                          // 110
var inFlush = false;                                                                                              // 111
// `true` if we are computing a computation now, either first time                                                // 112
// or recompute.  This matches Tracker.active unless we are inside                                                // 113
// Tracker.nonreactive, which nullfies currentComputation even though                                             // 114
// an enclosing computation may still be running.                                                                 // 115
var inCompute = false;                                                                                            // 116
// `true` if the `_throwFirstError` option was passed in to the call                                              // 117
// to Tracker.flush that we are in. When set, throw rather than log the                                           // 118
// first error encountered while flushing. Before throwing the error,                                             // 119
// finish flushing (from a finally block), logging any subsequent                                                 // 120
// errors.                                                                                                        // 121
var throwFirstError = false;                                                                                      // 122
                                                                                                                  // 123
var afterFlushCallbacks = [];                                                                                     // 124
                                                                                                                  // 125
var requireFlush = function () {                                                                                  // 126
  if (! willFlush) {                                                                                              // 127
    // We want this code to work without Meteor, see debugFunc above                                              // 128
    if (typeof Meteor !== "undefined")                                                                            // 129
      Meteor._setImmediate(Tracker._runFlush);                                                                    // 130
    else                                                                                                          // 131
      setTimeout(Tracker._runFlush, 0);                                                                           // 132
    willFlush = true;                                                                                             // 133
  }                                                                                                               // 134
};                                                                                                                // 135
                                                                                                                  // 136
// Tracker.Computation constructor is visible but private                                                         // 137
// (throws an error if you try to call it)                                                                        // 138
var constructingComputation = false;                                                                              // 139
                                                                                                                  // 140
//                                                                                                                // 141
// http://docs.meteor.com/#tracker_computation                                                                    // 142
                                                                                                                  // 143
/**                                                                                                               // 144
 * @summary A Computation object represents code that is repeatedly rerun                                         // 145
 * in response to                                                                                                 // 146
 * reactive data changes. Computations don't have return values; they just                                        // 147
 * perform actions, such as rerendering a template on the screen. Computations                                    // 148
 * are created using Tracker.autorun. Use stop to prevent further rerunning of a                                  // 149
 * computation.                                                                                                   // 150
 * @instancename computation                                                                                      // 151
 */                                                                                                               // 152
Tracker.Computation = function (f, parent, onError) {                                                             // 153
  if (! constructingComputation)                                                                                  // 154
    throw new Error(                                                                                              // 155
      "Tracker.Computation constructor is private; use Tracker.autorun");                                         // 156
  constructingComputation = false;                                                                                // 157
                                                                                                                  // 158
  var self = this;                                                                                                // 159
                                                                                                                  // 160
  // http://docs.meteor.com/#computation_stopped                                                                  // 161
                                                                                                                  // 162
  /**                                                                                                             // 163
   * @summary True if this computation has been stopped.                                                          // 164
   * @locus Client                                                                                                // 165
   * @memberOf Tracker.Computation                                                                                // 166
   * @instance                                                                                                    // 167
   * @name  stopped                                                                                               // 168
   */                                                                                                             // 169
  self.stopped = false;                                                                                           // 170
                                                                                                                  // 171
  // http://docs.meteor.com/#computation_invalidated                                                              // 172
                                                                                                                  // 173
  /**                                                                                                             // 174
   * @summary True if this computation has been invalidated (and not yet rerun), or if it has been stopped.       // 175
   * @locus Client                                                                                                // 176
   * @memberOf Tracker.Computation                                                                                // 177
   * @instance                                                                                                    // 178
   * @name  invalidated                                                                                           // 179
   * @type {Boolean}                                                                                              // 180
   */                                                                                                             // 181
  self.invalidated = false;                                                                                       // 182
                                                                                                                  // 183
  // http://docs.meteor.com/#computation_firstrun                                                                 // 184
                                                                                                                  // 185
  /**                                                                                                             // 186
   * @summary True during the initial run of the computation at the time `Tracker.autorun` is called, and false on subsequent reruns and at other times.
   * @locus Client                                                                                                // 188
   * @memberOf Tracker.Computation                                                                                // 189
   * @instance                                                                                                    // 190
   * @name  firstRun                                                                                              // 191
   * @type {Boolean}                                                                                              // 192
   */                                                                                                             // 193
  self.firstRun = true;                                                                                           // 194
                                                                                                                  // 195
  self._id = nextId++;                                                                                            // 196
  self._onInvalidateCallbacks = [];                                                                               // 197
  // the plan is at some point to use the parent relation                                                         // 198
  // to constrain the order that computations are processed                                                       // 199
  self._parent = parent;                                                                                          // 200
  self._func = f;                                                                                                 // 201
  self._onError = onError;                                                                                        // 202
  self._recomputing = false;                                                                                      // 203
                                                                                                                  // 204
  // Register the computation within the global Tracker.                                                          // 205
  Tracker._computations[self._id] = self;                                                                         // 206
                                                                                                                  // 207
  var errored = true;                                                                                             // 208
  try {                                                                                                           // 209
    self._compute();                                                                                              // 210
    errored = false;                                                                                              // 211
  } finally {                                                                                                     // 212
    self.firstRun = false;                                                                                        // 213
    if (errored)                                                                                                  // 214
      self.stop();                                                                                                // 215
  }                                                                                                               // 216
};                                                                                                                // 217
                                                                                                                  // 218
// http://docs.meteor.com/#computation_oninvalidate                                                               // 219
                                                                                                                  // 220
/**                                                                                                               // 221
 * @summary Registers `callback` to run when this computation is next invalidated, or runs it immediately if the computation is already invalidated.  The callback is run exactly once and not upon future invalidations unless `onInvalidate` is called again after the computation becomes valid again.
 * @locus Client                                                                                                  // 223
 * @param {Function} callback Function to be called on invalidation. Receives one argument, the computation that was invalidated.
 */                                                                                                               // 225
Tracker.Computation.prototype.onInvalidate = function (f) {                                                       // 226
  var self = this;                                                                                                // 227
                                                                                                                  // 228
  if (typeof f !== 'function')                                                                                    // 229
    throw new Error("onInvalidate requires a function");                                                          // 230
                                                                                                                  // 231
  if (self.invalidated) {                                                                                         // 232
    Tracker.nonreactive(function () {                                                                             // 233
      withNoYieldsAllowed(f)(self);                                                                               // 234
    });                                                                                                           // 235
  } else {                                                                                                        // 236
    self._onInvalidateCallbacks.push(f);                                                                          // 237
  }                                                                                                               // 238
};                                                                                                                // 239
                                                                                                                  // 240
// http://docs.meteor.com/#computation_invalidate                                                                 // 241
                                                                                                                  // 242
/**                                                                                                               // 243
 * @summary Invalidates this computation so that it will be rerun.                                                // 244
 * @locus Client                                                                                                  // 245
 */                                                                                                               // 246
Tracker.Computation.prototype.invalidate = function () {                                                          // 247
  var self = this;                                                                                                // 248
  if (! self.invalidated) {                                                                                       // 249
    // if we're currently in _recompute(), don't enqueue                                                          // 250
    // ourselves, since we'll rerun immediately anyway.                                                           // 251
    if (! self._recomputing && ! self.stopped) {                                                                  // 252
      requireFlush();                                                                                             // 253
      pendingComputations.push(this);                                                                             // 254
    }                                                                                                             // 255
                                                                                                                  // 256
    self.invalidated = true;                                                                                      // 257
                                                                                                                  // 258
    // callbacks can't add callbacks, because                                                                     // 259
    // self.invalidated === true.                                                                                 // 260
    for(var i = 0, f; f = self._onInvalidateCallbacks[i]; i++) {                                                  // 261
      Tracker.nonreactive(function () {                                                                           // 262
        withNoYieldsAllowed(f)(self);                                                                             // 263
      });                                                                                                         // 264
    }                                                                                                             // 265
    self._onInvalidateCallbacks = [];                                                                             // 266
  }                                                                                                               // 267
};                                                                                                                // 268
                                                                                                                  // 269
// http://docs.meteor.com/#computation_stop                                                                       // 270
                                                                                                                  // 271
/**                                                                                                               // 272
 * @summary Prevents this computation from rerunning.                                                             // 273
 * @locus Client                                                                                                  // 274
 */                                                                                                               // 275
Tracker.Computation.prototype.stop = function () {                                                                // 276
  if (! this.stopped) {                                                                                           // 277
    this.stopped = true;                                                                                          // 278
    this.invalidate();                                                                                            // 279
    // Unregister from global Tracker.                                                                            // 280
    delete Tracker._computations[this._id];                                                                       // 281
  }                                                                                                               // 282
};                                                                                                                // 283
                                                                                                                  // 284
Tracker.Computation.prototype._compute = function () {                                                            // 285
  var self = this;                                                                                                // 286
  self.invalidated = false;                                                                                       // 287
                                                                                                                  // 288
  var previous = Tracker.currentComputation;                                                                      // 289
  setCurrentComputation(self);                                                                                    // 290
  var previousInCompute = inCompute;                                                                              // 291
  inCompute = true;                                                                                               // 292
  try {                                                                                                           // 293
    withNoYieldsAllowed(self._func)(self);                                                                        // 294
  } finally {                                                                                                     // 295
    setCurrentComputation(previous);                                                                              // 296
    inCompute = previousInCompute;                                                                                // 297
  }                                                                                                               // 298
};                                                                                                                // 299
                                                                                                                  // 300
Tracker.Computation.prototype._needsRecompute = function () {                                                     // 301
  var self = this;                                                                                                // 302
  return self.invalidated && ! self.stopped;                                                                      // 303
};                                                                                                                // 304
                                                                                                                  // 305
Tracker.Computation.prototype._recompute = function () {                                                          // 306
  var self = this;                                                                                                // 307
                                                                                                                  // 308
  self._recomputing = true;                                                                                       // 309
  try {                                                                                                           // 310
    if (self._needsRecompute()) {                                                                                 // 311
      try {                                                                                                       // 312
        self._compute();                                                                                          // 313
      } catch (e) {                                                                                               // 314
        if (self._onError) {                                                                                      // 315
          self._onError(e);                                                                                       // 316
        } else {                                                                                                  // 317
          _throwOrLog("recompute", e);                                                                            // 318
        }                                                                                                         // 319
      }                                                                                                           // 320
    }                                                                                                             // 321
  } finally {                                                                                                     // 322
    self._recomputing = false;                                                                                    // 323
  }                                                                                                               // 324
};                                                                                                                // 325
                                                                                                                  // 326
//                                                                                                                // 327
// http://docs.meteor.com/#tracker_dependency                                                                     // 328
                                                                                                                  // 329
/**                                                                                                               // 330
 * @summary A Dependency represents an atomic unit of reactive data that a                                        // 331
 * computation might depend on. Reactive data sources such as Session or                                          // 332
 * Minimongo internally create different Dependency objects for different                                         // 333
 * pieces of data, each of which may be depended on by multiple computations.                                     // 334
 * When the data changes, the computations are invalidated.                                                       // 335
 * @class                                                                                                         // 336
 * @instanceName dependency                                                                                       // 337
 */                                                                                                               // 338
Tracker.Dependency = function () {                                                                                // 339
  this._dependentsById = {};                                                                                      // 340
};                                                                                                                // 341
                                                                                                                  // 342
// http://docs.meteor.com/#dependency_depend                                                                      // 343
//                                                                                                                // 344
// Adds `computation` to this set if it is not already                                                            // 345
// present.  Returns true if `computation` is a new member of the set.                                            // 346
// If no argument, defaults to currentComputation, or does nothing                                                // 347
// if there is no currentComputation.                                                                             // 348
                                                                                                                  // 349
/**                                                                                                               // 350
 * @summary Declares that the current computation (or `fromComputation` if given) depends on `dependency`.  The computation will be invalidated the next time `dependency` changes.
                                                                                                                  // 352
If there is no current computation and `depend()` is called with no arguments, it does nothing and returns false. // 353
                                                                                                                  // 354
Returns true if the computation is a new dependent of `dependency` rather than an existing one.                   // 355
 * @locus Client                                                                                                  // 356
 * @param {Tracker.Computation} [fromComputation] An optional computation declared to depend on `dependency` instead of the current computation.
 * @returns {Boolean}                                                                                             // 358
 */                                                                                                               // 359
Tracker.Dependency.prototype.depend = function (computation) {                                                    // 360
  if (! computation) {                                                                                            // 361
    if (! Tracker.active)                                                                                         // 362
      return false;                                                                                               // 363
                                                                                                                  // 364
    computation = Tracker.currentComputation;                                                                     // 365
  }                                                                                                               // 366
  var self = this;                                                                                                // 367
  var id = computation._id;                                                                                       // 368
  if (! (id in self._dependentsById)) {                                                                           // 369
    self._dependentsById[id] = computation;                                                                       // 370
    computation.onInvalidate(function () {                                                                        // 371
      delete self._dependentsById[id];                                                                            // 372
    });                                                                                                           // 373
    return true;                                                                                                  // 374
  }                                                                                                               // 375
  return false;                                                                                                   // 376
};                                                                                                                // 377
                                                                                                                  // 378
// http://docs.meteor.com/#dependency_changed                                                                     // 379
                                                                                                                  // 380
/**                                                                                                               // 381
 * @summary Invalidate all dependent computations immediately and remove them as dependents.                      // 382
 * @locus Client                                                                                                  // 383
 */                                                                                                               // 384
Tracker.Dependency.prototype.changed = function () {                                                              // 385
  var self = this;                                                                                                // 386
  for (var id in self._dependentsById)                                                                            // 387
    self._dependentsById[id].invalidate();                                                                        // 388
};                                                                                                                // 389
                                                                                                                  // 390
// http://docs.meteor.com/#dependency_hasdependents                                                               // 391
                                                                                                                  // 392
/**                                                                                                               // 393
 * @summary True if this Dependency has one or more dependent Computations, which would be invalidated if this Dependency were to change.
 * @locus Client                                                                                                  // 395
 * @returns {Boolean}                                                                                             // 396
 */                                                                                                               // 397
Tracker.Dependency.prototype.hasDependents = function () {                                                        // 398
  var self = this;                                                                                                // 399
  for(var id in self._dependentsById)                                                                             // 400
    return true;                                                                                                  // 401
  return false;                                                                                                   // 402
};                                                                                                                // 403
                                                                                                                  // 404
// http://docs.meteor.com/#tracker_flush                                                                          // 405
                                                                                                                  // 406
/**                                                                                                               // 407
 * @summary Process all reactive updates immediately and ensure that all invalidated computations are rerun.      // 408
 * @locus Client                                                                                                  // 409
 */                                                                                                               // 410
Tracker.flush = function (options) {                                                                              // 411
  Tracker._runFlush({ finishSynchronously: true,                                                                  // 412
                      throwFirstError: options && options._throwFirstError });                                    // 413
};                                                                                                                // 414
                                                                                                                  // 415
// Run all pending computations and afterFlush callbacks.  If we were not called                                  // 416
// directly via Tracker.flush, this may return before they're all done to allow                                   // 417
// the event loop to run a little before continuing.                                                              // 418
Tracker._runFlush = function (options) {                                                                          // 419
  // XXX What part of the comment below is still true? (We no longer                                              // 420
  // have Spark)                                                                                                  // 421
  //                                                                                                              // 422
  // Nested flush could plausibly happen if, say, a flush causes                                                  // 423
  // DOM mutation, which causes a "blur" event, which runs an                                                     // 424
  // app event handler that calls Tracker.flush.  At the moment                                                   // 425
  // Spark blocks event handlers during DOM mutation anyway,                                                      // 426
  // because the LiveRange tree isn't valid.  And we don't have                                                   // 427
  // any useful notion of a nested flush.                                                                         // 428
  //                                                                                                              // 429
  // https://app.asana.com/0/159908330244/385138233856                                                            // 430
  if (inFlush)                                                                                                    // 431
    throw new Error("Can't call Tracker.flush while flushing");                                                   // 432
                                                                                                                  // 433
  if (inCompute)                                                                                                  // 434
    throw new Error("Can't flush inside Tracker.autorun");                                                        // 435
                                                                                                                  // 436
  options = options || {};                                                                                        // 437
                                                                                                                  // 438
  inFlush = true;                                                                                                 // 439
  willFlush = true;                                                                                               // 440
  throwFirstError = !! options.throwFirstError;                                                                   // 441
                                                                                                                  // 442
  var recomputedCount = 0;                                                                                        // 443
  var finishedTry = false;                                                                                        // 444
  try {                                                                                                           // 445
    while (pendingComputations.length ||                                                                          // 446
           afterFlushCallbacks.length) {                                                                          // 447
                                                                                                                  // 448
      // recompute all pending computations                                                                       // 449
      while (pendingComputations.length) {                                                                        // 450
        var comp = pendingComputations.shift();                                                                   // 451
        comp._recompute();                                                                                        // 452
        if (comp._needsRecompute()) {                                                                             // 453
          pendingComputations.unshift(comp);                                                                      // 454
        }                                                                                                         // 455
                                                                                                                  // 456
        if (! options.finishSynchronously && ++recomputedCount > 1000) {                                          // 457
          finishedTry = true;                                                                                     // 458
          return;                                                                                                 // 459
        }                                                                                                         // 460
      }                                                                                                           // 461
                                                                                                                  // 462
      if (afterFlushCallbacks.length) {                                                                           // 463
        // call one afterFlush callback, which may                                                                // 464
        // invalidate more computations                                                                           // 465
        var func = afterFlushCallbacks.shift();                                                                   // 466
        try {                                                                                                     // 467
          func();                                                                                                 // 468
        } catch (e) {                                                                                             // 469
          _throwOrLog("afterFlush", e);                                                                           // 470
        }                                                                                                         // 471
      }                                                                                                           // 472
    }                                                                                                             // 473
    finishedTry = true;                                                                                           // 474
  } finally {                                                                                                     // 475
    if (! finishedTry) {                                                                                          // 476
      // we're erroring due to throwFirstError being true.                                                        // 477
      inFlush = false; // needed before calling `Tracker.flush()` again                                           // 478
      // finish flushing                                                                                          // 479
      Tracker._runFlush({                                                                                         // 480
        finishSynchronously: options.finishSynchronously,                                                         // 481
        throwFirstError: false                                                                                    // 482
      });                                                                                                         // 483
    }                                                                                                             // 484
    willFlush = false;                                                                                            // 485
    inFlush = false;                                                                                              // 486
    if (pendingComputations.length || afterFlushCallbacks.length) {                                               // 487
      // We're yielding because we ran a bunch of computations and we aren't                                      // 488
      // required to finish synchronously, so we'd like to give the event loop a                                  // 489
      // chance. We should flush again soon.                                                                      // 490
      if (options.finishSynchronously) {                                                                          // 491
        throw new Error("still have more to do?");  // shouldn't happen                                           // 492
      }                                                                                                           // 493
      setTimeout(requireFlush, 10);                                                                               // 494
    }                                                                                                             // 495
  }                                                                                                               // 496
};                                                                                                                // 497
                                                                                                                  // 498
// http://docs.meteor.com/#tracker_autorun                                                                        // 499
//                                                                                                                // 500
// Run f(). Record its dependencies. Rerun it whenever the                                                        // 501
// dependencies change.                                                                                           // 502
//                                                                                                                // 503
// Returns a new Computation, which is also passed to f.                                                          // 504
//                                                                                                                // 505
// Links the computation to the current computation                                                               // 506
// so that it is stopped if the current computation is invalidated.                                               // 507
                                                                                                                  // 508
/**                                                                                                               // 509
 * @callback Tracker.ComputationFunction                                                                          // 510
 * @param {Tracker.Computation}                                                                                   // 511
 */                                                                                                               // 512
/**                                                                                                               // 513
 * @summary Run a function now and rerun it later whenever its dependencies                                       // 514
 * change. Returns a Computation object that can be used to stop or observe the                                   // 515
 * rerunning.                                                                                                     // 516
 * @locus Client                                                                                                  // 517
 * @param {Tracker.ComputationFunction} runFunc The function to run. It receives                                  // 518
 * one argument: the Computation object that will be returned.                                                    // 519
 * @param {Object} [options]                                                                                      // 520
 * @param {Function} options.onError Optional. The function to run when an error                                  // 521
 * happens in the Computation. The only argument it recieves is the Error                                         // 522
 * thrown. Defaults to the error being logged to the console.                                                     // 523
 * @returns {Tracker.Computation}                                                                                 // 524
 */                                                                                                               // 525
Tracker.autorun = function (f, options) {                                                                         // 526
  if (typeof f !== 'function')                                                                                    // 527
    throw new Error('Tracker.autorun requires a function argument');                                              // 528
                                                                                                                  // 529
  options = options || {};                                                                                        // 530
                                                                                                                  // 531
  constructingComputation = true;                                                                                 // 532
  var c = new Tracker.Computation(                                                                                // 533
    f, Tracker.currentComputation, options.onError);                                                              // 534
                                                                                                                  // 535
  if (Tracker.active)                                                                                             // 536
    Tracker.onInvalidate(function () {                                                                            // 537
      c.stop();                                                                                                   // 538
    });                                                                                                           // 539
                                                                                                                  // 540
  return c;                                                                                                       // 541
};                                                                                                                // 542
                                                                                                                  // 543
// http://docs.meteor.com/#tracker_nonreactive                                                                    // 544
//                                                                                                                // 545
// Run `f` with no current computation, returning the return value                                                // 546
// of `f`.  Used to turn off reactivity for the duration of `f`,                                                  // 547
// so that reactive data sources accessed by `f` will not result in any                                           // 548
// computations being invalidated.                                                                                // 549
                                                                                                                  // 550
/**                                                                                                               // 551
 * @summary Run a function without tracking dependencies.                                                         // 552
 * @locus Client                                                                                                  // 553
 * @param {Function} func A function to call immediately.                                                         // 554
 */                                                                                                               // 555
Tracker.nonreactive = function (f) {                                                                              // 556
  var previous = Tracker.currentComputation;                                                                      // 557
  setCurrentComputation(null);                                                                                    // 558
  try {                                                                                                           // 559
    return f();                                                                                                   // 560
  } finally {                                                                                                     // 561
    setCurrentComputation(previous);                                                                              // 562
  }                                                                                                               // 563
};                                                                                                                // 564
                                                                                                                  // 565
// http://docs.meteor.com/#tracker_oninvalidate                                                                   // 566
                                                                                                                  // 567
/**                                                                                                               // 568
 * @summary Registers a new [`onInvalidate`](#computation_oninvalidate) callback on the current computation (which must exist), to be called immediately when the current computation is invalidated or stopped.
 * @locus Client                                                                                                  // 570
 * @param {Function} callback A callback function that will be invoked as `func(c)`, where `c` is the computation on which the callback is registered.
 */                                                                                                               // 572
Tracker.onInvalidate = function (f) {                                                                             // 573
  if (! Tracker.active)                                                                                           // 574
    throw new Error("Tracker.onInvalidate requires a currentComputation");                                        // 575
                                                                                                                  // 576
  Tracker.currentComputation.onInvalidate(f);                                                                     // 577
};                                                                                                                // 578
                                                                                                                  // 579
// http://docs.meteor.com/#tracker_afterflush                                                                     // 580
                                                                                                                  // 581
/**                                                                                                               // 582
 * @summary Schedules a function to be called during the next flush, or later in the current flush if one is in progress, after all invalidated computations have been rerun.  The function will be run once and not on subsequent flushes unless `afterFlush` is called again.
 * @locus Client                                                                                                  // 584
 * @param {Function} callback A function to call at flush time.                                                   // 585
 */                                                                                                               // 586
Tracker.afterFlush = function (f) {                                                                               // 587
  afterFlushCallbacks.push(f);                                                                                    // 588
  requireFlush();                                                                                                 // 589
};                                                                                                                // 590
                                                                                                                  // 591
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/tracker/deprecated.js                                                                                 //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// Deprecated functions.                                                                                          // 1
                                                                                                                  // 2
// These functions used to be on the Meteor object (and worked slightly                                           // 3
// differently).                                                                                                  // 4
// XXX COMPAT WITH 0.5.7                                                                                          // 5
Meteor.flush = Tracker.flush;                                                                                     // 6
Meteor.autorun = Tracker.autorun;                                                                                 // 7
                                                                                                                  // 8
// We used to require a special "autosubscribe" call to reactively subscribe to                                   // 9
// things. Now, it works with autorun.                                                                            // 10
// XXX COMPAT WITH 0.5.4                                                                                          // 11
Meteor.autosubscribe = Tracker.autorun;                                                                           // 12
                                                                                                                  // 13
// This Tracker API briefly existed in 0.5.8 and 0.5.9                                                            // 14
// XXX COMPAT WITH 0.5.9                                                                                          // 15
Tracker.depend = function (d) {                                                                                   // 16
  return d.depend();                                                                                              // 17
};                                                                                                                // 18
                                                                                                                  // 19
Deps = Tracker;                                                                                                   // 20
                                                                                                                  // 21
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.tracker = {
  Tracker: Tracker,
  Deps: Deps
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var Random = Package.random.Random;

/* Package-scope variables */
var Retry;

(function () {

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// packages/retry/retry.js                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////
                                                                           //
// Retry logic with an exponential backoff.                                // 1
//                                                                         // 2
// options:                                                                // 3
//  baseTimeout: time for initial reconnect attempt (ms).                  // 4
//  exponent: exponential factor to increase timeout each attempt.         // 5
//  maxTimeout: maximum time between retries (ms).                         // 6
//  minCount: how many times to reconnect "instantly".                     // 7
//  minTimeout: time to wait for the first `minCount` retries (ms).        // 8
//  fuzz: factor to randomize retry times by (to avoid retry storms).      // 9
                                                                           // 10
Retry = function (options) {                                               // 11
  var self = this;                                                         // 12
  _.extend(self, _.defaults(_.clone(options || {}), {                      // 13
    baseTimeout: 1000, // 1 second                                         // 14
    exponent: 2.2,                                                         // 15
    // The default is high-ish to ensure a server can recover from a       // 16
    // failure caused by load.                                             // 17
    maxTimeout: 5 * 60000, // 5 minutes                                    // 18
    minTimeout: 10,                                                        // 19
    minCount: 2,                                                           // 20
    fuzz: 0.5 // +- 25%                                                    // 21
  }));                                                                     // 22
  self.retryTimer = null;                                                  // 23
};                                                                         // 24
                                                                           // 25
_.extend(Retry.prototype, {                                                // 26
                                                                           // 27
  // Reset a pending retry, if any.                                        // 28
  clear: function () {                                                     // 29
    var self = this;                                                       // 30
    if (self.retryTimer)                                                   // 31
      clearTimeout(self.retryTimer);                                       // 32
    self.retryTimer = null;                                                // 33
  },                                                                       // 34
                                                                           // 35
  // Calculate how long to wait in milliseconds to retry, based on the     // 36
  // `count` of which retry this is.                                       // 37
  _timeout: function (count) {                                             // 38
    var self = this;                                                       // 39
                                                                           // 40
    if (count < self.minCount)                                             // 41
      return self.minTimeout;                                              // 42
                                                                           // 43
    var timeout = Math.min(                                                // 44
      self.maxTimeout,                                                     // 45
      self.baseTimeout * Math.pow(self.exponent, count));                  // 46
    // fuzz the timeout randomly, to avoid reconnect storms when a         // 47
    // server goes down.                                                   // 48
    timeout = timeout * ((Random.fraction() * self.fuzz) +                 // 49
                         (1 - self.fuzz/2));                               // 50
    return timeout;                                                        // 51
  },                                                                       // 52
                                                                           // 53
  // Call `fn` after a delay, based on the `count` of which retry this is. // 54
  retryLater: function (count, fn) {                                       // 55
    var self = this;                                                       // 56
    var timeout = self._timeout(count);                                    // 57
    if (self.retryTimer)                                                   // 58
      clearTimeout(self.retryTimer);                                       // 59
    self.retryTimer = Meteor.setTimeout(fn, timeout);                      // 60
    return timeout;                                                        // 61
  }                                                                        // 62
                                                                           // 63
});                                                                        // 64
                                                                           // 65
/////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.retry = {
  Retry: Retry
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var JSON = Package.json.JSON;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var IdMap;

(function () {

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// packages/id-map/id-map.js                                                  //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
                                                                              //
IdMap = function (idStringify, idParse) {                                     // 1
  var self = this;                                                            // 2
  self._map = {};                                                             // 3
  self._idStringify = idStringify || JSON.stringify;                          // 4
  self._idParse = idParse || JSON.parse;                                      // 5
};                                                                            // 6
                                                                              // 7
// Some of these methods are designed to match methods on OrderedDict, since  // 8
// (eg) ObserveMultiplex and _CachingChangeObserver use them interchangeably. // 9
// (Conceivably, this should be replaced with "UnorderedDict" with a specific // 10
// set of methods that overlap between the two.)                              // 11
                                                                              // 12
_.extend(IdMap.prototype, {                                                   // 13
  get: function (id) {                                                        // 14
    var self = this;                                                          // 15
    var key = self._idStringify(id);                                          // 16
    return self._map[key];                                                    // 17
  },                                                                          // 18
  set: function (id, value) {                                                 // 19
    var self = this;                                                          // 20
    var key = self._idStringify(id);                                          // 21
    self._map[key] = value;                                                   // 22
  },                                                                          // 23
  remove: function (id) {                                                     // 24
    var self = this;                                                          // 25
    var key = self._idStringify(id);                                          // 26
    delete self._map[key];                                                    // 27
  },                                                                          // 28
  has: function (id) {                                                        // 29
    var self = this;                                                          // 30
    var key = self._idStringify(id);                                          // 31
    return _.has(self._map, key);                                             // 32
  },                                                                          // 33
  empty: function () {                                                        // 34
    var self = this;                                                          // 35
    return _.isEmpty(self._map);                                              // 36
  },                                                                          // 37
  clear: function () {                                                        // 38
    var self = this;                                                          // 39
    self._map = {};                                                           // 40
  },                                                                          // 41
  // Iterates over the items in the map. Return `false` to break the loop.    // 42
  forEach: function (iterator) {                                              // 43
    var self = this;                                                          // 44
    // don't use _.each, because we can't break out of it.                    // 45
    var keys = _.keys(self._map);                                             // 46
    for (var i = 0; i < keys.length; i++) {                                   // 47
      var breakIfFalse = iterator.call(null, self._map[keys[i]],              // 48
                                       self._idParse(keys[i]));               // 49
      if (breakIfFalse === false)                                             // 50
        return;                                                               // 51
    }                                                                         // 52
  },                                                                          // 53
  size: function () {                                                         // 54
    var self = this;                                                          // 55
    return _.size(self._map);                                                 // 56
  },                                                                          // 57
  setDefault: function (id, def) {                                            // 58
    var self = this;                                                          // 59
    var key = self._idStringify(id);                                          // 60
    if (_.has(self._map, key))                                                // 61
      return self._map[key];                                                  // 62
    self._map[key] = def;                                                     // 63
    return def;                                                               // 64
  },                                                                          // 65
  // Assumes that values are EJSON-cloneable, and that we don't need to clone // 66
  // IDs (ie, that nobody is going to mutate an ObjectId).                    // 67
  clone: function () {                                                        // 68
    var self = this;                                                          // 69
    var clone = new IdMap(self._idStringify, self._idParse);                  // 70
    self.forEach(function (value, id) {                                       // 71
      clone.set(id, EJSON.clone(value));                                      // 72
    });                                                                       // 73
    return clone;                                                             // 74
  }                                                                           // 75
});                                                                           // 76
                                                                              // 77
                                                                              // 78
////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['id-map'] = {
  IdMap: IdMap
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var OrderedDict;

(function () {

///////////////////////////////////////////////////////////////////////////////////
//                                                                               //
// packages/ordered-dict/ordered_dict.js                                         //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////
                                                                                 //
// This file defines an ordered dictionary abstraction that is useful for        // 1
// maintaining a dataset backed by observeChanges.  It supports ordering items   // 2
// by specifying the item they now come before.                                  // 3
                                                                                 // 4
// The implementation is a dictionary that contains nodes of a doubly-linked     // 5
// list as its values.                                                           // 6
                                                                                 // 7
// constructs a new element struct                                               // 8
// next and prev are whole elements, not keys.                                   // 9
var element = function (key, value, next, prev) {                                // 10
  return {                                                                       // 11
    key: key,                                                                    // 12
    value: value,                                                                // 13
    next: next,                                                                  // 14
    prev: prev                                                                   // 15
  };                                                                             // 16
};                                                                               // 17
OrderedDict = function (/* ... */) {                                             // 18
  var self = this;                                                               // 19
  self._dict = {};                                                               // 20
  self._first = null;                                                            // 21
  self._last = null;                                                             // 22
  self._size = 0;                                                                // 23
  var args = _.toArray(arguments);                                               // 24
  self._stringify = function (x) { return x; };                                  // 25
  if (typeof args[0] === 'function')                                             // 26
    self._stringify = args.shift();                                              // 27
  _.each(args, function (kv) {                                                   // 28
    self.putBefore(kv[0], kv[1], null);                                          // 29
  });                                                                            // 30
};                                                                               // 31
                                                                                 // 32
_.extend(OrderedDict.prototype, {                                                // 33
  // the "prefix keys with a space" thing comes from here                        // 34
  // https://github.com/documentcloud/underscore/issues/376#issuecomment-2815649 // 35
  _k: function (key) { return " " + this._stringify(key); },                     // 36
                                                                                 // 37
  empty: function () {                                                           // 38
    var self = this;                                                             // 39
    return !self._first;                                                         // 40
  },                                                                             // 41
  size: function () {                                                            // 42
    var self = this;                                                             // 43
    return self._size;                                                           // 44
  },                                                                             // 45
  _linkEltIn: function (elt) {                                                   // 46
    var self = this;                                                             // 47
    if (!elt.next) {                                                             // 48
      elt.prev = self._last;                                                     // 49
      if (self._last)                                                            // 50
        self._last.next = elt;                                                   // 51
      self._last = elt;                                                          // 52
    } else {                                                                     // 53
      elt.prev = elt.next.prev;                                                  // 54
      elt.next.prev = elt;                                                       // 55
      if (elt.prev)                                                              // 56
        elt.prev.next = elt;                                                     // 57
    }                                                                            // 58
    if (self._first === null || self._first === elt.next)                        // 59
      self._first = elt;                                                         // 60
  },                                                                             // 61
  _linkEltOut: function (elt) {                                                  // 62
    var self = this;                                                             // 63
    if (elt.next)                                                                // 64
      elt.next.prev = elt.prev;                                                  // 65
    if (elt.prev)                                                                // 66
      elt.prev.next = elt.next;                                                  // 67
    if (elt === self._last)                                                      // 68
      self._last = elt.prev;                                                     // 69
    if (elt === self._first)                                                     // 70
      self._first = elt.next;                                                    // 71
  },                                                                             // 72
  putBefore: function (key, item, before) {                                      // 73
    var self = this;                                                             // 74
    if (self._dict[self._k(key)])                                                // 75
      throw new Error("Item " + key + " already present in OrderedDict");        // 76
    var elt = before ?                                                           // 77
          element(key, item, self._dict[self._k(before)]) :                      // 78
          element(key, item, null);                                              // 79
    if (elt.next === undefined)                                                  // 80
      throw new Error("could not find item to put this one before");             // 81
    self._linkEltIn(elt);                                                        // 82
    self._dict[self._k(key)] = elt;                                              // 83
    self._size++;                                                                // 84
  },                                                                             // 85
  append: function (key, item) {                                                 // 86
    var self = this;                                                             // 87
    self.putBefore(key, item, null);                                             // 88
  },                                                                             // 89
  remove: function (key) {                                                       // 90
    var self = this;                                                             // 91
    var elt = self._dict[self._k(key)];                                          // 92
    if (elt === undefined)                                                       // 93
      throw new Error("Item " + key + " not present in OrderedDict");            // 94
    self._linkEltOut(elt);                                                       // 95
    self._size--;                                                                // 96
    delete self._dict[self._k(key)];                                             // 97
    return elt.value;                                                            // 98
  },                                                                             // 99
  get: function (key) {                                                          // 100
    var self = this;                                                             // 101
    if (self.has(key))                                                           // 102
        return self._dict[self._k(key)].value;                                   // 103
    return undefined;                                                            // 104
  },                                                                             // 105
  has: function (key) {                                                          // 106
    var self = this;                                                             // 107
    return _.has(self._dict, self._k(key));                                      // 108
  },                                                                             // 109
  // Iterate through the items in this dictionary in order, calling              // 110
  // iter(value, key, index) on each one.                                        // 111
                                                                                 // 112
  // Stops whenever iter returns OrderedDict.BREAK, or after the last element.   // 113
  forEach: function (iter) {                                                     // 114
    var self = this;                                                             // 115
    var i = 0;                                                                   // 116
    var elt = self._first;                                                       // 117
    while (elt !== null) {                                                       // 118
      var b = iter(elt.value, elt.key, i);                                       // 119
      if (b === OrderedDict.BREAK)                                               // 120
        return;                                                                  // 121
      elt = elt.next;                                                            // 122
      i++;                                                                       // 123
    }                                                                            // 124
  },                                                                             // 125
  first: function () {                                                           // 126
    var self = this;                                                             // 127
    if (self.empty())                                                            // 128
      return undefined;                                                          // 129
    return self._first.key;                                                      // 130
  },                                                                             // 131
  firstValue: function () {                                                      // 132
    var self = this;                                                             // 133
    if (self.empty())                                                            // 134
      return undefined;                                                          // 135
    return self._first.value;                                                    // 136
  },                                                                             // 137
  last: function () {                                                            // 138
    var self = this;                                                             // 139
    if (self.empty())                                                            // 140
      return undefined;                                                          // 141
    return self._last.key;                                                       // 142
  },                                                                             // 143
  lastValue: function () {                                                       // 144
    var self = this;                                                             // 145
    if (self.empty())                                                            // 146
      return undefined;                                                          // 147
    return self._last.value;                                                     // 148
  },                                                                             // 149
  prev: function (key) {                                                         // 150
    var self = this;                                                             // 151
    if (self.has(key)) {                                                         // 152
      var elt = self._dict[self._k(key)];                                        // 153
      if (elt.prev)                                                              // 154
        return elt.prev.key;                                                     // 155
    }                                                                            // 156
    return null;                                                                 // 157
  },                                                                             // 158
  next: function (key) {                                                         // 159
    var self = this;                                                             // 160
    if (self.has(key)) {                                                         // 161
      var elt = self._dict[self._k(key)];                                        // 162
      if (elt.next)                                                              // 163
        return elt.next.key;                                                     // 164
    }                                                                            // 165
    return null;                                                                 // 166
  },                                                                             // 167
  moveBefore: function (key, before) {                                           // 168
    var self = this;                                                             // 169
    var elt = self._dict[self._k(key)];                                          // 170
    var eltBefore = before ? self._dict[self._k(before)] : null;                 // 171
    if (elt === undefined)                                                       // 172
      throw new Error("Item to move is not present");                            // 173
    if (eltBefore === undefined) {                                               // 174
      throw new Error("Could not find element to move this one before");         // 175
    }                                                                            // 176
    if (eltBefore === elt.next) // no moving necessary                           // 177
      return;                                                                    // 178
    // remove from its old place                                                 // 179
    self._linkEltOut(elt);                                                       // 180
    // patch into its new place                                                  // 181
    elt.next = eltBefore;                                                        // 182
    self._linkEltIn(elt);                                                        // 183
  },                                                                             // 184
  // Linear, sadly.                                                              // 185
  indexOf: function (key) {                                                      // 186
    var self = this;                                                             // 187
    var ret = null;                                                              // 188
    self.forEach(function (v, k, i) {                                            // 189
      if (self._k(k) === self._k(key)) {                                         // 190
        ret = i;                                                                 // 191
        return OrderedDict.BREAK;                                                // 192
      }                                                                          // 193
      return undefined;                                                          // 194
    });                                                                          // 195
    return ret;                                                                  // 196
  },                                                                             // 197
  _checkRep: function () {                                                       // 198
    var self = this;                                                             // 199
    _.each(self._dict, function (k, v) {                                         // 200
      if (v.next === v)                                                          // 201
        throw new Error("Next is a loop");                                       // 202
      if (v.prev === v)                                                          // 203
        throw new Error("Prev is a loop");                                       // 204
    });                                                                          // 205
  }                                                                              // 206
                                                                                 // 207
});                                                                              // 208
OrderedDict.BREAK = {"break": true};                                             // 209
                                                                                 // 210
///////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['ordered-dict'] = {
  OrderedDict: OrderedDict
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

/* Package-scope variables */
var GeoJSON, module;

(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                         //
// packages/geojson-utils/pre.js                                                                           //
//                                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                           //
// Define an object named exports. This will cause geojson-utils.js to put `gju`                           // 1
// as a field on it, instead of in the global namespace.  See also post.js.                                // 2
module = {exports:{}};                                                                                     // 3
                                                                                                           // 4
                                                                                                           // 5
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                         //
// packages/geojson-utils/geojson-utils.js                                                                 //
//                                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                           //
(function () {                                                                                             // 1
  var gju = {};                                                                                            // 2
                                                                                                           // 3
  // Export the geojson object for **CommonJS**                                                            // 4
  if (typeof module !== 'undefined' && module.exports) {                                                   // 5
    module.exports = gju;                                                                                  // 6
  }                                                                                                        // 7
                                                                                                           // 8
  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js                           // 9
  gju.lineStringsIntersect = function (l1, l2) {                                                           // 10
    var intersects = [];                                                                                   // 11
    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {                                                 // 12
      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {                                               // 13
        var a1 = {                                                                                         // 14
          x: l1.coordinates[i][1],                                                                         // 15
          y: l1.coordinates[i][0]                                                                          // 16
        },                                                                                                 // 17
          a2 = {                                                                                           // 18
            x: l1.coordinates[i + 1][1],                                                                   // 19
            y: l1.coordinates[i + 1][0]                                                                    // 20
          },                                                                                               // 21
          b1 = {                                                                                           // 22
            x: l2.coordinates[j][1],                                                                       // 23
            y: l2.coordinates[j][0]                                                                        // 24
          },                                                                                               // 25
          b2 = {                                                                                           // 26
            x: l2.coordinates[j + 1][1],                                                                   // 27
            y: l2.coordinates[j + 1][0]                                                                    // 28
          },                                                                                               // 29
          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),                            // 30
          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),                            // 31
          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);                             // 32
        if (u_b != 0) {                                                                                    // 33
          var ua = ua_t / u_b,                                                                             // 34
            ub = ub_t / u_b;                                                                               // 35
          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {                                                  // 36
            intersects.push({                                                                              // 37
              'type': 'Point',                                                                             // 38
              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]                        // 39
            });                                                                                            // 40
          }                                                                                                // 41
        }                                                                                                  // 42
      }                                                                                                    // 43
    }                                                                                                      // 44
    if (intersects.length == 0) intersects = false;                                                        // 45
    return intersects;                                                                                     // 46
  }                                                                                                        // 47
                                                                                                           // 48
  // Bounding Box                                                                                          // 49
                                                                                                           // 50
  function boundingBoxAroundPolyCoords (coords) {                                                          // 51
    var xAll = [], yAll = []                                                                               // 52
                                                                                                           // 53
    for (var i = 0; i < coords[0].length; i++) {                                                           // 54
      xAll.push(coords[0][i][1])                                                                           // 55
      yAll.push(coords[0][i][0])                                                                           // 56
    }                                                                                                      // 57
                                                                                                           // 58
    xAll = xAll.sort(function (a,b) { return a - b })                                                      // 59
    yAll = yAll.sort(function (a,b) { return a - b })                                                      // 60
                                                                                                           // 61
    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]                          // 62
  }                                                                                                        // 63
                                                                                                           // 64
  gju.pointInBoundingBox = function (point, bounds) {                                                      // 65
    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1])
  }                                                                                                        // 67
                                                                                                           // 68
  // Point in Polygon                                                                                      // 69
  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices           // 70
                                                                                                           // 71
  function pnpoly (x,y,coords) {                                                                           // 72
    var vert = [ [0,0] ]                                                                                   // 73
                                                                                                           // 74
    for (var i = 0; i < coords.length; i++) {                                                              // 75
      for (var j = 0; j < coords[i].length; j++) {                                                         // 76
        vert.push(coords[i][j])                                                                            // 77
      }                                                                                                    // 78
      vert.push([0,0])                                                                                     // 79
    }                                                                                                      // 80
                                                                                                           // 81
    var inside = false                                                                                     // 82
    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {                                       // 83
      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside
    }                                                                                                      // 85
                                                                                                           // 86
    return inside                                                                                          // 87
  }                                                                                                        // 88
                                                                                                           // 89
  gju.pointInPolygon = function (p, poly) {                                                                // 90
    var coords = (poly.type == "Polygon") ? [ poly.coordinates ] : poly.coordinates                        // 91
                                                                                                           // 92
    var insideBox = false                                                                                  // 93
    for (var i = 0; i < coords.length; i++) {                                                              // 94
      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true              // 95
    }                                                                                                      // 96
    if (!insideBox) return false                                                                           // 97
                                                                                                           // 98
    var insidePoly = false                                                                                 // 99
    for (var i = 0; i < coords.length; i++) {                                                              // 100
      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true                         // 101
    }                                                                                                      // 102
                                                                                                           // 103
    return insidePoly                                                                                      // 104
  }                                                                                                        // 105
                                                                                                           // 106
  gju.numberToRadius = function (number) {                                                                 // 107
    return number * Math.PI / 180;                                                                         // 108
  }                                                                                                        // 109
                                                                                                           // 110
  gju.numberToDegree = function (number) {                                                                 // 111
    return number * 180 / Math.PI;                                                                         // 112
  }                                                                                                        // 113
                                                                                                           // 114
  // written with help from @tautologe                                                                     // 115
  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {                                         // 116
    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],                                 // 117
      dist = (radiusInMeters / 1000) / 6371,                                                               // 118
      // convert meters to radiant                                                                         // 119
      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],                          // 120
      steps = steps || 15,                                                                                 // 121
      // 15 sided circle                                                                                   // 122
      poly = [[center[0], center[1]]];                                                                     // 123
    for (var i = 0; i < steps; i++) {                                                                      // 124
      var brng = 2 * Math.PI * i / steps;                                                                  // 125
      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)                                          // 126
              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));                                 // 127
      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),        // 128
                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));        // 129
      poly[i] = [];                                                                                        // 130
      poly[i][1] = gju.numberToDegree(lat);                                                                // 131
      poly[i][0] = gju.numberToDegree(lng);                                                                // 132
    }                                                                                                      // 133
    return {                                                                                               // 134
      "type": "Polygon",                                                                                   // 135
      "coordinates": [poly]                                                                                // 136
    };                                                                                                     // 137
  }                                                                                                        // 138
                                                                                                           // 139
  // assumes rectangle starts at lower left point                                                          // 140
  gju.rectangleCentroid = function (rectangle) {                                                           // 141
    var bbox = rectangle.coordinates[0];                                                                   // 142
    var xmin = bbox[0][0],                                                                                 // 143
      ymin = bbox[0][1],                                                                                   // 144
      xmax = bbox[2][0],                                                                                   // 145
      ymax = bbox[2][1];                                                                                   // 146
    var xwidth = xmax - xmin;                                                                              // 147
    var ywidth = ymax - ymin;                                                                              // 148
    return {                                                                                               // 149
      'type': 'Point',                                                                                     // 150
      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]                                                // 151
    };                                                                                                     // 152
  }                                                                                                        // 153
                                                                                                           // 154
  // from http://www.movable-type.co.uk/scripts/latlong.html                                               // 155
  gju.pointDistance = function (pt1, pt2) {                                                                // 156
    var lon1 = pt1.coordinates[0],                                                                         // 157
      lat1 = pt1.coordinates[1],                                                                           // 158
      lon2 = pt2.coordinates[0],                                                                           // 159
      lat2 = pt2.coordinates[1],                                                                           // 160
      dLat = gju.numberToRadius(lat2 - lat1),                                                              // 161
      dLon = gju.numberToRadius(lon2 - lon1),                                                              // 162
      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))                             // 163
        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),                            // 164
      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));                                                  // 165
    // Earth radius is 6371 km                                                                             // 166
    return (6371 * c) * 1000; // returns meters                                                            // 167
  },                                                                                                       // 168
                                                                                                           // 169
  // checks if geometry lies entirely within a circle                                                      // 170
  // works with Point, LineString, Polygon                                                                 // 171
  gju.geometryWithinRadius = function (geometry, center, radius) {                                         // 172
    if (geometry.type == 'Point') {                                                                        // 173
      return gju.pointDistance(geometry, center) <= radius;                                                // 174
    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {                              // 175
      var point = {};                                                                                      // 176
      var coordinates;                                                                                     // 177
      if (geometry.type == 'Polygon') {                                                                    // 178
        // it's enough to check the exterior ring of the Polygon                                           // 179
        coordinates = geometry.coordinates[0];                                                             // 180
      } else {                                                                                             // 181
        coordinates = geometry.coordinates;                                                                // 182
      }                                                                                                    // 183
      for (var i in coordinates) {                                                                         // 184
        point.coordinates = coordinates[i];                                                                // 185
        if (gju.pointDistance(point, center) > radius) {                                                   // 186
          return false;                                                                                    // 187
        }                                                                                                  // 188
      }                                                                                                    // 189
    }                                                                                                      // 190
    return true;                                                                                           // 191
  }                                                                                                        // 192
                                                                                                           // 193
  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt                                   // 194
  gju.area = function (polygon) {                                                                          // 195
    var area = 0;                                                                                          // 196
    // TODO: polygon holes at coordinates[1]                                                               // 197
    var points = polygon.coordinates[0];                                                                   // 198
    var j = points.length - 1;                                                                             // 199
    var p1, p2;                                                                                            // 200
                                                                                                           // 201
    for (var i = 0; i < points.length; j = i++) {                                                          // 202
      var p1 = {                                                                                           // 203
        x: points[i][1],                                                                                   // 204
        y: points[i][0]                                                                                    // 205
      };                                                                                                   // 206
      var p2 = {                                                                                           // 207
        x: points[j][1],                                                                                   // 208
        y: points[j][0]                                                                                    // 209
      };                                                                                                   // 210
      area += p1.x * p2.y;                                                                                 // 211
      area -= p1.y * p2.x;                                                                                 // 212
    }                                                                                                      // 213
                                                                                                           // 214
    area /= 2;                                                                                             // 215
    return area;                                                                                           // 216
  },                                                                                                       // 217
                                                                                                           // 218
  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt                                   // 219
  gju.centroid = function (polygon) {                                                                      // 220
    var f, x = 0,                                                                                          // 221
      y = 0;                                                                                               // 222
    // TODO: polygon holes at coordinates[1]                                                               // 223
    var points = polygon.coordinates[0];                                                                   // 224
    var j = points.length - 1;                                                                             // 225
    var p1, p2;                                                                                            // 226
                                                                                                           // 227
    for (var i = 0; i < points.length; j = i++) {                                                          // 228
      var p1 = {                                                                                           // 229
        x: points[i][1],                                                                                   // 230
        y: points[i][0]                                                                                    // 231
      };                                                                                                   // 232
      var p2 = {                                                                                           // 233
        x: points[j][1],                                                                                   // 234
        y: points[j][0]                                                                                    // 235
      };                                                                                                   // 236
      f = p1.x * p2.y - p2.x * p1.y;                                                                       // 237
      x += (p1.x + p2.x) * f;                                                                              // 238
      y += (p1.y + p2.y) * f;                                                                              // 239
    }                                                                                                      // 240
                                                                                                           // 241
    f = gju.area(polygon) * 6;                                                                             // 242
    return {                                                                                               // 243
      'type': 'Point',                                                                                     // 244
      'coordinates': [y / f, x / f]                                                                        // 245
    };                                                                                                     // 246
  },                                                                                                       // 247
                                                                                                           // 248
  gju.simplify = function (source, kink) { /* source[] array of geojson points */                          // 249
    /* kink	in metres, kinks above this depth kept  */                                                     // 250
    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */ // 251
    kink = kink || 20;                                                                                     // 252
    source = source.map(function (o) {                                                                     // 253
      return {                                                                                             // 254
        lng: o.coordinates[0],                                                                             // 255
        lat: o.coordinates[1]                                                                              // 256
      }                                                                                                    // 257
    });                                                                                                    // 258
                                                                                                           // 259
    var n_source, n_stack, n_dest, start, end, i, sig;                                                     // 260
    var dev_sqr, max_dev_sqr, band_sqr;                                                                    // 261
    var x12, y12, d12, x13, y13, d13, x23, y23, d23;                                                       // 262
    var F = (Math.PI / 180.0) * 0.5;                                                                       // 263
    var index = new Array(); /* aray of indexes of source points to include in the reduced line */         // 264
    var sig_start = new Array(); /* indices of start & end of working section */                           // 265
    var sig_end = new Array();                                                                             // 266
                                                                                                           // 267
    /* check for simple cases */                                                                           // 268
                                                                                                           // 269
    if (source.length < 3) return (source); /* one or two points */                                        // 270
                                                                                                           // 271
    /* more complex case. initialize stack */                                                              // 272
                                                                                                           // 273
    n_source = source.length;                                                                              // 274
    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */                            // 275
    band_sqr *= band_sqr;                                                                                  // 276
    n_dest = 0;                                                                                            // 277
    sig_start[0] = 0;                                                                                      // 278
    sig_end[0] = n_source - 1;                                                                             // 279
    n_stack = 1;                                                                                           // 280
                                                                                                           // 281
    /* while the stack is not empty  ... */                                                                // 282
    while (n_stack > 0) {                                                                                  // 283
                                                                                                           // 284
      /* ... pop the top-most entries off the stacks */                                                    // 285
                                                                                                           // 286
      start = sig_start[n_stack - 1];                                                                      // 287
      end = sig_end[n_stack - 1];                                                                          // 288
      n_stack--;                                                                                           // 289
                                                                                                           // 290
      if ((end - start) > 1) { /* any intermediate points ? */                                             // 291
                                                                                                           // 292
        /* ... yes, so find most deviant intermediate point to                                             // 293
        either side of line joining start & end points */                                                  // 294
                                                                                                           // 295
        x12 = (source[end].lng() - source[start].lng());                                                   // 296
        y12 = (source[end].lat() - source[start].lat());                                                   // 297
        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);                                            // 298
        x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */    // 299
        d12 = (x12 * x12) + (y12 * y12);                                                                   // 300
                                                                                                           // 301
        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {                               // 302
                                                                                                           // 303
          x13 = source[i].lng() - source[start].lng();                                                     // 304
          y13 = source[i].lat() - source[start].lat();                                                     // 305
          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);                                          // 306
          x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));                                    // 307
          d13 = (x13 * x13) + (y13 * y13);                                                                 // 308
                                                                                                           // 309
          x23 = source[i].lng() - source[end].lng();                                                       // 310
          y23 = source[i].lat() - source[end].lat();                                                       // 311
          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);                                          // 312
          x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));                                      // 313
          d23 = (x23 * x23) + (y23 * y23);                                                                 // 314
                                                                                                           // 315
          if (d13 >= (d12 + d23)) dev_sqr = d23;                                                           // 316
          else if (d23 >= (d12 + d13)) dev_sqr = d13;                                                      // 317
          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle        // 318
          if (dev_sqr > max_dev_sqr) {                                                                     // 319
            sig = i;                                                                                       // 320
            max_dev_sqr = dev_sqr;                                                                         // 321
          }                                                                                                // 322
        }                                                                                                  // 323
                                                                                                           // 324
        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */                           // 325
          /* ... no, so transfer current start point */                                                    // 326
          index[n_dest] = start;                                                                           // 327
          n_dest++;                                                                                        // 328
        } else { /* ... yes, so push two sub-sections on stack for further processing */                   // 329
          n_stack++;                                                                                       // 330
          sig_start[n_stack - 1] = sig;                                                                    // 331
          sig_end[n_stack - 1] = end;                                                                      // 332
          n_stack++;                                                                                       // 333
          sig_start[n_stack - 1] = start;                                                                  // 334
          sig_end[n_stack - 1] = sig;                                                                      // 335
        }                                                                                                  // 336
      } else { /* ... no intermediate points, so transfer current start point */                           // 337
        index[n_dest] = start;                                                                             // 338
        n_dest++;                                                                                          // 339
      }                                                                                                    // 340
    }                                                                                                      // 341
                                                                                                           // 342
    /* transfer last point */                                                                              // 343
    index[n_dest] = n_source - 1;                                                                          // 344
    n_dest++;                                                                                              // 345
                                                                                                           // 346
    /* make return array */                                                                                // 347
    var r = new Array();                                                                                   // 348
    for (var i = 0; i < n_dest; i++)                                                                       // 349
      r.push(source[index[i]]);                                                                            // 350
                                                                                                           // 351
    return r.map(function (o) {                                                                            // 352
      return {                                                                                             // 353
        type: "Point",                                                                                     // 354
        coordinates: [o.lng, o.lat]                                                                        // 355
      }                                                                                                    // 356
    });                                                                                                    // 357
  }                                                                                                        // 358
                                                                                                           // 359
  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint                                          // 360
  gju.destinationPoint = function (pt, brng, dist) {                                                       // 361
    dist = dist/6371;  // convert dist to angular distance in radians                                      // 362
    brng = gju.numberToRadius(brng);                                                                       // 363
                                                                                                           // 364
    var lat1 = gju.numberToRadius(pt.coordinates[0]);                                                      // 365
    var lon1 = gju.numberToRadius(pt.coordinates[1]);                                                      // 366
                                                                                                           // 367
    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +                                                  // 368
                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );                                  // 369
    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),                             // 370
                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));                            // 371
    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180Âº                          // 372
                                                                                                           // 373
    return {                                                                                               // 374
      'type': 'Point',                                                                                     // 375
      'coordinates': [gju.numberToDegree(lat2), gju.numberToDegree(lon2)]                                  // 376
    };                                                                                                     // 377
  };                                                                                                       // 378
                                                                                                           // 379
})();                                                                                                      // 380
                                                                                                           // 381
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                         //
// packages/geojson-utils/post.js                                                                          //
//                                                                                                         //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                           //
// This exports object was created in pre.js.  Now copy the `exports` object                               // 1
// from it into the package-scope variable `GeoJSON`, which will get exported.                             // 2
GeoJSON = module.exports;                                                                                  // 3
                                                                                                           // 4
                                                                                                           // 5
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['geojson-utils'] = {
  GeoJSON: GeoJSON
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var JSON = Package.json.JSON;
var EJSON = Package.ejson.EJSON;
var IdMap = Package['id-map'].IdMap;
var OrderedDict = Package['ordered-dict'].OrderedDict;
var Tracker = Package.tracker.Tracker;
var Deps = Package.tracker.Deps;
var Random = Package.random.Random;
var GeoJSON = Package['geojson-utils'].GeoJSON;

/* Package-scope variables */
var LocalCollection, Minimongo, MinimongoTest, MinimongoError, isArray, isPlainObject, isIndexable, isOperatorObject, isNumericKey, regexpElementMatcher, equalityElementMatcher, ELEMENT_OPERATORS, makeLookupFunction, expandArraysInBranches, projectionDetails, pathsToTree;

(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/minimongo.js                                                                           //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
// XXX type checking on selectors (graceful error if malformed)                                              // 1
                                                                                                             // 2
// LocalCollection: a set of documents that supports queries and modifiers.                                  // 3
                                                                                                             // 4
// Cursor: a specification for a particular subset of documents, w/                                          // 5
// a defined order, limit, and offset.  creating a Cursor with LocalCollection.find(),                       // 6
                                                                                                             // 7
// ObserveHandle: the return value of a live query.                                                          // 8
                                                                                                             // 9
LocalCollection = function (name) {                                                                          // 10
  var self = this;                                                                                           // 11
  self.name = name;                                                                                          // 12
  // _id -> document (also containing id)                                                                    // 13
  self._docs = new LocalCollection._IdMap;                                                                   // 14
                                                                                                             // 15
  self._observeQueue = new Meteor._SynchronousQueue();                                                       // 16
                                                                                                             // 17
  self.next_qid = 1; // live query id generator                                                              // 18
                                                                                                             // 19
  // qid -> live query object. keys:                                                                         // 20
  //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.                                 // 21
  //  results: array (ordered) or object (unordered) of current results                                      // 22
  //    (aliased with self._docs!)                                                                           // 23
  //  resultsSnapshot: snapshot of results. null if not paused.                                              // 24
  //  cursor: Cursor object for the query.                                                                   // 25
  //  selector, sorter, (callbacks): functions                                                               // 26
  self.queries = {};                                                                                         // 27
                                                                                                             // 28
  // null if not saving originals; an IdMap from id to original document value if                            // 29
  // saving originals. See comments before saveOriginals().                                                  // 30
  self._savedOriginals = null;                                                                               // 31
                                                                                                             // 32
  // True when observers are paused and we should not send callbacks.                                        // 33
  self.paused = false;                                                                                       // 34
};                                                                                                           // 35
                                                                                                             // 36
Minimongo = {};                                                                                              // 37
                                                                                                             // 38
// Object exported only for unit testing.                                                                    // 39
// Use it to export private functions to test in Tinytest.                                                   // 40
MinimongoTest = {};                                                                                          // 41
                                                                                                             // 42
LocalCollection._applyChanges = function (doc, changeFields) {                                               // 43
  _.each(changeFields, function (value, key) {                                                               // 44
    if (value === undefined)                                                                                 // 45
      delete doc[key];                                                                                       // 46
    else                                                                                                     // 47
      doc[key] = value;                                                                                      // 48
  });                                                                                                        // 49
};                                                                                                           // 50
                                                                                                             // 51
MinimongoError = function (message) {                                                                        // 52
  var e = new Error(message);                                                                                // 53
  e.name = "MinimongoError";                                                                                 // 54
  return e;                                                                                                  // 55
};                                                                                                           // 56
                                                                                                             // 57
                                                                                                             // 58
// options may include sort, skip, limit, reactive                                                           // 59
// sort may be any of these forms:                                                                           // 60
//     {a: 1, b: -1}                                                                                         // 61
//     [["a", "asc"], ["b", "desc"]]                                                                         // 62
//     ["a", ["b", "desc"]]                                                                                  // 63
//   (in the first form you're beholden to key enumeration order in                                          // 64
//   your javascript VM)                                                                                     // 65
//                                                                                                           // 66
// reactive: if given, and false, don't register with Tracker (default                                       // 67
// is true)                                                                                                  // 68
//                                                                                                           // 69
// XXX possibly should support retrieving a subset of fields? and                                            // 70
// have it be a hint (ignored on the client, when not copying the                                            // 71
// doc?)                                                                                                     // 72
//                                                                                                           // 73
// XXX sort does not yet support subkeys ('a.b') .. fix that!                                                // 74
// XXX add one more sort form: "key"                                                                         // 75
// XXX tests                                                                                                 // 76
LocalCollection.prototype.find = function (selector, options) {                                              // 77
  // default syntax for everything is to omit the selector argument.                                         // 78
  // but if selector is explicitly passed in as false or undefined, we                                       // 79
  // want a selector that matches nothing.                                                                   // 80
  if (arguments.length === 0)                                                                                // 81
    selector = {};                                                                                           // 82
                                                                                                             // 83
  return new LocalCollection.Cursor(this, selector, options);                                                // 84
};                                                                                                           // 85
                                                                                                             // 86
// don't call this ctor directly.  use LocalCollection.find().                                               // 87
                                                                                                             // 88
LocalCollection.Cursor = function (collection, selector, options) {                                          // 89
  var self = this;                                                                                           // 90
  if (!options) options = {};                                                                                // 91
                                                                                                             // 92
  self.collection = collection;                                                                              // 93
  self.sorter = null;                                                                                        // 94
                                                                                                             // 95
  if (LocalCollection._selectorIsId(selector)) {                                                             // 96
    // stash for fast path                                                                                   // 97
    self._selectorId = selector;                                                                             // 98
    self.matcher = new Minimongo.Matcher(selector);                                                          // 99
  } else {                                                                                                   // 100
    self._selectorId = undefined;                                                                            // 101
    self.matcher = new Minimongo.Matcher(selector);                                                          // 102
    if (self.matcher.hasGeoQuery() || options.sort) {                                                        // 103
      self.sorter = new Minimongo.Sorter(options.sort || [],                                                 // 104
                                         { matcher: self.matcher });                                         // 105
    }                                                                                                        // 106
  }                                                                                                          // 107
  self.skip = options.skip;                                                                                  // 108
  self.limit = options.limit;                                                                                // 109
  self.fields = options.fields;                                                                              // 110
                                                                                                             // 111
  self._projectionFn = LocalCollection._compileProjection(self.fields || {});                                // 112
                                                                                                             // 113
  self._transform = LocalCollection.wrapTransform(options.transform);                                        // 114
                                                                                                             // 115
  // by default, queries register w/ Tracker when it is available.                                           // 116
  if (typeof Tracker !== "undefined")                                                                        // 117
    self.reactive = (options.reactive === undefined) ? true : options.reactive;                              // 118
};                                                                                                           // 119
                                                                                                             // 120
// Since we don't actually have a "nextObject" interface, there's really no                                  // 121
// reason to have a "rewind" interface.  All it did was make multiple calls                                  // 122
// to fetch/map/forEach return nothing the second time.                                                      // 123
// XXX COMPAT WITH 0.8.1                                                                                     // 124
LocalCollection.Cursor.prototype.rewind = function () {                                                      // 125
};                                                                                                           // 126
                                                                                                             // 127
LocalCollection.prototype.findOne = function (selector, options) {                                           // 128
  if (arguments.length === 0)                                                                                // 129
    selector = {};                                                                                           // 130
                                                                                                             // 131
  // NOTE: by setting limit 1 here, we end up using very inefficient                                         // 132
  // code that recomputes the whole query on each update. The upside is                                      // 133
  // that when you reactively depend on a findOne you only get                                               // 134
  // invalidated when the found object changes, not any object in the                                        // 135
  // collection. Most findOne will be by id, which has a fast path, so                                       // 136
  // this might not be a big deal. In most cases, invalidation causes                                        // 137
  // the called to re-query anyway, so this should be a net performance                                      // 138
  // improvement.                                                                                            // 139
  options = options || {};                                                                                   // 140
  options.limit = 1;                                                                                         // 141
                                                                                                             // 142
  return this.find(selector, options).fetch()[0];                                                            // 143
};                                                                                                           // 144
                                                                                                             // 145
/**                                                                                                          // 146
 * @callback IterationCallback                                                                               // 147
 * @param {Object} doc                                                                                       // 148
 * @param {Number} index                                                                                     // 149
 */                                                                                                          // 150
/**                                                                                                          // 151
 * @summary Call `callback` once for each matching document, sequentially and synchronously.                 // 152
 * @locus Anywhere                                                                                           // 153
 * @method  forEach                                                                                          // 154
 * @instance                                                                                                 // 155
 * @memberOf Mongo.Cursor                                                                                    // 156
 * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.
 * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.                     // 158
 */                                                                                                          // 159
LocalCollection.Cursor.prototype.forEach = function (callback, thisArg) {                                    // 160
  var self = this;                                                                                           // 161
                                                                                                             // 162
  var objects = self._getRawObjects({ordered: true});                                                        // 163
                                                                                                             // 164
  if (self.reactive) {                                                                                       // 165
    self._depend({                                                                                           // 166
      addedBefore: true,                                                                                     // 167
      removed: true,                                                                                         // 168
      changed: true,                                                                                         // 169
      movedBefore: true});                                                                                   // 170
  }                                                                                                          // 171
                                                                                                             // 172
  _.each(objects, function (elt, i) {                                                                        // 173
    // This doubles as a clone operation.                                                                    // 174
    elt = self._projectionFn(elt);                                                                           // 175
                                                                                                             // 176
    if (self._transform)                                                                                     // 177
      elt = self._transform(elt);                                                                            // 178
    callback.call(thisArg, elt, i, self);                                                                    // 179
  });                                                                                                        // 180
};                                                                                                           // 181
                                                                                                             // 182
LocalCollection.Cursor.prototype.getTransform = function () {                                                // 183
  return this._transform;                                                                                    // 184
};                                                                                                           // 185
                                                                                                             // 186
/**                                                                                                          // 187
 * @summary Map callback over all matching documents.  Returns an Array.                                     // 188
 * @locus Anywhere                                                                                           // 189
 * @method map                                                                                               // 190
 * @instance                                                                                                 // 191
 * @memberOf Mongo.Cursor                                                                                    // 192
 * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.
 * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.                     // 194
 */                                                                                                          // 195
LocalCollection.Cursor.prototype.map = function (callback, thisArg) {                                        // 196
  var self = this;                                                                                           // 197
  var res = [];                                                                                              // 198
  self.forEach(function (doc, index) {                                                                       // 199
    res.push(callback.call(thisArg, doc, index, self));                                                      // 200
  });                                                                                                        // 201
  return res;                                                                                                // 202
};                                                                                                           // 203
                                                                                                             // 204
/**                                                                                                          // 205
 * @summary Return all matching documents as an Array.                                                       // 206
 * @memberOf Mongo.Cursor                                                                                    // 207
 * @method  fetch                                                                                            // 208
 * @instance                                                                                                 // 209
 * @locus Anywhere                                                                                           // 210
 * @returns {Object[]}                                                                                       // 211
 */                                                                                                          // 212
LocalCollection.Cursor.prototype.fetch = function () {                                                       // 213
  var self = this;                                                                                           // 214
  var res = [];                                                                                              // 215
  self.forEach(function (doc) {                                                                              // 216
    res.push(doc);                                                                                           // 217
  });                                                                                                        // 218
  return res;                                                                                                // 219
};                                                                                                           // 220
                                                                                                             // 221
/**                                                                                                          // 222
 * @summary Returns the number of documents that match a query.                                              // 223
 * @memberOf Mongo.Cursor                                                                                    // 224
 * @method  count                                                                                            // 225
 * @instance                                                                                                 // 226
 * @locus Anywhere                                                                                           // 227
 * @returns {Number}                                                                                         // 228
 */                                                                                                          // 229
LocalCollection.Cursor.prototype.count = function () {                                                       // 230
  var self = this;                                                                                           // 231
                                                                                                             // 232
  if (self.reactive)                                                                                         // 233
    self._depend({added: true, removed: true},                                                               // 234
                 true /* allow the observe to be unordered */);                                              // 235
                                                                                                             // 236
  return self._getRawObjects({ordered: true}).length;                                                        // 237
};                                                                                                           // 238
                                                                                                             // 239
LocalCollection.Cursor.prototype._publishCursor = function (sub) {                                           // 240
  var self = this;                                                                                           // 241
  if (! self.collection.name)                                                                                // 242
    throw new Error("Can't publish a cursor from a collection without a name.");                             // 243
  var collection = self.collection.name;                                                                     // 244
                                                                                                             // 245
  // XXX minimongo should not depend on mongo-livedata!                                                      // 246
  return Mongo.Collection._publishCursor(self, sub, collection);                                             // 247
};                                                                                                           // 248
                                                                                                             // 249
LocalCollection.Cursor.prototype._getCollectionName = function () {                                          // 250
  var self = this;                                                                                           // 251
  return self.collection.name;                                                                               // 252
};                                                                                                           // 253
                                                                                                             // 254
LocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {                                  // 255
  if (callbacks.added && callbacks.addedBefore)                                                              // 256
    throw new Error("Please specify only one of added() and addedBefore()");                                 // 257
  return !!(callbacks.addedBefore || callbacks.movedBefore);                                                 // 258
};                                                                                                           // 259
                                                                                                             // 260
LocalCollection._observeCallbacksAreOrdered = function (callbacks) {                                         // 261
  if (callbacks.addedAt && callbacks.added)                                                                  // 262
    throw new Error("Please specify only one of added() and addedAt()");                                     // 263
  if (callbacks.changedAt && callbacks.changed)                                                              // 264
    throw new Error("Please specify only one of changed() and changedAt()");                                 // 265
  if (callbacks.removed && callbacks.removedAt)                                                              // 266
    throw new Error("Please specify only one of removed() and removedAt()");                                 // 267
                                                                                                             // 268
  return !!(callbacks.addedAt || callbacks.movedTo || callbacks.changedAt                                    // 269
            || callbacks.removedAt);                                                                         // 270
};                                                                                                           // 271
                                                                                                             // 272
// the handle that comes back from observe.                                                                  // 273
LocalCollection.ObserveHandle = function () {};                                                              // 274
                                                                                                             // 275
// options to contain:                                                                                       // 276
//  * callbacks for observe():                                                                               // 277
//    - addedAt (document, atIndex)                                                                          // 278
//    - added (document)                                                                                     // 279
//    - changedAt (newDocument, oldDocument, atIndex)                                                        // 280
//    - changed (newDocument, oldDocument)                                                                   // 281
//    - removedAt (document, atIndex)                                                                        // 282
//    - removed (document)                                                                                   // 283
//    - movedTo (document, oldIndex, newIndex)                                                               // 284
//                                                                                                           // 285
// attributes available on returned query handle:                                                            // 286
//  * stop(): end updates                                                                                    // 287
//  * collection: the collection this query is querying                                                      // 288
//                                                                                                           // 289
// iff x is a returned query handle, (x instanceof                                                           // 290
// LocalCollection.ObserveHandle) is true                                                                    // 291
//                                                                                                           // 292
// initial results delivered through added callback                                                          // 293
// XXX maybe callbacks should take a list of objects, to expose transactions?                                // 294
// XXX maybe support field limiting (to limit what you're notified on)                                       // 295
                                                                                                             // 296
_.extend(LocalCollection.Cursor.prototype, {                                                                 // 297
  /**                                                                                                        // 298
   * @summary Watch a query.  Receive callbacks as the result set changes.                                   // 299
   * @locus Anywhere                                                                                         // 300
   * @memberOf Mongo.Cursor                                                                                  // 301
   * @instance                                                                                               // 302
   * @param {Object} callbacks Functions to call to deliver the result set as it changes                     // 303
   */                                                                                                        // 304
  observe: function (options) {                                                                              // 305
    var self = this;                                                                                         // 306
    return LocalCollection._observeFromObserveChanges(self, options);                                        // 307
  },                                                                                                         // 308
                                                                                                             // 309
  /**                                                                                                        // 310
   * @summary Watch a query.  Receive callbacks as the result set changes.  Only the differences between the old and new documents are passed to the callbacks.
   * @locus Anywhere                                                                                         // 312
   * @memberOf Mongo.Cursor                                                                                  // 313
   * @instance                                                                                               // 314
   * @param {Object} callbacks Functions to call to deliver the result set as it changes                     // 315
   */                                                                                                        // 316
  observeChanges: function (options) {                                                                       // 317
    var self = this;                                                                                         // 318
                                                                                                             // 319
    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);                               // 320
                                                                                                             // 321
    // there are several places that assume you aren't combining skip/limit with                             // 322
    // unordered observe.  eg, update's EJSON.clone, and the "there are several"                             // 323
    // comment in _modifyAndNotify                                                                           // 324
    // XXX allow skip/limit with unordered observe                                                           // 325
    if (!options._allow_unordered && !ordered && (self.skip || self.limit))                                  // 326
      throw new Error("must use ordered observe (ie, 'addedBefore' instead of 'added') with skip or limit"); // 327
                                                                                                             // 328
    if (self.fields && (self.fields._id === 0 || self.fields._id === false))                                 // 329
      throw Error("You may not observe a cursor with {fields: {_id: 0}}");                                   // 330
                                                                                                             // 331
    var query = {                                                                                            // 332
      matcher: self.matcher, // not fast pathed                                                              // 333
      sorter: ordered && self.sorter,                                                                        // 334
      distances: (                                                                                           // 335
        self.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap),                                // 336
      resultsSnapshot: null,                                                                                 // 337
      ordered: ordered,                                                                                      // 338
      cursor: self,                                                                                          // 339
      projectionFn: self._projectionFn                                                                       // 340
    };                                                                                                       // 341
    var qid;                                                                                                 // 342
                                                                                                             // 343
    // Non-reactive queries call added[Before] and then never call anything                                  // 344
    // else.                                                                                                 // 345
    if (self.reactive) {                                                                                     // 346
      qid = self.collection.next_qid++;                                                                      // 347
      self.collection.queries[qid] = query;                                                                  // 348
    }                                                                                                        // 349
    query.results = self._getRawObjects({                                                                    // 350
      ordered: ordered, distances: query.distances});                                                        // 351
    if (self.collection.paused)                                                                              // 352
      query.resultsSnapshot = (ordered ? [] : new LocalCollection._IdMap);                                   // 353
                                                                                                             // 354
    // wrap callbacks we were passed. callbacks only fire when not paused and                                // 355
    // are never undefined                                                                                   // 356
    // Filters out blacklisted fields according to cursor's projection.                                      // 357
    // XXX wrong place for this?                                                                             // 358
                                                                                                             // 359
    // furthermore, callbacks enqueue until the operation we're working on is                                // 360
    // done.                                                                                                 // 361
    var wrapCallback = function (f) {                                                                        // 362
      if (!f)                                                                                                // 363
        return function () {};                                                                               // 364
      return function (/*args*/) {                                                                           // 365
        var context = this;                                                                                  // 366
        var args = arguments;                                                                                // 367
                                                                                                             // 368
        if (self.collection.paused)                                                                          // 369
          return;                                                                                            // 370
                                                                                                             // 371
        self.collection._observeQueue.queueTask(function () {                                                // 372
          f.apply(context, args);                                                                            // 373
        });                                                                                                  // 374
      };                                                                                                     // 375
    };                                                                                                       // 376
    query.added = wrapCallback(options.added);                                                               // 377
    query.changed = wrapCallback(options.changed);                                                           // 378
    query.removed = wrapCallback(options.removed);                                                           // 379
    if (ordered) {                                                                                           // 380
      query.addedBefore = wrapCallback(options.addedBefore);                                                 // 381
      query.movedBefore = wrapCallback(options.movedBefore);                                                 // 382
    }                                                                                                        // 383
                                                                                                             // 384
    if (!options._suppress_initial && !self.collection.paused) {                                             // 385
      // XXX unify ordered and unordered interface                                                           // 386
      var each = ordered                                                                                     // 387
            ? _.bind(_.each, null, query.results)                                                            // 388
            : _.bind(query.results.forEach, query.results);                                                  // 389
      each(function (doc) {                                                                                  // 390
        var fields = EJSON.clone(doc);                                                                       // 391
                                                                                                             // 392
        delete fields._id;                                                                                   // 393
        if (ordered)                                                                                         // 394
          query.addedBefore(doc._id, self._projectionFn(fields), null);                                      // 395
        query.added(doc._id, self._projectionFn(fields));                                                    // 396
      });                                                                                                    // 397
    }                                                                                                        // 398
                                                                                                             // 399
    var handle = new LocalCollection.ObserveHandle;                                                          // 400
    _.extend(handle, {                                                                                       // 401
      collection: self.collection,                                                                           // 402
      stop: function () {                                                                                    // 403
        if (self.reactive)                                                                                   // 404
          delete self.collection.queries[qid];                                                               // 405
      }                                                                                                      // 406
    });                                                                                                      // 407
                                                                                                             // 408
    if (self.reactive && Tracker.active) {                                                                   // 409
      // XXX in many cases, the same observe will be recreated when                                          // 410
      // the current autorun is rerun.  we could save work by                                                // 411
      // letting it linger across rerun and potentially get                                                  // 412
      // repurposed if the same observe is performed, using logic                                            // 413
      // similar to that of Meteor.subscribe.                                                                // 414
      Tracker.onInvalidate(function () {                                                                     // 415
        handle.stop();                                                                                       // 416
      });                                                                                                    // 417
    }                                                                                                        // 418
    // run the observe callbacks resulting from the initial contents                                         // 419
    // before we leave the observe.                                                                          // 420
    self.collection._observeQueue.drain();                                                                   // 421
                                                                                                             // 422
    return handle;                                                                                           // 423
  }                                                                                                          // 424
});                                                                                                          // 425
                                                                                                             // 426
// Returns a collection of matching objects, but doesn't deep copy them.                                     // 427
//                                                                                                           // 428
// If ordered is set, returns a sorted array, respecting sorter, skip, and limit                             // 429
// properties of the query.  if sorter is falsey, no sort -- you get the natural                             // 430
// order.                                                                                                    // 431
//                                                                                                           // 432
// If ordered is not set, returns an object mapping from ID to doc (sorter, skip                             // 433
// and limit should not be set).                                                                             // 434
//                                                                                                           // 435
// If ordered is set and this cursor is a $near geoquery, then this function                                 // 436
// will use an _IdMap to track each distance from the $near argument point in                                // 437
// order to use it as a sort key. If an _IdMap is passed in the 'distances'                                  // 438
// argument, this function will clear it and use it for this purpose (otherwise                              // 439
// it will just create its own _IdMap). The observeChanges implementation uses                               // 440
// this to remember the distances after this function returns.                                               // 441
LocalCollection.Cursor.prototype._getRawObjects = function (options) {                                       // 442
  var self = this;                                                                                           // 443
  options = options || {};                                                                                   // 444
                                                                                                             // 445
  // XXX use OrderedDict instead of array, and make IdMap and OrderedDict                                    // 446
  // compatible                                                                                              // 447
  var results = options.ordered ? [] : new LocalCollection._IdMap;                                           // 448
                                                                                                             // 449
  // fast path for single ID value                                                                           // 450
  if (self._selectorId !== undefined) {                                                                      // 451
    // If you have non-zero skip and ask for a single id, you get                                            // 452
    // nothing. This is so it matches the behavior of the '{_id: foo}'                                       // 453
    // path.                                                                                                 // 454
    if (self.skip)                                                                                           // 455
      return results;                                                                                        // 456
                                                                                                             // 457
    var selectedDoc = self.collection._docs.get(self._selectorId);                                           // 458
    if (selectedDoc) {                                                                                       // 459
      if (options.ordered)                                                                                   // 460
        results.push(selectedDoc);                                                                           // 461
      else                                                                                                   // 462
        results.set(self._selectorId, selectedDoc);                                                          // 463
    }                                                                                                        // 464
    return results;                                                                                          // 465
  }                                                                                                          // 466
                                                                                                             // 467
  // slow path for arbitrary selector, sort, skip, limit                                                     // 468
                                                                                                             // 469
  // in the observeChanges case, distances is actually part of the "query" (ie,                              // 470
  // live results set) object.  in other cases, distances is only used inside                                // 471
  // this function.                                                                                          // 472
  var distances;                                                                                             // 473
  if (self.matcher.hasGeoQuery() && options.ordered) {                                                       // 474
    if (options.distances) {                                                                                 // 475
      distances = options.distances;                                                                         // 476
      distances.clear();                                                                                     // 477
    } else {                                                                                                 // 478
      distances = new LocalCollection._IdMap();                                                              // 479
    }                                                                                                        // 480
  }                                                                                                          // 481
                                                                                                             // 482
  self.collection._docs.forEach(function (doc, id) {                                                         // 483
    var matchResult = self.matcher.documentMatches(doc);                                                     // 484
    if (matchResult.result) {                                                                                // 485
      if (options.ordered) {                                                                                 // 486
        results.push(doc);                                                                                   // 487
        if (distances && matchResult.distance !== undefined)                                                 // 488
          distances.set(id, matchResult.distance);                                                           // 489
      } else {                                                                                               // 490
        results.set(id, doc);                                                                                // 491
      }                                                                                                      // 492
    }                                                                                                        // 493
    // Fast path for limited unsorted queries.                                                               // 494
    // XXX 'length' check here seems wrong for ordered                                                       // 495
    if (self.limit && !self.skip && !self.sorter &&                                                          // 496
        results.length === self.limit)                                                                       // 497
      return false;  // break                                                                                // 498
    return true;  // continue                                                                                // 499
  });                                                                                                        // 500
                                                                                                             // 501
  if (!options.ordered)                                                                                      // 502
    return results;                                                                                          // 503
                                                                                                             // 504
  if (self.sorter) {                                                                                         // 505
    var comparator = self.sorter.getComparator({distances: distances});                                      // 506
    results.sort(comparator);                                                                                // 507
  }                                                                                                          // 508
                                                                                                             // 509
  var idx_start = self.skip || 0;                                                                            // 510
  var idx_end = self.limit ? (self.limit + idx_start) : results.length;                                      // 511
  return results.slice(idx_start, idx_end);                                                                  // 512
};                                                                                                           // 513
                                                                                                             // 514
// XXX Maybe we need a version of observe that just calls a callback if                                      // 515
// anything changed.                                                                                         // 516
LocalCollection.Cursor.prototype._depend = function (changers, _allow_unordered) {                           // 517
  var self = this;                                                                                           // 518
                                                                                                             // 519
  if (Tracker.active) {                                                                                      // 520
    var v = new Tracker.Dependency;                                                                          // 521
    v.depend();                                                                                              // 522
    var notifyChange = _.bind(v.changed, v);                                                                 // 523
                                                                                                             // 524
    var options = {                                                                                          // 525
      _suppress_initial: true,                                                                               // 526
      _allow_unordered: _allow_unordered                                                                     // 527
    };                                                                                                       // 528
    _.each(['added', 'changed', 'removed', 'addedBefore', 'movedBefore'],                                    // 529
           function (fnName) {                                                                               // 530
             if (changers[fnName])                                                                           // 531
               options[fnName] = notifyChange;                                                               // 532
           });                                                                                               // 533
                                                                                                             // 534
    // observeChanges will stop() when this computation is invalidated                                       // 535
    self.observeChanges(options);                                                                            // 536
  }                                                                                                          // 537
};                                                                                                           // 538
                                                                                                             // 539
// XXX enforce rule that field names can't start with '$' or contain '.'                                     // 540
// (real mongodb does in fact enforce this)                                                                  // 541
// XXX possibly enforce that 'undefined' does not appear (we assume                                          // 542
// this in our handling of null and $exists)                                                                 // 543
LocalCollection.prototype.insert = function (doc, callback) {                                                // 544
  var self = this;                                                                                           // 545
  doc = EJSON.clone(doc);                                                                                    // 546
                                                                                                             // 547
  if (!_.has(doc, '_id')) {                                                                                  // 548
    // if you really want to use ObjectIDs, set this global.                                                 // 549
    // Mongo.Collection specifies its own ids and does not use this code.                                    // 550
    doc._id = LocalCollection._useOID ? new LocalCollection._ObjectID()                                      // 551
                                      : Random.id();                                                         // 552
  }                                                                                                          // 553
  var id = doc._id;                                                                                          // 554
                                                                                                             // 555
  if (self._docs.has(id))                                                                                    // 556
    throw MinimongoError("Duplicate _id '" + id + "'");                                                      // 557
                                                                                                             // 558
  self._saveOriginal(id, undefined);                                                                         // 559
  self._docs.set(id, doc);                                                                                   // 560
                                                                                                             // 561
  var queriesToRecompute = [];                                                                               // 562
  // trigger live queries that match                                                                         // 563
  for (var qid in self.queries) {                                                                            // 564
    var query = self.queries[qid];                                                                           // 565
    var matchResult = query.matcher.documentMatches(doc);                                                    // 566
    if (matchResult.result) {                                                                                // 567
      if (query.distances && matchResult.distance !== undefined)                                             // 568
        query.distances.set(id, matchResult.distance);                                                       // 569
      if (query.cursor.skip || query.cursor.limit)                                                           // 570
        queriesToRecompute.push(qid);                                                                        // 571
      else                                                                                                   // 572
        LocalCollection._insertInResults(query, doc);                                                        // 573
    }                                                                                                        // 574
  }                                                                                                          // 575
                                                                                                             // 576
  _.each(queriesToRecompute, function (qid) {                                                                // 577
    if (self.queries[qid])                                                                                   // 578
      self._recomputeResults(self.queries[qid]);                                                             // 579
  });                                                                                                        // 580
  self._observeQueue.drain();                                                                                // 581
                                                                                                             // 582
  // Defer because the caller likely doesn't expect the callback to be run                                   // 583
  // immediately.                                                                                            // 584
  if (callback)                                                                                              // 585
    Meteor.defer(function () {                                                                               // 586
      callback(null, id);                                                                                    // 587
    });                                                                                                      // 588
  return id;                                                                                                 // 589
};                                                                                                           // 590
                                                                                                             // 591
// Iterates over a subset of documents that could match selector; calls                                      // 592
// f(doc, id) on each of them.  Specifically, if selector specifies                                          // 593
// specific _id's, it only looks at those.  doc is *not* cloned: it is the                                   // 594
// same object that is in _docs.                                                                             // 595
LocalCollection.prototype._eachPossiblyMatchingDoc = function (selector, f) {                                // 596
  var self = this;                                                                                           // 597
  var specificIds = LocalCollection._idsMatchedBySelector(selector);                                         // 598
  if (specificIds) {                                                                                         // 599
    for (var i = 0; i < specificIds.length; ++i) {                                                           // 600
      var id = specificIds[i];                                                                               // 601
      var doc = self._docs.get(id);                                                                          // 602
      if (doc) {                                                                                             // 603
        var breakIfFalse = f(doc, id);                                                                       // 604
        if (breakIfFalse === false)                                                                          // 605
          break;                                                                                             // 606
      }                                                                                                      // 607
    }                                                                                                        // 608
  } else {                                                                                                   // 609
    self._docs.forEach(f);                                                                                   // 610
  }                                                                                                          // 611
};                                                                                                           // 612
                                                                                                             // 613
LocalCollection.prototype.remove = function (selector, callback) {                                           // 614
  var self = this;                                                                                           // 615
                                                                                                             // 616
  // Easy special case: if we're not calling observeChanges callbacks and we're                              // 617
  // not saving originals and we got asked to remove everything, then just empty                             // 618
  // everything directly.                                                                                    // 619
  if (self.paused && !self._savedOriginals && EJSON.equals(selector, {})) {                                  // 620
    var result = self._docs.size();                                                                          // 621
    self._docs.clear();                                                                                      // 622
    _.each(self.queries, function (query) {                                                                  // 623
      if (query.ordered) {                                                                                   // 624
        query.results = [];                                                                                  // 625
      } else {                                                                                               // 626
        query.results.clear();                                                                               // 627
      }                                                                                                      // 628
    });                                                                                                      // 629
    if (callback) {                                                                                          // 630
      Meteor.defer(function () {                                                                             // 631
        callback(null, result);                                                                              // 632
      });                                                                                                    // 633
    }                                                                                                        // 634
    return result;                                                                                           // 635
  }                                                                                                          // 636
                                                                                                             // 637
  var matcher = new Minimongo.Matcher(selector);                                                             // 638
  var remove = [];                                                                                           // 639
  self._eachPossiblyMatchingDoc(selector, function (doc, id) {                                               // 640
    if (matcher.documentMatches(doc).result)                                                                 // 641
      remove.push(id);                                                                                       // 642
  });                                                                                                        // 643
                                                                                                             // 644
  var queriesToRecompute = [];                                                                               // 645
  var queryRemove = [];                                                                                      // 646
  for (var i = 0; i < remove.length; i++) {                                                                  // 647
    var removeId = remove[i];                                                                                // 648
    var removeDoc = self._docs.get(removeId);                                                                // 649
    _.each(self.queries, function (query, qid) {                                                             // 650
      if (query.matcher.documentMatches(removeDoc).result) {                                                 // 651
        if (query.cursor.skip || query.cursor.limit)                                                         // 652
          queriesToRecompute.push(qid);                                                                      // 653
        else                                                                                                 // 654
          queryRemove.push({qid: qid, doc: removeDoc});                                                      // 655
      }                                                                                                      // 656
    });                                                                                                      // 657
    self._saveOriginal(removeId, removeDoc);                                                                 // 658
    self._docs.remove(removeId);                                                                             // 659
  }                                                                                                          // 660
                                                                                                             // 661
  // run live query callbacks _after_ we've removed the documents.                                           // 662
  _.each(queryRemove, function (remove) {                                                                    // 663
    var query = self.queries[remove.qid];                                                                    // 664
    if (query) {                                                                                             // 665
      query.distances && query.distances.remove(remove.doc._id);                                             // 666
      LocalCollection._removeFromResults(query, remove.doc);                                                 // 667
    }                                                                                                        // 668
  });                                                                                                        // 669
  _.each(queriesToRecompute, function (qid) {                                                                // 670
    var query = self.queries[qid];                                                                           // 671
    if (query)                                                                                               // 672
      self._recomputeResults(query);                                                                         // 673
  });                                                                                                        // 674
  self._observeQueue.drain();                                                                                // 675
  result = remove.length;                                                                                    // 676
  if (callback)                                                                                              // 677
    Meteor.defer(function () {                                                                               // 678
      callback(null, result);                                                                                // 679
    });                                                                                                      // 680
  return result;                                                                                             // 681
};                                                                                                           // 682
                                                                                                             // 683
// XXX atomicity: if multi is true, and one modification fails, do                                           // 684
// we rollback the whole operation, or what?                                                                 // 685
LocalCollection.prototype.update = function (selector, mod, options, callback) {                             // 686
  var self = this;                                                                                           // 687
  if (! callback && options instanceof Function) {                                                           // 688
    callback = options;                                                                                      // 689
    options = null;                                                                                          // 690
  }                                                                                                          // 691
  if (!options) options = {};                                                                                // 692
                                                                                                             // 693
  var matcher = new Minimongo.Matcher(selector);                                                             // 694
                                                                                                             // 695
  // Save the original results of any query that we might need to                                            // 696
  // _recomputeResults on, because _modifyAndNotify will mutate the objects in                               // 697
  // it. (We don't need to save the original results of paused queries because                               // 698
  // they already have a resultsSnapshot and we won't be diffing in                                          // 699
  // _recomputeResults.)                                                                                     // 700
  var qidToOriginalResults = {};                                                                             // 701
  _.each(self.queries, function (query, qid) {                                                               // 702
    // XXX for now, skip/limit implies ordered observe, so query.results is                                  // 703
    // always an array                                                                                       // 704
    if ((query.cursor.skip || query.cursor.limit) && ! self.paused)                                          // 705
      qidToOriginalResults[qid] = EJSON.clone(query.results);                                                // 706
  });                                                                                                        // 707
  var recomputeQids = {};                                                                                    // 708
                                                                                                             // 709
  var updateCount = 0;                                                                                       // 710
                                                                                                             // 711
  self._eachPossiblyMatchingDoc(selector, function (doc, id) {                                               // 712
    var queryResult = matcher.documentMatches(doc);                                                          // 713
    if (queryResult.result) {                                                                                // 714
      // XXX Should we save the original even if mod ends up being a no-op?                                  // 715
      self._saveOriginal(id, doc);                                                                           // 716
      self._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);                              // 717
      ++updateCount;                                                                                         // 718
      if (!options.multi)                                                                                    // 719
        return false;  // break                                                                              // 720
    }                                                                                                        // 721
    return true;                                                                                             // 722
  });                                                                                                        // 723
                                                                                                             // 724
  _.each(recomputeQids, function (dummy, qid) {                                                              // 725
    var query = self.queries[qid];                                                                           // 726
    if (query)                                                                                               // 727
      self._recomputeResults(query, qidToOriginalResults[qid]);                                              // 728
  });                                                                                                        // 729
  self._observeQueue.drain();                                                                                // 730
                                                                                                             // 731
  // If we are doing an upsert, and we didn't modify any documents yet, then                                 // 732
  // it's time to do an insert. Figure out what document we are inserting, and                               // 733
  // generate an id for it.                                                                                  // 734
  var insertedId;                                                                                            // 735
  if (updateCount === 0 && options.upsert) {                                                                 // 736
    var newDoc = LocalCollection._removeDollarOperators(selector);                                           // 737
    LocalCollection._modify(newDoc, mod, {isInsert: true});                                                  // 738
    if (! newDoc._id && options.insertedId)                                                                  // 739
      newDoc._id = options.insertedId;                                                                       // 740
    insertedId = self.insert(newDoc);                                                                        // 741
    updateCount = 1;                                                                                         // 742
  }                                                                                                          // 743
                                                                                                             // 744
  // Return the number of affected documents, or in the upsert case, an object                               // 745
  // containing the number of affected docs and the id of the doc that was                                   // 746
  // inserted, if any.                                                                                       // 747
  var result;                                                                                                // 748
  if (options._returnObject) {                                                                               // 749
    result = {                                                                                               // 750
      numberAffected: updateCount                                                                            // 751
    };                                                                                                       // 752
    if (insertedId !== undefined)                                                                            // 753
      result.insertedId = insertedId;                                                                        // 754
  } else {                                                                                                   // 755
    result = updateCount;                                                                                    // 756
  }                                                                                                          // 757
                                                                                                             // 758
  if (callback)                                                                                              // 759
    Meteor.defer(function () {                                                                               // 760
      callback(null, result);                                                                                // 761
    });                                                                                                      // 762
  return result;                                                                                             // 763
};                                                                                                           // 764
                                                                                                             // 765
// A convenience wrapper on update. LocalCollection.upsert(sel, mod) is                                      // 766
// equivalent to LocalCollection.update(sel, mod, { upsert: true, _returnObject:                             // 767
// true }).                                                                                                  // 768
LocalCollection.prototype.upsert = function (selector, mod, options, callback) {                             // 769
  var self = this;                                                                                           // 770
  if (! callback && typeof options === "function") {                                                         // 771
    callback = options;                                                                                      // 772
    options = {};                                                                                            // 773
  }                                                                                                          // 774
  return self.update(selector, mod, _.extend({}, options, {                                                  // 775
    upsert: true,                                                                                            // 776
    _returnObject: true                                                                                      // 777
  }), callback);                                                                                             // 778
};                                                                                                           // 779
                                                                                                             // 780
LocalCollection.prototype._modifyAndNotify = function (                                                      // 781
    doc, mod, recomputeQids, arrayIndices) {                                                                 // 782
  var self = this;                                                                                           // 783
                                                                                                             // 784
  var matched_before = {};                                                                                   // 785
  for (var qid in self.queries) {                                                                            // 786
    var query = self.queries[qid];                                                                           // 787
    if (query.ordered) {                                                                                     // 788
      matched_before[qid] = query.matcher.documentMatches(doc).result;                                       // 789
    } else {                                                                                                 // 790
      // Because we don't support skip or limit (yet) in unordered queries, we                               // 791
      // can just do a direct lookup.                                                                        // 792
      matched_before[qid] = query.results.has(doc._id);                                                      // 793
    }                                                                                                        // 794
  }                                                                                                          // 795
                                                                                                             // 796
  var old_doc = EJSON.clone(doc);                                                                            // 797
                                                                                                             // 798
  LocalCollection._modify(doc, mod, {arrayIndices: arrayIndices});                                           // 799
                                                                                                             // 800
  for (qid in self.queries) {                                                                                // 801
    query = self.queries[qid];                                                                               // 802
    var before = matched_before[qid];                                                                        // 803
    var afterMatch = query.matcher.documentMatches(doc);                                                     // 804
    var after = afterMatch.result;                                                                           // 805
    if (after && query.distances && afterMatch.distance !== undefined)                                       // 806
      query.distances.set(doc._id, afterMatch.distance);                                                     // 807
                                                                                                             // 808
    if (query.cursor.skip || query.cursor.limit) {                                                           // 809
      // We need to recompute any query where the doc may have been in the                                   // 810
      // cursor's window either before or after the update. (Note that if skip                               // 811
      // or limit is set, "before" and "after" being true do not necessarily                                 // 812
      // mean that the document is in the cursor's output after skip/limit is                                // 813
      // applied... but if they are false, then the document definitely is NOT                               // 814
      // in the output. So it's safe to skip recompute if neither before or                                  // 815
      // after are true.)                                                                                    // 816
      if (before || after)                                                                                   // 817
        recomputeQids[qid] = true;                                                                           // 818
    } else if (before && !after) {                                                                           // 819
      LocalCollection._removeFromResults(query, doc);                                                        // 820
    } else if (!before && after) {                                                                           // 821
      LocalCollection._insertInResults(query, doc);                                                          // 822
    } else if (before && after) {                                                                            // 823
      LocalCollection._updateInResults(query, doc, old_doc);                                                 // 824
    }                                                                                                        // 825
  }                                                                                                          // 826
};                                                                                                           // 827
                                                                                                             // 828
// XXX the sorted-query logic below is laughably inefficient. we'll                                          // 829
// need to come up with a better datastructure for this.                                                     // 830
//                                                                                                           // 831
// XXX the logic for observing with a skip or a limit is even more                                           // 832
// laughably inefficient. we recompute the whole results every time!                                         // 833
                                                                                                             // 834
LocalCollection._insertInResults = function (query, doc) {                                                   // 835
  var fields = EJSON.clone(doc);                                                                             // 836
  delete fields._id;                                                                                         // 837
  if (query.ordered) {                                                                                       // 838
    if (!query.sorter) {                                                                                     // 839
      query.addedBefore(doc._id, query.projectionFn(fields), null);                                          // 840
      query.results.push(doc);                                                                               // 841
    } else {                                                                                                 // 842
      var i = LocalCollection._insertInSortedList(                                                           // 843
        query.sorter.getComparator({distances: query.distances}),                                            // 844
        query.results, doc);                                                                                 // 845
      var next = query.results[i+1];                                                                         // 846
      if (next)                                                                                              // 847
        next = next._id;                                                                                     // 848
      else                                                                                                   // 849
        next = null;                                                                                         // 850
      query.addedBefore(doc._id, query.projectionFn(fields), next);                                          // 851
    }                                                                                                        // 852
    query.added(doc._id, query.projectionFn(fields));                                                        // 853
  } else {                                                                                                   // 854
    query.added(doc._id, query.projectionFn(fields));                                                        // 855
    query.results.set(doc._id, doc);                                                                         // 856
  }                                                                                                          // 857
};                                                                                                           // 858
                                                                                                             // 859
LocalCollection._removeFromResults = function (query, doc) {                                                 // 860
  if (query.ordered) {                                                                                       // 861
    var i = LocalCollection._findInOrderedResults(query, doc);                                               // 862
    query.removed(doc._id);                                                                                  // 863
    query.results.splice(i, 1);                                                                              // 864
  } else {                                                                                                   // 865
    var id = doc._id;  // in case callback mutates doc                                                       // 866
    query.removed(doc._id);                                                                                  // 867
    query.results.remove(id);                                                                                // 868
  }                                                                                                          // 869
};                                                                                                           // 870
                                                                                                             // 871
LocalCollection._updateInResults = function (query, doc, old_doc) {                                          // 872
  if (!EJSON.equals(doc._id, old_doc._id))                                                                   // 873
    throw new Error("Can't change a doc's _id while updating");                                              // 874
  var projectionFn = query.projectionFn;                                                                     // 875
  var changedFields = LocalCollection._makeChangedFields(                                                    // 876
    projectionFn(doc), projectionFn(old_doc));                                                               // 877
                                                                                                             // 878
  if (!query.ordered) {                                                                                      // 879
    if (!_.isEmpty(changedFields)) {                                                                         // 880
      query.changed(doc._id, changedFields);                                                                 // 881
      query.results.set(doc._id, doc);                                                                       // 882
    }                                                                                                        // 883
    return;                                                                                                  // 884
  }                                                                                                          // 885
                                                                                                             // 886
  var orig_idx = LocalCollection._findInOrderedResults(query, doc);                                          // 887
                                                                                                             // 888
  if (!_.isEmpty(changedFields))                                                                             // 889
    query.changed(doc._id, changedFields);                                                                   // 890
  if (!query.sorter)                                                                                         // 891
    return;                                                                                                  // 892
                                                                                                             // 893
  // just take it out and put it back in again, and see if the index                                         // 894
  // changes                                                                                                 // 895
  query.results.splice(orig_idx, 1);                                                                         // 896
  var new_idx = LocalCollection._insertInSortedList(                                                         // 897
    query.sorter.getComparator({distances: query.distances}),                                                // 898
    query.results, doc);                                                                                     // 899
  if (orig_idx !== new_idx) {                                                                                // 900
    var next = query.results[new_idx+1];                                                                     // 901
    if (next)                                                                                                // 902
      next = next._id;                                                                                       // 903
    else                                                                                                     // 904
      next = null;                                                                                           // 905
    query.movedBefore && query.movedBefore(doc._id, next);                                                   // 906
  }                                                                                                          // 907
};                                                                                                           // 908
                                                                                                             // 909
// Recomputes the results of a query and runs observe callbacks for the                                      // 910
// difference between the previous results and the current results (unless                                   // 911
// paused). Used for skip/limit queries.                                                                     // 912
//                                                                                                           // 913
// When this is used by insert or remove, it can just use query.results for the                              // 914
// old results (and there's no need to pass in oldResults), because these                                    // 915
// operations don't mutate the documents in the collection. Update needs to pass                             // 916
// in an oldResults which was deep-copied before the modifier was applied.                                   // 917
//                                                                                                           // 918
// oldResults is guaranteed to be ignored if the query is not paused.                                        // 919
LocalCollection.prototype._recomputeResults = function (query, oldResults) {                                 // 920
  var self = this;                                                                                           // 921
  if (! self.paused && ! oldResults)                                                                         // 922
    oldResults = query.results;                                                                              // 923
  if (query.distances)                                                                                       // 924
    query.distances.clear();                                                                                 // 925
  query.results = query.cursor._getRawObjects({                                                              // 926
    ordered: query.ordered, distances: query.distances});                                                    // 927
                                                                                                             // 928
  if (! self.paused) {                                                                                       // 929
    LocalCollection._diffQueryChanges(                                                                       // 930
      query.ordered, oldResults, query.results, query,                                                       // 931
      { projectionFn: query.projectionFn });                                                                 // 932
  }                                                                                                          // 933
};                                                                                                           // 934
                                                                                                             // 935
                                                                                                             // 936
LocalCollection._findInOrderedResults = function (query, doc) {                                              // 937
  if (!query.ordered)                                                                                        // 938
    throw new Error("Can't call _findInOrderedResults on unordered query");                                  // 939
  for (var i = 0; i < query.results.length; i++)                                                             // 940
    if (query.results[i] === doc)                                                                            // 941
      return i;                                                                                              // 942
  throw Error("object missing from query");                                                                  // 943
};                                                                                                           // 944
                                                                                                             // 945
// This binary search puts a value between any equal values, and the first                                   // 946
// lesser value.                                                                                             // 947
LocalCollection._binarySearch = function (cmp, array, value) {                                               // 948
  var first = 0, rangeLength = array.length;                                                                 // 949
                                                                                                             // 950
  while (rangeLength > 0) {                                                                                  // 951
    var halfRange = Math.floor(rangeLength/2);                                                               // 952
    if (cmp(value, array[first + halfRange]) >= 0) {                                                         // 953
      first += halfRange + 1;                                                                                // 954
      rangeLength -= halfRange + 1;                                                                          // 955
    } else {                                                                                                 // 956
      rangeLength = halfRange;                                                                               // 957
    }                                                                                                        // 958
  }                                                                                                          // 959
  return first;                                                                                              // 960
};                                                                                                           // 961
                                                                                                             // 962
LocalCollection._insertInSortedList = function (cmp, array, value) {                                         // 963
  if (array.length === 0) {                                                                                  // 964
    array.push(value);                                                                                       // 965
    return 0;                                                                                                // 966
  }                                                                                                          // 967
                                                                                                             // 968
  var idx = LocalCollection._binarySearch(cmp, array, value);                                                // 969
  array.splice(idx, 0, value);                                                                               // 970
  return idx;                                                                                                // 971
};                                                                                                           // 972
                                                                                                             // 973
// To track what documents are affected by a piece of code, call saveOriginals()                             // 974
// before it and retrieveOriginals() after it. retrieveOriginals returns an                                  // 975
// object whose keys are the ids of the documents that were affected since the                               // 976
// call to saveOriginals(), and the values are equal to the document's contents                              // 977
// at the time of saveOriginals. (In the case of an inserted document, undefined                             // 978
// is the value.) You must alternate between calls to saveOriginals() and                                    // 979
// retrieveOriginals().                                                                                      // 980
LocalCollection.prototype.saveOriginals = function () {                                                      // 981
  var self = this;                                                                                           // 982
  if (self._savedOriginals)                                                                                  // 983
    throw new Error("Called saveOriginals twice without retrieveOriginals");                                 // 984
  self._savedOriginals = new LocalCollection._IdMap;                                                         // 985
};                                                                                                           // 986
LocalCollection.prototype.retrieveOriginals = function () {                                                  // 987
  var self = this;                                                                                           // 988
  if (!self._savedOriginals)                                                                                 // 989
    throw new Error("Called retrieveOriginals without saveOriginals");                                       // 990
                                                                                                             // 991
  var originals = self._savedOriginals;                                                                      // 992
  self._savedOriginals = null;                                                                               // 993
  return originals;                                                                                          // 994
};                                                                                                           // 995
                                                                                                             // 996
LocalCollection.prototype._saveOriginal = function (id, doc) {                                               // 997
  var self = this;                                                                                           // 998
  // Are we even trying to save originals?                                                                   // 999
  if (!self._savedOriginals)                                                                                 // 1000
    return;                                                                                                  // 1001
  // Have we previously mutated the original (and so 'doc' is not actually                                   // 1002
  // original)?  (Note the 'has' check rather than truth: we store undefined                                 // 1003
  // here for inserted docs!)                                                                                // 1004
  if (self._savedOriginals.has(id))                                                                          // 1005
    return;                                                                                                  // 1006
  self._savedOriginals.set(id, EJSON.clone(doc));                                                            // 1007
};                                                                                                           // 1008
                                                                                                             // 1009
// Pause the observers. No callbacks from observers will fire until                                          // 1010
// 'resumeObservers' is called.                                                                              // 1011
LocalCollection.prototype.pauseObservers = function () {                                                     // 1012
  // No-op if already paused.                                                                                // 1013
  if (this.paused)                                                                                           // 1014
    return;                                                                                                  // 1015
                                                                                                             // 1016
  // Set the 'paused' flag such that new observer messages don't fire.                                       // 1017
  this.paused = true;                                                                                        // 1018
                                                                                                             // 1019
  // Take a snapshot of the query results for each query.                                                    // 1020
  for (var qid in this.queries) {                                                                            // 1021
    var query = this.queries[qid];                                                                           // 1022
                                                                                                             // 1023
    query.resultsSnapshot = EJSON.clone(query.results);                                                      // 1024
  }                                                                                                          // 1025
};                                                                                                           // 1026
                                                                                                             // 1027
// Resume the observers. Observers immediately receive change                                                // 1028
// notifications to bring them to the current state of the                                                   // 1029
// database. Note that this is not just replaying all the changes that                                       // 1030
// happened during the pause, it is a smarter 'coalesced' diff.                                              // 1031
LocalCollection.prototype.resumeObservers = function () {                                                    // 1032
  var self = this;                                                                                           // 1033
  // No-op if not paused.                                                                                    // 1034
  if (!this.paused)                                                                                          // 1035
    return;                                                                                                  // 1036
                                                                                                             // 1037
  // Unset the 'paused' flag. Make sure to do this first, otherwise                                          // 1038
  // observer methods won't actually fire when we trigger them.                                              // 1039
  this.paused = false;                                                                                       // 1040
                                                                                                             // 1041
  for (var qid in this.queries) {                                                                            // 1042
    var query = self.queries[qid];                                                                           // 1043
    // Diff the current results against the snapshot and send to observers.                                  // 1044
    // pass the query object for its observer callbacks.                                                     // 1045
    LocalCollection._diffQueryChanges(                                                                       // 1046
      query.ordered, query.resultsSnapshot, query.results, query,                                            // 1047
      { projectionFn: query.projectionFn });                                                                 // 1048
    query.resultsSnapshot = null;                                                                            // 1049
  }                                                                                                          // 1050
  self._observeQueue.drain();                                                                                // 1051
};                                                                                                           // 1052
                                                                                                             // 1053
                                                                                                             // 1054
// NB: used by livedata                                                                                      // 1055
LocalCollection._idStringify = function (id) {                                                               // 1056
  if (id instanceof LocalCollection._ObjectID) {                                                             // 1057
    return id.valueOf();                                                                                     // 1058
  } else if (typeof id === 'string') {                                                                       // 1059
    if (id === "") {                                                                                         // 1060
      return id;                                                                                             // 1061
    } else if (id.substr(0, 1) === "-" || // escape previously dashed strings                                // 1062
               id.substr(0, 1) === "~" || // escape escaped numbers, true, false                             // 1063
               LocalCollection._looksLikeObjectID(id) || // escape object-id-form strings                    // 1064
               id.substr(0, 1) === '{') { // escape object-form strings, for maybe implementing later        // 1065
      return "-" + id;                                                                                       // 1066
    } else {                                                                                                 // 1067
      return id; // other strings go through unchanged.                                                      // 1068
    }                                                                                                        // 1069
  } else if (id === undefined) {                                                                             // 1070
    return '-';                                                                                              // 1071
  } else if (typeof id === 'object' && id !== null) {                                                        // 1072
    throw new Error("Meteor does not currently support objects other than ObjectID as ids");                 // 1073
  } else { // Numbers, true, false, null                                                                     // 1074
    return "~" + JSON.stringify(id);                                                                         // 1075
  }                                                                                                          // 1076
};                                                                                                           // 1077
                                                                                                             // 1078
                                                                                                             // 1079
// NB: used by livedata                                                                                      // 1080
LocalCollection._idParse = function (id) {                                                                   // 1081
  if (id === "") {                                                                                           // 1082
    return id;                                                                                               // 1083
  } else if (id === '-') {                                                                                   // 1084
    return undefined;                                                                                        // 1085
  } else if (id.substr(0, 1) === '-') {                                                                      // 1086
    return id.substr(1);                                                                                     // 1087
  } else if (id.substr(0, 1) === '~') {                                                                      // 1088
    return JSON.parse(id.substr(1));                                                                         // 1089
  } else if (LocalCollection._looksLikeObjectID(id)) {                                                       // 1090
    return new LocalCollection._ObjectID(id);                                                                // 1091
  } else {                                                                                                   // 1092
    return id;                                                                                               // 1093
  }                                                                                                          // 1094
};                                                                                                           // 1095
                                                                                                             // 1096
LocalCollection._makeChangedFields = function (newDoc, oldDoc) {                                             // 1097
  var fields = {};                                                                                           // 1098
  LocalCollection._diffObjects(oldDoc, newDoc, {                                                             // 1099
    leftOnly: function (key, value) {                                                                        // 1100
      fields[key] = undefined;                                                                               // 1101
    },                                                                                                       // 1102
    rightOnly: function (key, value) {                                                                       // 1103
      fields[key] = value;                                                                                   // 1104
    },                                                                                                       // 1105
    both: function (key, leftValue, rightValue) {                                                            // 1106
      if (!EJSON.equals(leftValue, rightValue))                                                              // 1107
        fields[key] = rightValue;                                                                            // 1108
    }                                                                                                        // 1109
  });                                                                                                        // 1110
  return fields;                                                                                             // 1111
};                                                                                                           // 1112
                                                                                                             // 1113
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/wrap_transform.js                                                                      //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
// Wrap a transform function to return objects that have the _id field                                       // 1
// of the untransformed document. This ensures that subsystems such as                                       // 2
// the observe-sequence package that call `observe` can keep track of                                        // 3
// the documents identities.                                                                                 // 4
//                                                                                                           // 5
// - Require that it returns objects                                                                         // 6
// - If the return value has an _id field, verify that it matches the                                        // 7
//   original _id field                                                                                      // 8
// - If the return value doesn't have an _id field, add it back.                                             // 9
LocalCollection.wrapTransform = function (transform) {                                                       // 10
  if (! transform)                                                                                           // 11
    return null;                                                                                             // 12
                                                                                                             // 13
  // No need to doubly-wrap transforms.                                                                      // 14
  if (transform.__wrappedTransform__)                                                                        // 15
    return transform;                                                                                        // 16
                                                                                                             // 17
  var wrapped = function (doc) {                                                                             // 18
    if (!_.has(doc, '_id')) {                                                                                // 19
      // XXX do we ever have a transform on the oplog's collection? because that                             // 20
      // collection has no _id.                                                                              // 21
      throw new Error("can only transform documents with _id");                                              // 22
    }                                                                                                        // 23
                                                                                                             // 24
    var id = doc._id;                                                                                        // 25
    // XXX consider making tracker a weak dependency and checking Package.tracker here                       // 26
    var transformed = Tracker.nonreactive(function () {                                                      // 27
      return transform(doc);                                                                                 // 28
    });                                                                                                      // 29
                                                                                                             // 30
    if (!isPlainObject(transformed)) {                                                                       // 31
      throw new Error("transform must return object");                                                       // 32
    }                                                                                                        // 33
                                                                                                             // 34
    if (_.has(transformed, '_id')) {                                                                         // 35
      if (!EJSON.equals(transformed._id, id)) {                                                              // 36
        throw new Error("transformed document can't have different _id");                                    // 37
      }                                                                                                      // 38
    } else {                                                                                                 // 39
      transformed._id = id;                                                                                  // 40
    }                                                                                                        // 41
    return transformed;                                                                                      // 42
  };                                                                                                         // 43
  wrapped.__wrappedTransform__ = true;                                                                       // 44
  return wrapped;                                                                                            // 45
};                                                                                                           // 46
                                                                                                             // 47
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/helpers.js                                                                             //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
// Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as                              // 1
// arrays.                                                                                                   // 2
// XXX maybe this should be EJSON.isArray                                                                    // 3
isArray = function (x) {                                                                                     // 4
  return _.isArray(x) && !EJSON.isBinary(x);                                                                 // 5
};                                                                                                           // 6
                                                                                                             // 7
// XXX maybe this should be EJSON.isObject, though EJSON doesn't know about                                  // 8
// RegExp                                                                                                    // 9
// XXX note that _type(undefined) === 3!!!!                                                                  // 10
isPlainObject = LocalCollection._isPlainObject = function (x) {                                              // 11
  return x && LocalCollection._f._type(x) === 3;                                                             // 12
};                                                                                                           // 13
                                                                                                             // 14
isIndexable = function (x) {                                                                                 // 15
  return isArray(x) || isPlainObject(x);                                                                     // 16
};                                                                                                           // 17
                                                                                                             // 18
// Returns true if this is an object with at least one key and all keys begin                                // 19
// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and                               // 20
// others don't.                                                                                             // 21
isOperatorObject = function (valueSelector, inconsistentOK) {                                                // 22
  if (!isPlainObject(valueSelector))                                                                         // 23
    return false;                                                                                            // 24
                                                                                                             // 25
  var theseAreOperators = undefined;                                                                         // 26
  _.each(valueSelector, function (value, selKey) {                                                           // 27
    var thisIsOperator = selKey.substr(0, 1) === '$';                                                        // 28
    if (theseAreOperators === undefined) {                                                                   // 29
      theseAreOperators = thisIsOperator;                                                                    // 30
    } else if (theseAreOperators !== thisIsOperator) {                                                       // 31
      if (!inconsistentOK)                                                                                   // 32
        throw new Error("Inconsistent operator: " +                                                          // 33
                        JSON.stringify(valueSelector));                                                      // 34
      theseAreOperators = false;                                                                             // 35
    }                                                                                                        // 36
  });                                                                                                        // 37
  return !!theseAreOperators;  // {} has no operators                                                        // 38
};                                                                                                           // 39
                                                                                                             // 40
                                                                                                             // 41
// string can be converted to integer                                                                        // 42
isNumericKey = function (s) {                                                                                // 43
  return /^[0-9]+$/.test(s);                                                                                 // 44
};                                                                                                           // 45
                                                                                                             // 46
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/selector.js                                                                            //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
// The minimongo selector compiler!                                                                          // 1
                                                                                                             // 2
// Terminology:                                                                                              // 3
//  - a "selector" is the EJSON object representing a selector                                               // 4
//  - a "matcher" is its compiled form (whether a full Minimongo.Matcher                                     // 5
//    object or one of the component lambdas that matches parts of it)                                       // 6
//  - a "result object" is an object with a "result" field and maybe                                         // 7
//    distance and arrayIndices.                                                                             // 8
//  - a "branched value" is an object with a "value" field and maybe                                         // 9
//    "dontIterate" and "arrayIndices".                                                                      // 10
//  - a "document" is a top-level object that can be stored in a collection.                                 // 11
//  - a "lookup function" is a function that takes in a document and returns                                 // 12
//    an array of "branched values".                                                                         // 13
//  - a "branched matcher" maps from an array of branched values to a result                                 // 14
//    object.                                                                                                // 15
//  - an "element matcher" maps from a single value to a bool.                                               // 16
                                                                                                             // 17
// Main entry point.                                                                                         // 18
//   var matcher = new Minimongo.Matcher({a: {$gt: 5}});                                                     // 19
//   if (matcher.documentMatches({a: 7})) ...                                                                // 20
Minimongo.Matcher = function (selector) {                                                                    // 21
  var self = this;                                                                                           // 22
  // A set (object mapping string -> *) of all of the document paths looked                                  // 23
  // at by the selector. Also includes the empty string if it may look at any                                // 24
  // path (eg, $where).                                                                                      // 25
  self._paths = {};                                                                                          // 26
  // Set to true if compilation finds a $near.                                                               // 27
  self._hasGeoQuery = false;                                                                                 // 28
  // Set to true if compilation finds a $where.                                                              // 29
  self._hasWhere = false;                                                                                    // 30
  // Set to false if compilation finds anything other than a simple equality or                              // 31
  // one or more of '$gt', '$gte', '$lt', '$lte', '$ne', '$in', '$nin' used with                             // 32
  // scalars as operands.                                                                                    // 33
  self._isSimple = true;                                                                                     // 34
  // Set to a dummy document which always matches this Matcher. Or set to null                               // 35
  // if such document is too hard to find.                                                                   // 36
  self._matchingDocument = undefined;                                                                        // 37
  // A clone of the original selector. It may just be a function if the user                                 // 38
  // passed in a function; otherwise is definitely an object (eg, IDs are                                    // 39
  // translated into {_id: ID} first. Used by canBecomeTrueByModifier and                                    // 40
  // Sorter._useWithMatcher.                                                                                 // 41
  self._selector = null;                                                                                     // 42
  self._docMatcher = self._compileSelector(selector);                                                        // 43
};                                                                                                           // 44
                                                                                                             // 45
_.extend(Minimongo.Matcher.prototype, {                                                                      // 46
  documentMatches: function (doc) {                                                                          // 47
    if (!doc || typeof doc !== "object") {                                                                   // 48
      throw Error("documentMatches needs a document");                                                       // 49
    }                                                                                                        // 50
    return this._docMatcher(doc);                                                                            // 51
  },                                                                                                         // 52
  hasGeoQuery: function () {                                                                                 // 53
    return this._hasGeoQuery;                                                                                // 54
  },                                                                                                         // 55
  hasWhere: function () {                                                                                    // 56
    return this._hasWhere;                                                                                   // 57
  },                                                                                                         // 58
  isSimple: function () {                                                                                    // 59
    return this._isSimple;                                                                                   // 60
  },                                                                                                         // 61
                                                                                                             // 62
  // Given a selector, return a function that takes one argument, a                                          // 63
  // document. It returns a result object.                                                                   // 64
  _compileSelector: function (selector) {                                                                    // 65
    var self = this;                                                                                         // 66
    // you can pass a literal function instead of a selector                                                 // 67
    if (selector instanceof Function) {                                                                      // 68
      self._isSimple = false;                                                                                // 69
      self._selector = selector;                                                                             // 70
      self._recordPathUsed('');                                                                              // 71
      return function (doc) {                                                                                // 72
        return {result: !!selector.call(doc)};                                                               // 73
      };                                                                                                     // 74
    }                                                                                                        // 75
                                                                                                             // 76
    // shorthand -- scalars match _id                                                                        // 77
    if (LocalCollection._selectorIsId(selector)) {                                                           // 78
      self._selector = {_id: selector};                                                                      // 79
      self._recordPathUsed('_id');                                                                           // 80
      return function (doc) {                                                                                // 81
        return {result: EJSON.equals(doc._id, selector)};                                                    // 82
      };                                                                                                     // 83
    }                                                                                                        // 84
                                                                                                             // 85
    // protect against dangerous selectors.  falsey and {_id: falsey} are both                               // 86
    // likely programmer error, and not what you want, particularly for                                      // 87
    // destructive operations.                                                                               // 88
    if (!selector || (('_id' in selector) && !selector._id)) {                                               // 89
      self._isSimple = false;                                                                                // 90
      return nothingMatcher;                                                                                 // 91
    }                                                                                                        // 92
                                                                                                             // 93
    // Top level can't be an array or true or binary.                                                        // 94
    if (typeof(selector) === 'boolean' || isArray(selector) ||                                               // 95
        EJSON.isBinary(selector))                                                                            // 96
      throw new Error("Invalid selector: " + selector);                                                      // 97
                                                                                                             // 98
    self._selector = EJSON.clone(selector);                                                                  // 99
    return compileDocumentSelector(selector, self, {isRoot: true});                                          // 100
  },                                                                                                         // 101
  _recordPathUsed: function (path) {                                                                         // 102
    this._paths[path] = true;                                                                                // 103
  },                                                                                                         // 104
  // Returns a list of key paths the given selector is looking for. It includes                              // 105
  // the empty string if there is a $where.                                                                  // 106
  _getPaths: function () {                                                                                   // 107
    return _.keys(this._paths);                                                                              // 108
  }                                                                                                          // 109
});                                                                                                          // 110
                                                                                                             // 111
                                                                                                             // 112
// Takes in a selector that could match a full document (eg, the original                                    // 113
// selector). Returns a function mapping document->result object.                                            // 114
//                                                                                                           // 115
// matcher is the Matcher object we are compiling.                                                           // 116
//                                                                                                           // 117
// If this is the root document selector (ie, not wrapped in $and or the like),                              // 118
// then isRoot is true. (This is used by $near.)                                                             // 119
var compileDocumentSelector = function (docSelector, matcher, options) {                                     // 120
  options = options || {};                                                                                   // 121
  var docMatchers = [];                                                                                      // 122
  _.each(docSelector, function (subSelector, key) {                                                          // 123
    if (key.substr(0, 1) === '$') {                                                                          // 124
      // Outer operators are either logical operators (they recurse back into                                // 125
      // this function), or $where.                                                                          // 126
      if (!_.has(LOGICAL_OPERATORS, key))                                                                    // 127
        throw new Error("Unrecognized logical operator: " + key);                                            // 128
      matcher._isSimple = false;                                                                             // 129
      docMatchers.push(LOGICAL_OPERATORS[key](subSelector, matcher,                                          // 130
                                              options.inElemMatch));                                         // 131
    } else {                                                                                                 // 132
      // Record this path, but only if we aren't in an elemMatcher, since in an                              // 133
      // elemMatch this is a path inside an object in an array, not in the doc                               // 134
      // root.                                                                                               // 135
      if (!options.inElemMatch)                                                                              // 136
        matcher._recordPathUsed(key);                                                                        // 137
      var lookUpByIndex = makeLookupFunction(key);                                                           // 138
      var valueMatcher =                                                                                     // 139
        compileValueSelector(subSelector, matcher, options.isRoot);                                          // 140
      docMatchers.push(function (doc) {                                                                      // 141
        var branchValues = lookUpByIndex(doc);                                                               // 142
        return valueMatcher(branchValues);                                                                   // 143
      });                                                                                                    // 144
    }                                                                                                        // 145
  });                                                                                                        // 146
                                                                                                             // 147
  return andDocumentMatchers(docMatchers);                                                                   // 148
};                                                                                                           // 149
                                                                                                             // 150
// Takes in a selector that could match a key-indexed value in a document; eg,                               // 151
// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to                               // 152
// indicate equality).  Returns a branched matcher: a function mapping                                       // 153
// [branched value]->result object.                                                                          // 154
var compileValueSelector = function (valueSelector, matcher, isRoot) {                                       // 155
  if (valueSelector instanceof RegExp) {                                                                     // 156
    matcher._isSimple = false;                                                                               // 157
    return convertElementMatcherToBranchedMatcher(                                                           // 158
      regexpElementMatcher(valueSelector));                                                                  // 159
  } else if (isOperatorObject(valueSelector)) {                                                              // 160
    return operatorBranchedMatcher(valueSelector, matcher, isRoot);                                          // 161
  } else {                                                                                                   // 162
    return convertElementMatcherToBranchedMatcher(                                                           // 163
      equalityElementMatcher(valueSelector));                                                                // 164
  }                                                                                                          // 165
};                                                                                                           // 166
                                                                                                             // 167
// Given an element matcher (which evaluates a single value), returns a branched                             // 168
// value (which evaluates the element matcher on all the branches and returns a                              // 169
// more structured return value possibly including arrayIndices).                                            // 170
var convertElementMatcherToBranchedMatcher = function (                                                      // 171
    elementMatcher, options) {                                                                               // 172
  options = options || {};                                                                                   // 173
  return function (branches) {                                                                               // 174
    var expanded = branches;                                                                                 // 175
    if (!options.dontExpandLeafArrays) {                                                                     // 176
      expanded = expandArraysInBranches(                                                                     // 177
        branches, options.dontIncludeLeafArrays);                                                            // 178
    }                                                                                                        // 179
    var ret = {};                                                                                            // 180
    ret.result = _.any(expanded, function (element) {                                                        // 181
      var matched = elementMatcher(element.value);                                                           // 182
                                                                                                             // 183
      // Special case for $elemMatch: it means "true, and use this as an array                               // 184
      // index if I didn't already have one".                                                                // 185
      if (typeof matched === 'number') {                                                                     // 186
        // XXX This code dates from when we only stored a single array index                                 // 187
        // (for the outermost array). Should we be also including deeper array                               // 188
        // indices from the $elemMatch match?                                                                // 189
        if (!element.arrayIndices)                                                                           // 190
          element.arrayIndices = [matched];                                                                  // 191
        matched = true;                                                                                      // 192
      }                                                                                                      // 193
                                                                                                             // 194
      // If some element matched, and it's tagged with array indices, include                                // 195
      // those indices in our result object.                                                                 // 196
      if (matched && element.arrayIndices)                                                                   // 197
        ret.arrayIndices = element.arrayIndices;                                                             // 198
                                                                                                             // 199
      return matched;                                                                                        // 200
    });                                                                                                      // 201
    return ret;                                                                                              // 202
  };                                                                                                         // 203
};                                                                                                           // 204
                                                                                                             // 205
// Takes a RegExp object and returns an element matcher.                                                     // 206
regexpElementMatcher = function (regexp) {                                                                   // 207
  return function (value) {                                                                                  // 208
    if (value instanceof RegExp) {                                                                           // 209
      // Comparing two regexps means seeing if the regexps are identical                                     // 210
      // (really!). Underscore knows how.                                                                    // 211
      return _.isEqual(value, regexp);                                                                       // 212
    }                                                                                                        // 213
    // Regexps only work against strings.                                                                    // 214
    if (typeof value !== 'string')                                                                           // 215
      return false;                                                                                          // 216
                                                                                                             // 217
    // Reset regexp's state to avoid inconsistent matching for objects with the                              // 218
    // same value on consecutive calls of regexp.test. This happens only if the                              // 219
    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for                             // 220
    // which we should *not* change the lastIndex but MongoDB doesn't support                                // 221
    // either of these flags.                                                                                // 222
    regexp.lastIndex = 0;                                                                                    // 223
                                                                                                             // 224
    return regexp.test(value);                                                                               // 225
  };                                                                                                         // 226
};                                                                                                           // 227
                                                                                                             // 228
// Takes something that is not an operator object and returns an element matcher                             // 229
// for equality with that thing.                                                                             // 230
equalityElementMatcher = function (elementSelector) {                                                        // 231
  if (isOperatorObject(elementSelector))                                                                     // 232
    throw Error("Can't create equalityValueSelector for operator object");                                   // 233
                                                                                                             // 234
  // Special-case: null and undefined are equal (if you got undefined in there                               // 235
  // somewhere, or if you got it due to some branch being non-existent in the                                // 236
  // weird special case), even though they aren't with EJSON.equals.                                         // 237
  if (elementSelector == null) {  // undefined or null                                                       // 238
    return function (value) {                                                                                // 239
      return value == null;  // undefined or null                                                            // 240
    };                                                                                                       // 241
  }                                                                                                          // 242
                                                                                                             // 243
  return function (value) {                                                                                  // 244
    return LocalCollection._f._equal(elementSelector, value);                                                // 245
  };                                                                                                         // 246
};                                                                                                           // 247
                                                                                                             // 248
// Takes an operator object (an object with $ keys) and returns a branched                                   // 249
// matcher for it.                                                                                           // 250
var operatorBranchedMatcher = function (valueSelector, matcher, isRoot) {                                    // 251
  // Each valueSelector works separately on the various branches.  So one                                    // 252
  // operator can match one branch and another can match another branch.  This                               // 253
  // is OK.                                                                                                  // 254
                                                                                                             // 255
  var operatorMatchers = [];                                                                                 // 256
  _.each(valueSelector, function (operand, operator) {                                                       // 257
    // XXX we should actually implement $eq, which is new in 2.6                                             // 258
    var simpleRange = _.contains(['$lt', '$lte', '$gt', '$gte'], operator) &&                                // 259
      _.isNumber(operand);                                                                                   // 260
    var simpleInequality = operator === '$ne' && !_.isObject(operand);                                       // 261
    var simpleInclusion = _.contains(['$in', '$nin'], operator) &&                                           // 262
      _.isArray(operand) && !_.any(operand, _.isObject);                                                     // 263
                                                                                                             // 264
    if (! (operator === '$eq' || simpleRange ||                                                              // 265
           simpleInclusion || simpleInequality)) {                                                           // 266
      matcher._isSimple = false;                                                                             // 267
    }                                                                                                        // 268
                                                                                                             // 269
    if (_.has(VALUE_OPERATORS, operator)) {                                                                  // 270
      operatorMatchers.push(                                                                                 // 271
        VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot));                                 // 272
    } else if (_.has(ELEMENT_OPERATORS, operator)) {                                                         // 273
      var options = ELEMENT_OPERATORS[operator];                                                             // 274
      operatorMatchers.push(                                                                                 // 275
        convertElementMatcherToBranchedMatcher(                                                              // 276
          options.compileElementSelector(                                                                    // 277
            operand, valueSelector, matcher),                                                                // 278
          options));                                                                                         // 279
    } else {                                                                                                 // 280
      throw new Error("Unrecognized operator: " + operator);                                                 // 281
    }                                                                                                        // 282
  });                                                                                                        // 283
                                                                                                             // 284
  return andBranchedMatchers(operatorMatchers);                                                              // 285
};                                                                                                           // 286
                                                                                                             // 287
var compileArrayOfDocumentSelectors = function (                                                             // 288
    selectors, matcher, inElemMatch) {                                                                       // 289
  if (!isArray(selectors) || _.isEmpty(selectors))                                                           // 290
    throw Error("$and/$or/$nor must be nonempty array");                                                     // 291
  return _.map(selectors, function (subSelector) {                                                           // 292
    if (!isPlainObject(subSelector))                                                                         // 293
      throw Error("$or/$and/$nor entries need to be full objects");                                          // 294
    return compileDocumentSelector(                                                                          // 295
      subSelector, matcher, {inElemMatch: inElemMatch});                                                     // 296
  });                                                                                                        // 297
};                                                                                                           // 298
                                                                                                             // 299
// Operators that appear at the top level of a document selector.                                            // 300
var LOGICAL_OPERATORS = {                                                                                    // 301
  $and: function (subSelector, matcher, inElemMatch) {                                                       // 302
    var matchers = compileArrayOfDocumentSelectors(                                                          // 303
      subSelector, matcher, inElemMatch);                                                                    // 304
    return andDocumentMatchers(matchers);                                                                    // 305
  },                                                                                                         // 306
                                                                                                             // 307
  $or: function (subSelector, matcher, inElemMatch) {                                                        // 308
    var matchers = compileArrayOfDocumentSelectors(                                                          // 309
      subSelector, matcher, inElemMatch);                                                                    // 310
                                                                                                             // 311
    // Special case: if there is only one matcher, use it directly, *preserving*                             // 312
    // any arrayIndices it returns.                                                                          // 313
    if (matchers.length === 1)                                                                               // 314
      return matchers[0];                                                                                    // 315
                                                                                                             // 316
    return function (doc) {                                                                                  // 317
      var result = _.any(matchers, function (f) {                                                            // 318
        return f(doc).result;                                                                                // 319
      });                                                                                                    // 320
      // $or does NOT set arrayIndices when it has multiple                                                  // 321
      // sub-expressions. (Tested against MongoDB.)                                                          // 322
      return {result: result};                                                                               // 323
    };                                                                                                       // 324
  },                                                                                                         // 325
                                                                                                             // 326
  $nor: function (subSelector, matcher, inElemMatch) {                                                       // 327
    var matchers = compileArrayOfDocumentSelectors(                                                          // 328
      subSelector, matcher, inElemMatch);                                                                    // 329
    return function (doc) {                                                                                  // 330
      var result = _.all(matchers, function (f) {                                                            // 331
        return !f(doc).result;                                                                               // 332
      });                                                                                                    // 333
      // Never set arrayIndices, because we only match if nothing in particular                              // 334
      // "matched" (and because this is consistent with MongoDB).                                            // 335
      return {result: result};                                                                               // 336
    };                                                                                                       // 337
  },                                                                                                         // 338
                                                                                                             // 339
  $where: function (selectorValue, matcher) {                                                                // 340
    // Record that *any* path may be used.                                                                   // 341
    matcher._recordPathUsed('');                                                                             // 342
    matcher._hasWhere = true;                                                                                // 343
    if (!(selectorValue instanceof Function)) {                                                              // 344
      // XXX MongoDB seems to have more complex logic to decide where or or not                              // 345
      // to add "return"; not sure exactly what it is.                                                       // 346
      selectorValue = Function("obj", "return " + selectorValue);                                            // 347
    }                                                                                                        // 348
    return function (doc) {                                                                                  // 349
      // We make the document available as both `this` and `obj`.                                            // 350
      // XXX not sure what we should do if this throws                                                       // 351
      return {result: selectorValue.call(doc, doc)};                                                         // 352
    };                                                                                                       // 353
  },                                                                                                         // 354
                                                                                                             // 355
  // This is just used as a comment in the query (in MongoDB, it also ends up in                             // 356
  // query logs); it has no effect on the actual selection.                                                  // 357
  $comment: function () {                                                                                    // 358
    return function () {                                                                                     // 359
      return {result: true};                                                                                 // 360
    };                                                                                                       // 361
  }                                                                                                          // 362
};                                                                                                           // 363
                                                                                                             // 364
// Returns a branched matcher that matches iff the given matcher does not.                                   // 365
// Note that this implicitly "deMorganizes" the wrapped function.  ie, it                                    // 366
// means that ALL branch values need to fail to match innerBranchedMatcher.                                  // 367
var invertBranchedMatcher = function (branchedMatcher) {                                                     // 368
  return function (branchValues) {                                                                           // 369
    var invertMe = branchedMatcher(branchValues);                                                            // 370
    // We explicitly choose to strip arrayIndices here: it doesn't make sense to                             // 371
    // say "update the array element that does not match something", at least                                // 372
    // in mongo-land.                                                                                        // 373
    return {result: !invertMe.result};                                                                       // 374
  };                                                                                                         // 375
};                                                                                                           // 376
                                                                                                             // 377
// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a                                // 378
// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as                               // 379
// "match each branched value independently and combine with                                                 // 380
// convertElementMatcherToBranchedMatcher".                                                                  // 381
var VALUE_OPERATORS = {                                                                                      // 382
  $not: function (operand, valueSelector, matcher) {                                                         // 383
    return invertBranchedMatcher(compileValueSelector(operand, matcher));                                    // 384
  },                                                                                                         // 385
  $ne: function (operand) {                                                                                  // 386
    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(                                     // 387
      equalityElementMatcher(operand)));                                                                     // 388
  },                                                                                                         // 389
  $nin: function (operand) {                                                                                 // 390
    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(                                     // 391
      ELEMENT_OPERATORS.$in.compileElementSelector(operand)));                                               // 392
  },                                                                                                         // 393
  $exists: function (operand) {                                                                              // 394
    var exists = convertElementMatcherToBranchedMatcher(function (value) {                                   // 395
      return value !== undefined;                                                                            // 396
    });                                                                                                      // 397
    return operand ? exists : invertBranchedMatcher(exists);                                                 // 398
  },                                                                                                         // 399
  // $options just provides options for $regex; its logic is inside $regex                                   // 400
  $options: function (operand, valueSelector) {                                                              // 401
    if (!_.has(valueSelector, '$regex'))                                                                     // 402
      throw Error("$options needs a $regex");                                                                // 403
    return everythingMatcher;                                                                                // 404
  },                                                                                                         // 405
  // $maxDistance is basically an argument to $near                                                          // 406
  $maxDistance: function (operand, valueSelector) {                                                          // 407
    if (!valueSelector.$near)                                                                                // 408
      throw Error("$maxDistance needs a $near");                                                             // 409
    return everythingMatcher;                                                                                // 410
  },                                                                                                         // 411
  $all: function (operand, valueSelector, matcher) {                                                         // 412
    if (!isArray(operand))                                                                                   // 413
      throw Error("$all requires array");                                                                    // 414
    // Not sure why, but this seems to be what MongoDB does.                                                 // 415
    if (_.isEmpty(operand))                                                                                  // 416
      return nothingMatcher;                                                                                 // 417
                                                                                                             // 418
    var branchedMatchers = [];                                                                               // 419
    _.each(operand, function (criterion) {                                                                   // 420
      // XXX handle $all/$elemMatch combination                                                              // 421
      if (isOperatorObject(criterion))                                                                       // 422
        throw Error("no $ expressions in $all");                                                             // 423
      // This is always a regexp or equality selector.                                                       // 424
      branchedMatchers.push(compileValueSelector(criterion, matcher));                                       // 425
    });                                                                                                      // 426
    // andBranchedMatchers does NOT require all selectors to return true on the                              // 427
    // SAME branch.                                                                                          // 428
    return andBranchedMatchers(branchedMatchers);                                                            // 429
  },                                                                                                         // 430
  $near: function (operand, valueSelector, matcher, isRoot) {                                                // 431
    if (!isRoot)                                                                                             // 432
      throw Error("$near can't be inside another $ operator");                                               // 433
    matcher._hasGeoQuery = true;                                                                             // 434
                                                                                                             // 435
    // There are two kinds of geodata in MongoDB: coordinate pairs and                                       // 436
    // GeoJSON. They use different distance metrics, too. GeoJSON queries are                                // 437
    // marked with a $geometry property.                                                                     // 438
                                                                                                             // 439
    var maxDistance, point, distance;                                                                        // 440
    if (isPlainObject(operand) && _.has(operand, '$geometry')) {                                             // 441
      // GeoJSON "2dsphere" mode.                                                                            // 442
      maxDistance = operand.$maxDistance;                                                                    // 443
      point = operand.$geometry;                                                                             // 444
      distance = function (value) {                                                                          // 445
        // XXX: for now, we don't calculate the actual distance between, say,                                // 446
        // polygon and circle. If people care about this use-case it will get                                // 447
        // a priority.                                                                                       // 448
        if (!value || !value.type)                                                                           // 449
          return null;                                                                                       // 450
        if (value.type === "Point") {                                                                        // 451
          return GeoJSON.pointDistance(point, value);                                                        // 452
        } else {                                                                                             // 453
          return GeoJSON.geometryWithinRadius(value, point, maxDistance)                                     // 454
            ? 0 : maxDistance + 1;                                                                           // 455
        }                                                                                                    // 456
      };                                                                                                     // 457
    } else {                                                                                                 // 458
      maxDistance = valueSelector.$maxDistance;                                                              // 459
      if (!isArray(operand) && !isPlainObject(operand))                                                      // 460
        throw Error("$near argument must be coordinate pair or GeoJSON");                                    // 461
      point = pointToArray(operand);                                                                         // 462
      distance = function (value) {                                                                          // 463
        if (!isArray(value) && !isPlainObject(value))                                                        // 464
          return null;                                                                                       // 465
        return distanceCoordinatePairs(point, value);                                                        // 466
      };                                                                                                     // 467
    }                                                                                                        // 468
                                                                                                             // 469
    return function (branchedValues) {                                                                       // 470
      // There might be multiple points in the document that match the given                                 // 471
      // field. Only one of them needs to be within $maxDistance, but we need to                             // 472
      // evaluate all of them and use the nearest one for the implicit sort                                  // 473
      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)                                   // 474
      //                                                                                                     // 475
      // Note: This differs from MongoDB's implementation, where a document will                             // 476
      // actually show up *multiple times* in the result set, with one entry for                             // 477
      // each within-$maxDistance branching point.                                                           // 478
      branchedValues = expandArraysInBranches(branchedValues);                                               // 479
      var result = {result: false};                                                                          // 480
      _.each(branchedValues, function (branch) {                                                             // 481
        var curDistance = distance(branch.value);                                                            // 482
        // Skip branches that aren't real points or are too far away.                                        // 483
        if (curDistance === null || curDistance > maxDistance)                                               // 484
          return;                                                                                            // 485
        // Skip anything that's a tie.                                                                       // 486
        if (result.distance !== undefined && result.distance <= curDistance)                                 // 487
          return;                                                                                            // 488
        result.result = true;                                                                                // 489
        result.distance = curDistance;                                                                       // 490
        if (!branch.arrayIndices)                                                                            // 491
          delete result.arrayIndices;                                                                        // 492
        else                                                                                                 // 493
          result.arrayIndices = branch.arrayIndices;                                                         // 494
      });                                                                                                    // 495
      return result;                                                                                         // 496
    };                                                                                                       // 497
  }                                                                                                          // 498
};                                                                                                           // 499
                                                                                                             // 500
// Helpers for $near.                                                                                        // 501
var distanceCoordinatePairs = function (a, b) {                                                              // 502
  a = pointToArray(a);                                                                                       // 503
  b = pointToArray(b);                                                                                       // 504
  var x = a[0] - b[0];                                                                                       // 505
  var y = a[1] - b[1];                                                                                       // 506
  if (_.isNaN(x) || _.isNaN(y))                                                                              // 507
    return null;                                                                                             // 508
  return Math.sqrt(x * x + y * y);                                                                           // 509
};                                                                                                           // 510
// Makes sure we get 2 elements array and assume the first one to be x and                                   // 511
// the second one to y no matter what user passes.                                                           // 512
// In case user passes { lon: x, lat: y } returns [x, y]                                                     // 513
var pointToArray = function (point) {                                                                        // 514
  return _.map(point, _.identity);                                                                           // 515
};                                                                                                           // 516
                                                                                                             // 517
// Helper for $lt/$gt/$lte/$gte.                                                                             // 518
var makeInequality = function (cmpValueComparator) {                                                         // 519
  return {                                                                                                   // 520
    compileElementSelector: function (operand) {                                                             // 521
      // Arrays never compare false with non-arrays for any inequality.                                      // 522
      // XXX This was behavior we observed in pre-release MongoDB 2.5, but                                   // 523
      //     it seems to have been reverted.                                                                 // 524
      //     See https://jira.mongodb.org/browse/SERVER-11444                                                // 525
      if (isArray(operand)) {                                                                                // 526
        return function () {                                                                                 // 527
          return false;                                                                                      // 528
        };                                                                                                   // 529
      }                                                                                                      // 530
                                                                                                             // 531
      // Special case: consider undefined and null the same (so true with                                    // 532
      // $gte/$lte).                                                                                         // 533
      if (operand === undefined)                                                                             // 534
        operand = null;                                                                                      // 535
                                                                                                             // 536
      var operandType = LocalCollection._f._type(operand);                                                   // 537
                                                                                                             // 538
      return function (value) {                                                                              // 539
        if (value === undefined)                                                                             // 540
          value = null;                                                                                      // 541
        // Comparisons are never true among things of different type (except                                 // 542
        // null vs undefined).                                                                               // 543
        if (LocalCollection._f._type(value) !== operandType)                                                 // 544
          return false;                                                                                      // 545
        return cmpValueComparator(LocalCollection._f._cmp(value, operand));                                  // 546
      };                                                                                                     // 547
    }                                                                                                        // 548
  };                                                                                                         // 549
};                                                                                                           // 550
                                                                                                             // 551
// Each element selector contains:                                                                           // 552
//  - compileElementSelector, a function with args:                                                          // 553
//    - operand - the "right hand side" of the operator                                                      // 554
//    - valueSelector - the "context" for the operator (so that $regex can find                              // 555
//      $options)                                                                                            // 556
//    - matcher - the Matcher this is going into (so that $elemMatch can compile                             // 557
//      more things)                                                                                         // 558
//    returning a function mapping a single value to bool.                                                   // 559
//  - dontExpandLeafArrays, a bool which prevents expandArraysInBranches from                                // 560
//    being called                                                                                           // 561
//  - dontIncludeLeafArrays, a bool which causes an argument to be passed to                                 // 562
//    expandArraysInBranches if it is called                                                                 // 563
ELEMENT_OPERATORS = {                                                                                        // 564
  $lt: makeInequality(function (cmpValue) {                                                                  // 565
    return cmpValue < 0;                                                                                     // 566
  }),                                                                                                        // 567
  $gt: makeInequality(function (cmpValue) {                                                                  // 568
    return cmpValue > 0;                                                                                     // 569
  }),                                                                                                        // 570
  $lte: makeInequality(function (cmpValue) {                                                                 // 571
    return cmpValue <= 0;                                                                                    // 572
  }),                                                                                                        // 573
  $gte: makeInequality(function (cmpValue) {                                                                 // 574
    return cmpValue >= 0;                                                                                    // 575
  }),                                                                                                        // 576
  $mod: {                                                                                                    // 577
    compileElementSelector: function (operand) {                                                             // 578
      if (!(isArray(operand) && operand.length === 2                                                         // 579
            && typeof(operand[0]) === 'number'                                                               // 580
            && typeof(operand[1]) === 'number')) {                                                           // 581
        throw Error("argument to $mod must be an array of two numbers");                                     // 582
      }                                                                                                      // 583
      // XXX could require to be ints or round or something                                                  // 584
      var divisor = operand[0];                                                                              // 585
      var remainder = operand[1];                                                                            // 586
      return function (value) {                                                                              // 587
        return typeof value === 'number' && value % divisor === remainder;                                   // 588
      };                                                                                                     // 589
    }                                                                                                        // 590
  },                                                                                                         // 591
  $in: {                                                                                                     // 592
    compileElementSelector: function (operand) {                                                             // 593
      if (!isArray(operand))                                                                                 // 594
        throw Error("$in needs an array");                                                                   // 595
                                                                                                             // 596
      var elementMatchers = [];                                                                              // 597
      _.each(operand, function (option) {                                                                    // 598
        if (option instanceof RegExp)                                                                        // 599
          elementMatchers.push(regexpElementMatcher(option));                                                // 600
        else if (isOperatorObject(option))                                                                   // 601
          throw Error("cannot nest $ under $in");                                                            // 602
        else                                                                                                 // 603
          elementMatchers.push(equalityElementMatcher(option));                                              // 604
      });                                                                                                    // 605
                                                                                                             // 606
      return function (value) {                                                                              // 607
        // Allow {a: {$in: [null]}} to match when 'a' does not exist.                                        // 608
        if (value === undefined)                                                                             // 609
          value = null;                                                                                      // 610
        return _.any(elementMatchers, function (e) {                                                         // 611
          return e(value);                                                                                   // 612
        });                                                                                                  // 613
      };                                                                                                     // 614
    }                                                                                                        // 615
  },                                                                                                         // 616
  $size: {                                                                                                   // 617
    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we                               // 618
    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a                               // 619
    // possible value.                                                                                       // 620
    dontExpandLeafArrays: true,                                                                              // 621
    compileElementSelector: function (operand) {                                                             // 622
      if (typeof operand === 'string') {                                                                     // 623
        // Don't ask me why, but by experimentation, this seems to be what Mongo                             // 624
        // does.                                                                                             // 625
        operand = 0;                                                                                         // 626
      } else if (typeof operand !== 'number') {                                                              // 627
        throw Error("$size needs a number");                                                                 // 628
      }                                                                                                      // 629
      return function (value) {                                                                              // 630
        return isArray(value) && value.length === operand;                                                   // 631
      };                                                                                                     // 632
    }                                                                                                        // 633
  },                                                                                                         // 634
  $type: {                                                                                                   // 635
    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should                                // 636
    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:                                // 637
    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but                                // 638
    // should *not* include it itself.                                                                       // 639
    dontIncludeLeafArrays: true,                                                                             // 640
    compileElementSelector: function (operand) {                                                             // 641
      if (typeof operand !== 'number')                                                                       // 642
        throw Error("$type needs a number");                                                                 // 643
      return function (value) {                                                                              // 644
        return value !== undefined                                                                           // 645
          && LocalCollection._f._type(value) === operand;                                                    // 646
      };                                                                                                     // 647
    }                                                                                                        // 648
  },                                                                                                         // 649
  $regex: {                                                                                                  // 650
    compileElementSelector: function (operand, valueSelector) {                                              // 651
      if (!(typeof operand === 'string' || operand instanceof RegExp))                                       // 652
        throw Error("$regex has to be a string or RegExp");                                                  // 653
                                                                                                             // 654
      var regexp;                                                                                            // 655
      if (valueSelector.$options !== undefined) {                                                            // 656
        // Options passed in $options (even the empty string) always overrides                               // 657
        // options in the RegExp object itself. (See also                                                    // 658
        // Mongo.Collection._rewriteSelector.)                                                               // 659
                                                                                                             // 660
        // Be clear that we only support the JS-supported options, not extended                              // 661
        // ones (eg, Mongo supports x and s). Ideally we would implement x and s                             // 662
        // by transforming the regexp, but not today...                                                      // 663
        if (/[^gim]/.test(valueSelector.$options))                                                           // 664
          throw new Error("Only the i, m, and g regexp options are supported");                              // 665
                                                                                                             // 666
        var regexSource = operand instanceof RegExp ? operand.source : operand;                              // 667
        regexp = new RegExp(regexSource, valueSelector.$options);                                            // 668
      } else if (operand instanceof RegExp) {                                                                // 669
        regexp = operand;                                                                                    // 670
      } else {                                                                                               // 671
        regexp = new RegExp(operand);                                                                        // 672
      }                                                                                                      // 673
      return regexpElementMatcher(regexp);                                                                   // 674
    }                                                                                                        // 675
  },                                                                                                         // 676
  $elemMatch: {                                                                                              // 677
    dontExpandLeafArrays: true,                                                                              // 678
    compileElementSelector: function (operand, valueSelector, matcher) {                                     // 679
      if (!isPlainObject(operand))                                                                           // 680
        throw Error("$elemMatch need an object");                                                            // 681
                                                                                                             // 682
      var subMatcher, isDocMatcher;                                                                          // 683
      if (isOperatorObject(operand, true)) {                                                                 // 684
        subMatcher = compileValueSelector(operand, matcher);                                                 // 685
        isDocMatcher = false;                                                                                // 686
      } else {                                                                                               // 687
        // This is NOT the same as compileValueSelector(operand), and not just                               // 688
        // because of the slightly different calling convention.                                             // 689
        // {$elemMatch: {x: 3}} means "an element has a field x:3", not                                      // 690
        // "consists only of a field x:3". Also, regexps and sub-$ are allowed.                              // 691
        subMatcher = compileDocumentSelector(operand, matcher,                                               // 692
                                             {inElemMatch: true});                                           // 693
        isDocMatcher = true;                                                                                 // 694
      }                                                                                                      // 695
                                                                                                             // 696
      return function (value) {                                                                              // 697
        if (!isArray(value))                                                                                 // 698
          return false;                                                                                      // 699
        for (var i = 0; i < value.length; ++i) {                                                             // 700
          var arrayElement = value[i];                                                                       // 701
          var arg;                                                                                           // 702
          if (isDocMatcher) {                                                                                // 703
            // We can only match {$elemMatch: {b: 3}} against objects.                                       // 704
            // (We can also match against arrays, if there's numeric indices,                                // 705
            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)                                         // 706
            if (!isPlainObject(arrayElement) && !isArray(arrayElement))                                      // 707
              return false;                                                                                  // 708
            arg = arrayElement;                                                                              // 709
          } else {                                                                                           // 710
            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches                                  // 711
            // {a: [8]} but not {a: [[8]]}                                                                   // 712
            arg = [{value: arrayElement, dontIterate: true}];                                                // 713
          }                                                                                                  // 714
          // XXX support $near in $elemMatch by propagating $distance?                                       // 715
          if (subMatcher(arg).result)                                                                        // 716
            return i;   // specially understood to mean "use as arrayIndices"                                // 717
        }                                                                                                    // 718
        return false;                                                                                        // 719
      };                                                                                                     // 720
    }                                                                                                        // 721
  }                                                                                                          // 722
};                                                                                                           // 723
                                                                                                             // 724
// makeLookupFunction(key) returns a lookup function.                                                        // 725
//                                                                                                           // 726
// A lookup function takes in a document and returns an array of matching                                    // 727
// branches.  If no arrays are found while looking up the key, this array will                               // 728
// have exactly one branches (possibly 'undefined', if some segment of the key                               // 729
// was not found).                                                                                           // 730
//                                                                                                           // 731
// If arrays are found in the middle, this can have more than one element, since                             // 732
// we "branch". When we "branch", if there are more key segments to look up,                                 // 733
// then we only pursue branches that are plain objects (not arrays or scalars).                              // 734
// This means we can actually end up with no branches!                                                       // 735
//                                                                                                           // 736
// We do *NOT* branch on arrays that are found at the end (ie, at the last                                   // 737
// dotted member of the key). We just return that array; if you want to                                      // 738
// effectively "branch" over the array's values, post-process the lookup                                     // 739
// function with expandArraysInBranches.                                                                     // 740
//                                                                                                           // 741
// Each branch is an object with keys:                                                                       // 742
//  - value: the value at the branch                                                                         // 743
//  - dontIterate: an optional bool; if true, it means that 'value' is an array                              // 744
//    that expandArraysInBranches should NOT expand. This specifically happens                               // 745
//    when there is a numeric index in the key, and ensures the                                              // 746
//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT                                          // 747
//    match {a: [[5]]}.                                                                                      // 748
//  - arrayIndices: if any array indexing was done during lookup (either due to                              // 749
//    explicit numeric indices or implicit branching), this will be an array of                              // 750
//    the array indices used, from outermost to innermost; it is falsey or                                   // 751
//    absent if no array index is used. If an explicit numeric index is used,                                // 752
//    the index will be followed in arrayIndices by the string 'x'.                                          // 753
//                                                                                                           // 754
//    Note: arrayIndices is used for two purposes. First, it is used to                                      // 755
//    implement the '$' modifier feature, which only ever looks at its first                                 // 756
//    element.                                                                                               // 757
//                                                                                                           // 758
//    Second, it is used for sort key generation, which needs to be able to tell                             // 759
//    the difference between different paths. Moreover, it needs to                                          // 760
//    differentiate between explicit and implicit branching, which is why                                    // 761
//    there's the somewhat hacky 'x' entry: this means that explicit and                                     // 762
//    implicit array lookups will have different full arrayIndices paths. (That                              // 763
//    code only requires that different paths have different arrayIndices; it                                // 764
//    doesn't actually "parse" arrayIndices. As an alternative, arrayIndices                                 // 765
//    could contain objects with flags like "implicit", but I think that only                                // 766
//    makes the code surrounding them more complex.)                                                         // 767
//                                                                                                           // 768
//    (By the way, this field ends up getting passed around a lot without                                    // 769
//    cloning, so never mutate any arrayIndices field/var in this package!)                                  // 770
//                                                                                                           // 771
//                                                                                                           // 772
// At the top level, you may only pass in a plain object or array.                                           // 773
//                                                                                                           // 774
// See the test 'minimongo - lookup' for some examples of what lookup functions                              // 775
// return.                                                                                                   // 776
makeLookupFunction = function (key, options) {                                                               // 777
  options = options || {};                                                                                   // 778
  var parts = key.split('.');                                                                                // 779
  var firstPart = parts.length ? parts[0] : '';                                                              // 780
  var firstPartIsNumeric = isNumericKey(firstPart);                                                          // 781
  var nextPartIsNumeric = parts.length >= 2 && isNumericKey(parts[1]);                                       // 782
  var lookupRest;                                                                                            // 783
  if (parts.length > 1) {                                                                                    // 784
    lookupRest = makeLookupFunction(parts.slice(1).join('.'));                                               // 785
  }                                                                                                          // 786
                                                                                                             // 787
  var omitUnnecessaryFields = function (retVal) {                                                            // 788
    if (!retVal.dontIterate)                                                                                 // 789
      delete retVal.dontIterate;                                                                             // 790
    if (retVal.arrayIndices && !retVal.arrayIndices.length)                                                  // 791
      delete retVal.arrayIndices;                                                                            // 792
    return retVal;                                                                                           // 793
  };                                                                                                         // 794
                                                                                                             // 795
  // Doc will always be a plain object or an array.                                                          // 796
  // apply an explicit numeric index, an array.                                                              // 797
  return function (doc, arrayIndices) {                                                                      // 798
    if (!arrayIndices)                                                                                       // 799
      arrayIndices = [];                                                                                     // 800
                                                                                                             // 801
    if (isArray(doc)) {                                                                                      // 802
      // If we're being asked to do an invalid lookup into an array (non-integer                             // 803
      // or out-of-bounds), return no results (which is different from returning                             // 804
      // a single undefined result, in that `null` equality checks won't match).                             // 805
      if (!(firstPartIsNumeric && firstPart < doc.length))                                                   // 806
        return [];                                                                                           // 807
                                                                                                             // 808
      // Remember that we used this array index. Include an 'x' to indicate that                             // 809
      // the previous index came from being considered as an explicit array                                  // 810
      // index (not branching).                                                                              // 811
      arrayIndices = arrayIndices.concat(+firstPart, 'x');                                                   // 812
    }                                                                                                        // 813
                                                                                                             // 814
    // Do our first lookup.                                                                                  // 815
    var firstLevel = doc[firstPart];                                                                         // 816
                                                                                                             // 817
    // If there is no deeper to dig, return what we found.                                                   // 818
    //                                                                                                       // 819
    // If what we found is an array, most value selectors will choose to treat                               // 820
    // the elements of the array as matchable values in their own right, but                                 // 821
    // that's done outside of the lookup function. (Exceptions to this are $size                             // 822
    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:                             // 823
    // [[1, 2]]}.)                                                                                           // 824
    //                                                                                                       // 825
    // That said, if we just did an *explicit* array lookup (on doc) to find                                 // 826
    // firstLevel, and firstLevel is an array too, we do NOT want value                                      // 827
    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.                              // 828
    // So in that case, we mark the return value as "don't iterate".                                         // 829
    if (!lookupRest) {                                                                                       // 830
      return [omitUnnecessaryFields({                                                                        // 831
        value: firstLevel,                                                                                   // 832
        dontIterate: isArray(doc) && isArray(firstLevel),                                                    // 833
        arrayIndices: arrayIndices})];                                                                       // 834
    }                                                                                                        // 835
                                                                                                             // 836
    // We need to dig deeper.  But if we can't, because what we've found is not                              // 837
    // an array or plain object, we're done. If we just did a numeric index into                             // 838
    // an array, we return nothing here (this is a change in Mongo 2.5 from                                  // 839
    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,                               // 840
    // return a single `undefined` (which can, for example, match via equality                               // 841
    // with `null`).                                                                                         // 842
    if (!isIndexable(firstLevel)) {                                                                          // 843
      if (isArray(doc))                                                                                      // 844
        return [];                                                                                           // 845
      return [omitUnnecessaryFields({value: undefined,                                                       // 846
                                      arrayIndices: arrayIndices})];                                         // 847
    }                                                                                                        // 848
                                                                                                             // 849
    var result = [];                                                                                         // 850
    var appendToResult = function (more) {                                                                   // 851
      Array.prototype.push.apply(result, more);                                                              // 852
    };                                                                                                       // 853
                                                                                                             // 854
    // Dig deeper: look up the rest of the parts on whatever we've found.                                    // 855
    // (lookupRest is smart enough to not try to do invalid lookups into                                     // 856
    // firstLevel if it's an array.)                                                                         // 857
    appendToResult(lookupRest(firstLevel, arrayIndices));                                                    // 858
                                                                                                             // 859
    // If we found an array, then in *addition* to potentially treating the next                             // 860
    // part as a literal integer lookup, we should also "branch": try to look up                             // 861
    // the rest of the parts on each array element in parallel.                                              // 862
    //                                                                                                       // 863
    // In this case, we *only* dig deeper into array elements that are plain                                 // 864
    // objects. (Recall that we only got this far if we have further to dig.)                                // 865
    // This makes sense: we certainly don't dig deeper into non-indexable                                    // 866
    // objects. And it would be weird to dig into an array: it's simpler to have                             // 867
    // a rule that explicit integer indexes only apply to an outer array, not to                             // 868
    // an array you find after a branching search.                                                           // 869
    //                                                                                                       // 870
    // In the special case of a numeric part in a *sort selector* (not a query                               // 871
    // selector), we skip the branching: we ONLY allow the numeric part to mean                              // 872
    // "look up this index" in that case, not "also look up this index in all                                // 873
    // the elements of the array".                                                                           // 874
    if (isArray(firstLevel) && !(nextPartIsNumeric && options.forSort)) {                                    // 875
      _.each(firstLevel, function (branch, arrayIndex) {                                                     // 876
        if (isPlainObject(branch)) {                                                                         // 877
          appendToResult(lookupRest(                                                                         // 878
            branch,                                                                                          // 879
            arrayIndices.concat(arrayIndex)));                                                               // 880
        }                                                                                                    // 881
      });                                                                                                    // 882
    }                                                                                                        // 883
                                                                                                             // 884
    return result;                                                                                           // 885
  };                                                                                                         // 886
};                                                                                                           // 887
MinimongoTest.makeLookupFunction = makeLookupFunction;                                                       // 888
                                                                                                             // 889
expandArraysInBranches = function (branches, skipTheArrays) {                                                // 890
  var branchesOut = [];                                                                                      // 891
  _.each(branches, function (branch) {                                                                       // 892
    var thisIsArray = isArray(branch.value);                                                                 // 893
    // We include the branch itself, *UNLESS* we it's an array that we're going                              // 894
    // to iterate and we're told to skip arrays.  (That's right, we include some                             // 895
    // arrays even skipTheArrays is true: these are arrays that were found via                               // 896
    // explicit numerical indices.)                                                                          // 897
    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {                                            // 898
      branchesOut.push({                                                                                     // 899
        value: branch.value,                                                                                 // 900
        arrayIndices: branch.arrayIndices                                                                    // 901
      });                                                                                                    // 902
    }                                                                                                        // 903
    if (thisIsArray && !branch.dontIterate) {                                                                // 904
      _.each(branch.value, function (leaf, i) {                                                              // 905
        branchesOut.push({                                                                                   // 906
          value: leaf,                                                                                       // 907
          arrayIndices: (branch.arrayIndices || []).concat(i)                                                // 908
        });                                                                                                  // 909
      });                                                                                                    // 910
    }                                                                                                        // 911
  });                                                                                                        // 912
  return branchesOut;                                                                                        // 913
};                                                                                                           // 914
                                                                                                             // 915
var nothingMatcher = function (docOrBranchedValues) {                                                        // 916
  return {result: false};                                                                                    // 917
};                                                                                                           // 918
                                                                                                             // 919
var everythingMatcher = function (docOrBranchedValues) {                                                     // 920
  return {result: true};                                                                                     // 921
};                                                                                                           // 922
                                                                                                             // 923
                                                                                                             // 924
// NB: We are cheating and using this function to implement "AND" for both                                   // 925
// "document matchers" and "branched matchers". They both return result objects                              // 926
// but the argument is different: for the former it's a whole doc, whereas for                               // 927
// the latter it's an array of "branched values".                                                            // 928
var andSomeMatchers = function (subMatchers) {                                                               // 929
  if (subMatchers.length === 0)                                                                              // 930
    return everythingMatcher;                                                                                // 931
  if (subMatchers.length === 1)                                                                              // 932
    return subMatchers[0];                                                                                   // 933
                                                                                                             // 934
  return function (docOrBranches) {                                                                          // 935
    var ret = {};                                                                                            // 936
    ret.result = _.all(subMatchers, function (f) {                                                           // 937
      var subResult = f(docOrBranches);                                                                      // 938
      // Copy a 'distance' number out of the first sub-matcher that has                                      // 939
      // one. Yes, this means that if there are multiple $near fields in a                                   // 940
      // query, something arbitrary happens; this appears to be consistent with                              // 941
      // Mongo.                                                                                              // 942
      if (subResult.result && subResult.distance !== undefined                                               // 943
          && ret.distance === undefined) {                                                                   // 944
        ret.distance = subResult.distance;                                                                   // 945
      }                                                                                                      // 946
      // Similarly, propagate arrayIndices from sub-matchers... but to match                                 // 947
      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices                                // 948
      // wins.                                                                                               // 949
      if (subResult.result && subResult.arrayIndices) {                                                      // 950
        ret.arrayIndices = subResult.arrayIndices;                                                           // 951
      }                                                                                                      // 952
      return subResult.result;                                                                               // 953
    });                                                                                                      // 954
                                                                                                             // 955
    // If we didn't actually match, forget any extra metadata we came up with.                               // 956
    if (!ret.result) {                                                                                       // 957
      delete ret.distance;                                                                                   // 958
      delete ret.arrayIndices;                                                                               // 959
    }                                                                                                        // 960
    return ret;                                                                                              // 961
  };                                                                                                         // 962
};                                                                                                           // 963
                                                                                                             // 964
var andDocumentMatchers = andSomeMatchers;                                                                   // 965
var andBranchedMatchers = andSomeMatchers;                                                                   // 966
                                                                                                             // 967
                                                                                                             // 968
// helpers used by compiled selector code                                                                    // 969
LocalCollection._f = {                                                                                       // 970
  // XXX for _all and _in, consider building 'inquery' at compile time..                                     // 971
                                                                                                             // 972
  _type: function (v) {                                                                                      // 973
    if (typeof v === "number")                                                                               // 974
      return 1;                                                                                              // 975
    if (typeof v === "string")                                                                               // 976
      return 2;                                                                                              // 977
    if (typeof v === "boolean")                                                                              // 978
      return 8;                                                                                              // 979
    if (isArray(v))                                                                                          // 980
      return 4;                                                                                              // 981
    if (v === null)                                                                                          // 982
      return 10;                                                                                             // 983
    if (v instanceof RegExp)                                                                                 // 984
      // note that typeof(/x/) === "object"                                                                  // 985
      return 11;                                                                                             // 986
    if (typeof v === "function")                                                                             // 987
      return 13;                                                                                             // 988
    if (v instanceof Date)                                                                                   // 989
      return 9;                                                                                              // 990
    if (EJSON.isBinary(v))                                                                                   // 991
      return 5;                                                                                              // 992
    if (v instanceof LocalCollection._ObjectID)                                                              // 993
      return 7;                                                                                              // 994
    return 3; // object                                                                                      // 995
                                                                                                             // 996
    // XXX support some/all of these:                                                                        // 997
    // 14, symbol                                                                                            // 998
    // 15, javascript code with scope                                                                        // 999
    // 16, 18: 32-bit/64-bit integer                                                                         // 1000
    // 17, timestamp                                                                                         // 1001
    // 255, minkey                                                                                           // 1002
    // 127, maxkey                                                                                           // 1003
  },                                                                                                         // 1004
                                                                                                             // 1005
  // deep equality test: use for literal document and array matches                                          // 1006
  _equal: function (a, b) {                                                                                  // 1007
    return EJSON.equals(a, b, {keyOrderSensitive: true});                                                    // 1008
  },                                                                                                         // 1009
                                                                                                             // 1010
  // maps a type code to a value that can be used to sort values of                                          // 1011
  // different types                                                                                         // 1012
  _typeorder: function (t) {                                                                                 // 1013
    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types                          // 1014
    // XXX what is the correct sort position for Javascript code?                                            // 1015
    // ('100' in the matrix below)                                                                           // 1016
    // XXX minkey/maxkey                                                                                     // 1017
    return [-1,  // (not a type)                                                                             // 1018
            1,   // number                                                                                   // 1019
            2,   // string                                                                                   // 1020
            3,   // object                                                                                   // 1021
            4,   // array                                                                                    // 1022
            5,   // binary                                                                                   // 1023
            -1,  // deprecated                                                                               // 1024
            6,   // ObjectID                                                                                 // 1025
            7,   // bool                                                                                     // 1026
            8,   // Date                                                                                     // 1027
            0,   // null                                                                                     // 1028
            9,   // RegExp                                                                                   // 1029
            -1,  // deprecated                                                                               // 1030
            100, // JS code                                                                                  // 1031
            2,   // deprecated (symbol)                                                                      // 1032
            100, // JS code                                                                                  // 1033
            1,   // 32-bit int                                                                               // 1034
            8,   // Mongo timestamp                                                                          // 1035
            1    // 64-bit int                                                                               // 1036
           ][t];                                                                                             // 1037
  },                                                                                                         // 1038
                                                                                                             // 1039
  // compare two values of unknown type according to BSON ordering                                           // 1040
  // semantics. (as an extension, consider 'undefined' to be less than                                       // 1041
  // any other value.) return negative if a is less, positive if b is                                        // 1042
  // less, or 0 if equal                                                                                     // 1043
  _cmp: function (a, b) {                                                                                    // 1044
    if (a === undefined)                                                                                     // 1045
      return b === undefined ? 0 : -1;                                                                       // 1046
    if (b === undefined)                                                                                     // 1047
      return 1;                                                                                              // 1048
    var ta = LocalCollection._f._type(a);                                                                    // 1049
    var tb = LocalCollection._f._type(b);                                                                    // 1050
    var oa = LocalCollection._f._typeorder(ta);                                                              // 1051
    var ob = LocalCollection._f._typeorder(tb);                                                              // 1052
    if (oa !== ob)                                                                                           // 1053
      return oa < ob ? -1 : 1;                                                                               // 1054
    if (ta !== tb)                                                                                           // 1055
      // XXX need to implement this if we implement Symbol or integers, or                                   // 1056
      // Timestamp                                                                                           // 1057
      throw Error("Missing type coercion logic in _cmp");                                                    // 1058
    if (ta === 7) { // ObjectID                                                                              // 1059
      // Convert to string.                                                                                  // 1060
      ta = tb = 2;                                                                                           // 1061
      a = a.toHexString();                                                                                   // 1062
      b = b.toHexString();                                                                                   // 1063
    }                                                                                                        // 1064
    if (ta === 9) { // Date                                                                                  // 1065
      // Convert to millis.                                                                                  // 1066
      ta = tb = 1;                                                                                           // 1067
      a = a.getTime();                                                                                       // 1068
      b = b.getTime();                                                                                       // 1069
    }                                                                                                        // 1070
                                                                                                             // 1071
    if (ta === 1) // double                                                                                  // 1072
      return a - b;                                                                                          // 1073
    if (tb === 2) // string                                                                                  // 1074
      return a < b ? -1 : (a === b ? 0 : 1);                                                                 // 1075
    if (ta === 3) { // Object                                                                                // 1076
      // this could be much more efficient in the expected case ...                                          // 1077
      var to_array = function (obj) {                                                                        // 1078
        var ret = [];                                                                                        // 1079
        for (var key in obj) {                                                                               // 1080
          ret.push(key);                                                                                     // 1081
          ret.push(obj[key]);                                                                                // 1082
        }                                                                                                    // 1083
        return ret;                                                                                          // 1084
      };                                                                                                     // 1085
      return LocalCollection._f._cmp(to_array(a), to_array(b));                                              // 1086
    }                                                                                                        // 1087
    if (ta === 4) { // Array                                                                                 // 1088
      for (var i = 0; ; i++) {                                                                               // 1089
        if (i === a.length)                                                                                  // 1090
          return (i === b.length) ? 0 : -1;                                                                  // 1091
        if (i === b.length)                                                                                  // 1092
          return 1;                                                                                          // 1093
        var s = LocalCollection._f._cmp(a[i], b[i]);                                                         // 1094
        if (s !== 0)                                                                                         // 1095
          return s;                                                                                          // 1096
      }                                                                                                      // 1097
    }                                                                                                        // 1098
    if (ta === 5) { // binary                                                                                // 1099
      // Surprisingly, a small binary blob is always less than a large one in                                // 1100
      // Mongo.                                                                                              // 1101
      if (a.length !== b.length)                                                                             // 1102
        return a.length - b.length;                                                                          // 1103
      for (i = 0; i < a.length; i++) {                                                                       // 1104
        if (a[i] < b[i])                                                                                     // 1105
          return -1;                                                                                         // 1106
        if (a[i] > b[i])                                                                                     // 1107
          return 1;                                                                                          // 1108
      }                                                                                                      // 1109
      return 0;                                                                                              // 1110
    }                                                                                                        // 1111
    if (ta === 8) { // boolean                                                                               // 1112
      if (a) return b ? 0 : 1;                                                                               // 1113
      return b ? -1 : 0;                                                                                     // 1114
    }                                                                                                        // 1115
    if (ta === 10) // null                                                                                   // 1116
      return 0;                                                                                              // 1117
    if (ta === 11) // regexp                                                                                 // 1118
      throw Error("Sorting not supported on regular expression"); // XXX                                     // 1119
    // 13: javascript code                                                                                   // 1120
    // 14: symbol                                                                                            // 1121
    // 15: javascript code with scope                                                                        // 1122
    // 16: 32-bit integer                                                                                    // 1123
    // 17: timestamp                                                                                         // 1124
    // 18: 64-bit integer                                                                                    // 1125
    // 255: minkey                                                                                           // 1126
    // 127: maxkey                                                                                           // 1127
    if (ta === 13) // javascript code                                                                        // 1128
      throw Error("Sorting not supported on Javascript code"); // XXX                                        // 1129
    throw Error("Unknown type to sort");                                                                     // 1130
  }                                                                                                          // 1131
};                                                                                                           // 1132
                                                                                                             // 1133
// Oddball function used by upsert.                                                                          // 1134
LocalCollection._removeDollarOperators = function (selector) {                                               // 1135
  var selectorDoc = {};                                                                                      // 1136
  for (var k in selector)                                                                                    // 1137
    if (k.substr(0, 1) !== '$')                                                                              // 1138
      selectorDoc[k] = selector[k];                                                                          // 1139
  return selectorDoc;                                                                                        // 1140
};                                                                                                           // 1141
                                                                                                             // 1142
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/sort.js                                                                                //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
// Give a sort spec, which can be in any of these forms:                                                     // 1
//   {"key1": 1, "key2": -1}                                                                                 // 2
//   [["key1", "asc"], ["key2", "desc"]]                                                                     // 3
//   ["key1", ["key2", "desc"]]                                                                              // 4
//                                                                                                           // 5
// (.. with the first form being dependent on the key enumeration                                            // 6
// behavior of your javascript VM, which usually does what you mean in                                       // 7
// this case if the key names don't look like integers ..)                                                   // 8
//                                                                                                           // 9
// return a function that takes two objects, and returns -1 if the                                           // 10
// first object comes first in order, 1 if the second object comes                                           // 11
// first, or 0 if neither object comes before the other.                                                     // 12
                                                                                                             // 13
Minimongo.Sorter = function (spec, options) {                                                                // 14
  var self = this;                                                                                           // 15
  options = options || {};                                                                                   // 16
                                                                                                             // 17
  self._sortSpecParts = [];                                                                                  // 18
                                                                                                             // 19
  var addSpecPart = function (path, ascending) {                                                             // 20
    if (!path)                                                                                               // 21
      throw Error("sort keys must be non-empty");                                                            // 22
    if (path.charAt(0) === '$')                                                                              // 23
      throw Error("unsupported sort key: " + path);                                                          // 24
    self._sortSpecParts.push({                                                                               // 25
      path: path,                                                                                            // 26
      lookup: makeLookupFunction(path, {forSort: true}),                                                     // 27
      ascending: ascending                                                                                   // 28
    });                                                                                                      // 29
  };                                                                                                         // 30
                                                                                                             // 31
  if (spec instanceof Array) {                                                                               // 32
    for (var i = 0; i < spec.length; i++) {                                                                  // 33
      if (typeof spec[i] === "string") {                                                                     // 34
        addSpecPart(spec[i], true);                                                                          // 35
      } else {                                                                                               // 36
        addSpecPart(spec[i][0], spec[i][1] !== "desc");                                                      // 37
      }                                                                                                      // 38
    }                                                                                                        // 39
  } else if (typeof spec === "object") {                                                                     // 40
    _.each(spec, function (value, key) {                                                                     // 41
      addSpecPart(key, value >= 0);                                                                          // 42
    });                                                                                                      // 43
  } else {                                                                                                   // 44
    throw Error("Bad sort specification: " + JSON.stringify(spec));                                          // 45
  }                                                                                                          // 46
                                                                                                             // 47
  // To implement affectedByModifier, we piggy-back on top of Matcher's                                      // 48
  // affectedByModifier code; we create a selector that is affected by the same                              // 49
  // modifiers as this sort order. This is only implemented on the server.                                   // 50
  if (self.affectedByModifier) {                                                                             // 51
    var selector = {};                                                                                       // 52
    _.each(self._sortSpecParts, function (spec) {                                                            // 53
      selector[spec.path] = 1;                                                                               // 54
    });                                                                                                      // 55
    self._selectorForAffectedByModifier = new Minimongo.Matcher(selector);                                   // 56
  }                                                                                                          // 57
                                                                                                             // 58
  self._keyComparator = composeComparators(                                                                  // 59
    _.map(self._sortSpecParts, function (spec, i) {                                                          // 60
      return self._keyFieldComparator(i);                                                                    // 61
    }));                                                                                                     // 62
                                                                                                             // 63
  // If you specify a matcher for this Sorter, _keyFilter may be set to a                                    // 64
  // function which selects whether or not a given "sort key" (tuple of values                               // 65
  // for the different sort spec fields) is compatible with the selector.                                    // 66
  self._keyFilter = null;                                                                                    // 67
  options.matcher && self._useWithMatcher(options.matcher);                                                  // 68
};                                                                                                           // 69
                                                                                                             // 70
// In addition to these methods, sorter_project.js defines combineIntoProjection                             // 71
// on the server only.                                                                                       // 72
_.extend(Minimongo.Sorter.prototype, {                                                                       // 73
  getComparator: function (options) {                                                                        // 74
    var self = this;                                                                                         // 75
                                                                                                             // 76
    // If we have no distances, just use the comparator from the source                                      // 77
    // specification (which defaults to "everything is equal".                                               // 78
    if (!options || !options.distances) {                                                                    // 79
      return self._getBaseComparator();                                                                      // 80
    }                                                                                                        // 81
                                                                                                             // 82
    var distances = options.distances;                                                                       // 83
                                                                                                             // 84
    // Return a comparator which first tries the sort specification, and if that                             // 85
    // says "it's equal", breaks ties using $near distances.                                                 // 86
    return composeComparators([self._getBaseComparator(), function (a, b) {                                  // 87
      if (!distances.has(a._id))                                                                             // 88
        throw Error("Missing distance for " + a._id);                                                        // 89
      if (!distances.has(b._id))                                                                             // 90
        throw Error("Missing distance for " + b._id);                                                        // 91
      return distances.get(a._id) - distances.get(b._id);                                                    // 92
    }]);                                                                                                     // 93
  },                                                                                                         // 94
                                                                                                             // 95
  _getPaths: function () {                                                                                   // 96
    var self = this;                                                                                         // 97
    return _.pluck(self._sortSpecParts, 'path');                                                             // 98
  },                                                                                                         // 99
                                                                                                             // 100
  // Finds the minimum key from the doc, according to the sort specs.  (We say                               // 101
  // "minimum" here but this is with respect to the sort spec, so "descending"                               // 102
  // sort fields mean we're finding the max for that field.)                                                 // 103
  //                                                                                                         // 104
  // Note that this is NOT "find the minimum value of the first field, the                                   // 105
  // minimum value of the second field, etc"... it's "choose the                                             // 106
  // lexicographically minimum value of the key vector, allowing only keys which                             // 107
  // you can find along the same paths".  ie, for a doc {a: [{x: 0, y: 5}, {x:                               // 108
  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and                             // 109
  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.                                       // 110
  _getMinKeyFromDoc: function (doc) {                                                                        // 111
    var self = this;                                                                                         // 112
    var minKey = null;                                                                                       // 113
                                                                                                             // 114
    self._generateKeysFromDoc(doc, function (key) {                                                          // 115
      if (!self._keyCompatibleWithSelector(key))                                                             // 116
        return;                                                                                              // 117
                                                                                                             // 118
      if (minKey === null) {                                                                                 // 119
        minKey = key;                                                                                        // 120
        return;                                                                                              // 121
      }                                                                                                      // 122
      if (self._compareKeys(key, minKey) < 0) {                                                              // 123
        minKey = key;                                                                                        // 124
      }                                                                                                      // 125
    });                                                                                                      // 126
                                                                                                             // 127
    // This could happen if our key filter somehow filters out all the keys even                             // 128
    // though somehow the selector matches.                                                                  // 129
    if (minKey === null)                                                                                     // 130
      throw Error("sort selector found no keys in doc?");                                                    // 131
    return minKey;                                                                                           // 132
  },                                                                                                         // 133
                                                                                                             // 134
  _keyCompatibleWithSelector: function (key) {                                                               // 135
    var self = this;                                                                                         // 136
    return !self._keyFilter || self._keyFilter(key);                                                         // 137
  },                                                                                                         // 138
                                                                                                             // 139
  // Iterates over each possible "key" from doc (ie, over each branch), calling                              // 140
  // 'cb' with the key.                                                                                      // 141
  _generateKeysFromDoc: function (doc, cb) {                                                                 // 142
    var self = this;                                                                                         // 143
                                                                                                             // 144
    if (self._sortSpecParts.length === 0)                                                                    // 145
      throw new Error("can't generate keys without a spec");                                                 // 146
                                                                                                             // 147
    // maps index -> ({'' -> value} or {path -> value})                                                      // 148
    var valuesByIndexAndPath = [];                                                                           // 149
                                                                                                             // 150
    var pathFromIndices = function (indices) {                                                               // 151
      return indices.join(',') + ',';                                                                        // 152
    };                                                                                                       // 153
                                                                                                             // 154
    var knownPaths = null;                                                                                   // 155
                                                                                                             // 156
    _.each(self._sortSpecParts, function (spec, whichField) {                                                // 157
      // Expand any leaf arrays that we find, and ignore those arrays                                        // 158
      // themselves.  (We never sort based on an array itself.)                                              // 159
      var branches = expandArraysInBranches(spec.lookup(doc), true);                                         // 160
                                                                                                             // 161
      // If there are no values for a key (eg, key goes to an empty array),                                  // 162
      // pretend we found one null value.                                                                    // 163
      if (!branches.length)                                                                                  // 164
        branches = [{value: null}];                                                                          // 165
                                                                                                             // 166
      var usedPaths = false;                                                                                 // 167
      valuesByIndexAndPath[whichField] = {};                                                                 // 168
      _.each(branches, function (branch) {                                                                   // 169
        if (!branch.arrayIndices) {                                                                          // 170
          // If there are no array indices for a branch, then it must be the                                 // 171
          // only branch, because the only thing that produces multiple branches                             // 172
          // is the use of arrays.                                                                           // 173
          if (branches.length > 1)                                                                           // 174
            throw Error("multiple branches but no array used?");                                             // 175
          valuesByIndexAndPath[whichField][''] = branch.value;                                               // 176
          return;                                                                                            // 177
        }                                                                                                    // 178
                                                                                                             // 179
        usedPaths = true;                                                                                    // 180
        var path = pathFromIndices(branch.arrayIndices);                                                     // 181
        if (_.has(valuesByIndexAndPath[whichField], path))                                                   // 182
          throw Error("duplicate path: " + path);                                                            // 183
        valuesByIndexAndPath[whichField][path] = branch.value;                                               // 184
                                                                                                             // 185
        // If two sort fields both go into arrays, they have to go into the                                  // 186
        // exact same arrays and we have to find the same paths.  This is                                    // 187
        // roughly the same condition that makes MongoDB throw this strange                                  // 188
        // error message.  eg, the main thing is that if sort spec is {a: 1,                                 // 189
        // b:1} then a and b cannot both be arrays.                                                          // 190
        //                                                                                                   // 191
        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'                                // 192
        // and 'a.x.y' are both arrays, but we don't allow this for now.                                     // 193
        // #NestedArraySort                                                                                  // 194
        // XXX achieve full compatibility here                                                               // 195
        if (knownPaths && !_.has(knownPaths, path)) {                                                        // 196
          throw Error("cannot index parallel arrays");                                                       // 197
        }                                                                                                    // 198
      });                                                                                                    // 199
                                                                                                             // 200
      if (knownPaths) {                                                                                      // 201
        // Similarly to above, paths must match everywhere, unless this is a                                 // 202
        // non-array field.                                                                                  // 203
        if (!_.has(valuesByIndexAndPath[whichField], '') &&                                                  // 204
            _.size(knownPaths) !== _.size(valuesByIndexAndPath[whichField])) {                               // 205
          throw Error("cannot index parallel arrays!");                                                      // 206
        }                                                                                                    // 207
      } else if (usedPaths) {                                                                                // 208
        knownPaths = {};                                                                                     // 209
        _.each(valuesByIndexAndPath[whichField], function (x, path) {                                        // 210
          knownPaths[path] = true;                                                                           // 211
        });                                                                                                  // 212
      }                                                                                                      // 213
    });                                                                                                      // 214
                                                                                                             // 215
    if (!knownPaths) {                                                                                       // 216
      // Easy case: no use of arrays.                                                                        // 217
      var soleKey = _.map(valuesByIndexAndPath, function (values) {                                          // 218
        if (!_.has(values, ''))                                                                              // 219
          throw Error("no value in sole key case?");                                                         // 220
        return values[''];                                                                                   // 221
      });                                                                                                    // 222
      cb(soleKey);                                                                                           // 223
      return;                                                                                                // 224
    }                                                                                                        // 225
                                                                                                             // 226
    _.each(knownPaths, function (x, path) {                                                                  // 227
      var key = _.map(valuesByIndexAndPath, function (values) {                                              // 228
        if (_.has(values, ''))                                                                               // 229
          return values[''];                                                                                 // 230
        if (!_.has(values, path))                                                                            // 231
          throw Error("missing path?");                                                                      // 232
        return values[path];                                                                                 // 233
      });                                                                                                    // 234
      cb(key);                                                                                               // 235
    });                                                                                                      // 236
  },                                                                                                         // 237
                                                                                                             // 238
  // Takes in two keys: arrays whose lengths match the number of spec                                        // 239
  // parts. Returns negative, 0, or positive based on using the sort spec to                                 // 240
  // compare fields.                                                                                         // 241
  _compareKeys: function (key1, key2) {                                                                      // 242
    var self = this;                                                                                         // 243
    if (key1.length !== self._sortSpecParts.length ||                                                        // 244
        key2.length !== self._sortSpecParts.length) {                                                        // 245
      throw Error("Key has wrong length");                                                                   // 246
    }                                                                                                        // 247
                                                                                                             // 248
    return self._keyComparator(key1, key2);                                                                  // 249
  },                                                                                                         // 250
                                                                                                             // 251
  // Given an index 'i', returns a comparator that compares two key arrays based                             // 252
  // on field 'i'.                                                                                           // 253
  _keyFieldComparator: function (i) {                                                                        // 254
    var self = this;                                                                                         // 255
    var invert = !self._sortSpecParts[i].ascending;                                                          // 256
    return function (key1, key2) {                                                                           // 257
      var compare = LocalCollection._f._cmp(key1[i], key2[i]);                                               // 258
      if (invert)                                                                                            // 259
        compare = -compare;                                                                                  // 260
      return compare;                                                                                        // 261
    };                                                                                                       // 262
  },                                                                                                         // 263
                                                                                                             // 264
  // Returns a comparator that represents the sort specification (but not                                    // 265
  // including a possible geoquery distance tie-breaker).                                                    // 266
  _getBaseComparator: function () {                                                                          // 267
    var self = this;                                                                                         // 268
                                                                                                             // 269
    // If we're only sorting on geoquery distance and no specs, just say                                     // 270
    // everything is equal.                                                                                  // 271
    if (!self._sortSpecParts.length) {                                                                       // 272
      return function (doc1, doc2) {                                                                         // 273
        return 0;                                                                                            // 274
      };                                                                                                     // 275
    }                                                                                                        // 276
                                                                                                             // 277
    return function (doc1, doc2) {                                                                           // 278
      var key1 = self._getMinKeyFromDoc(doc1);                                                               // 279
      var key2 = self._getMinKeyFromDoc(doc2);                                                               // 280
      return self._compareKeys(key1, key2);                                                                  // 281
    };                                                                                                       // 282
  },                                                                                                         // 283
                                                                                                             // 284
  // In MongoDB, if you have documents                                                                       // 285
  //    {_id: 'x', a: [1, 10]} and                                                                           // 286
  //    {_id: 'y', a: [5, 15]},                                                                              // 287
  // then C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).                                     // 288
  // But  C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not                                  // 289
  // match the selector, and 5 comes before 10).                                                             // 290
  //                                                                                                         // 291
  // The way this works is pretty subtle!  For example, if the documents                                     // 292
  // are instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and                                                       // 293
  //             {_id: 'y', a: [{x: 5}, {x: 15}]}),                                                          // 294
  // then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and                                                  // 295
  //      C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})                                       // 296
  // both follow this rule (y before x).  (ie, you do have to apply this                                     // 297
  // through $elemMatch.)                                                                                    // 298
  //                                                                                                         // 299
  // So if you pass a matcher to this sorter's constructor, we will attempt to                               // 300
  // skip sort keys that don't match the selector. The logic here is pretty                                  // 301
  // subtle and undocumented; we've gotten as close as we can figure out based                               // 302
  // on our understanding of Mongo's behavior.                                                               // 303
  _useWithMatcher: function (matcher) {                                                                      // 304
    var self = this;                                                                                         // 305
                                                                                                             // 306
    if (self._keyFilter)                                                                                     // 307
      throw Error("called _useWithMatcher twice?");                                                          // 308
                                                                                                             // 309
    // If we are only sorting by distance, then we're not going to bother to                                 // 310
    // build a key filter.                                                                                   // 311
    // XXX figure out how geoqueries interact with this stuff                                                // 312
    if (_.isEmpty(self._sortSpecParts))                                                                      // 313
      return;                                                                                                // 314
                                                                                                             // 315
    var selector = matcher._selector;                                                                        // 316
                                                                                                             // 317
    // If the user just passed a literal function to find(), then we can't get a                             // 318
    // key filter from it.                                                                                   // 319
    if (selector instanceof Function)                                                                        // 320
      return;                                                                                                // 321
                                                                                                             // 322
    var constraintsByPath = {};                                                                              // 323
    _.each(self._sortSpecParts, function (spec, i) {                                                         // 324
      constraintsByPath[spec.path] = [];                                                                     // 325
    });                                                                                                      // 326
                                                                                                             // 327
    _.each(selector, function (subSelector, key) {                                                           // 328
      // XXX support $and and $or                                                                            // 329
                                                                                                             // 330
      var constraints = constraintsByPath[key];                                                              // 331
      if (!constraints)                                                                                      // 332
        return;                                                                                              // 333
                                                                                                             // 334
      // XXX it looks like the real MongoDB implementation isn't "does the                                   // 335
      // regexp match" but "does the value fall into a range named by the                                    // 336
      // literal prefix of the regexp", ie "foo" in /^foo(bar|baz)+/  But                                    // 337
      // "does the regexp match" is a good approximation.                                                    // 338
      if (subSelector instanceof RegExp) {                                                                   // 339
        // As far as we can tell, using either of the options that both we and                               // 340
        // MongoDB support ('i' and 'm') disables use of the key filter. This                                // 341
        // makes sense: MongoDB mostly appears to be calculating ranges of an                                // 342
        // index to use, which means it only cares about regexps that match                                  // 343
        // one range (with a literal prefix), and both 'i' and 'm' prevent the                               // 344
        // literal prefix of the regexp from actually meaning one range.                                     // 345
        if (subSelector.ignoreCase || subSelector.multiline)                                                 // 346
          return;                                                                                            // 347
        constraints.push(regexpElementMatcher(subSelector));                                                 // 348
        return;                                                                                              // 349
      }                                                                                                      // 350
                                                                                                             // 351
      if (isOperatorObject(subSelector)) {                                                                   // 352
        _.each(subSelector, function (operand, operator) {                                                   // 353
          if (_.contains(['$lt', '$lte', '$gt', '$gte'], operator)) {                                        // 354
            // XXX this depends on us knowing that these operators don't use any                             // 355
            // of the arguments to compileElementSelector other than operand.                                // 356
            constraints.push(                                                                                // 357
              ELEMENT_OPERATORS[operator].compileElementSelector(operand));                                  // 358
          }                                                                                                  // 359
                                                                                                             // 360
          // See comments in the RegExp block above.                                                         // 361
          if (operator === '$regex' && !subSelector.$options) {                                              // 362
            constraints.push(                                                                                // 363
              ELEMENT_OPERATORS.$regex.compileElementSelector(                                               // 364
                operand, subSelector));                                                                      // 365
          }                                                                                                  // 366
                                                                                                             // 367
          // XXX support {$exists: true}, $mod, $type, $in, $elemMatch                                       // 368
        });                                                                                                  // 369
        return;                                                                                              // 370
      }                                                                                                      // 371
                                                                                                             // 372
      // OK, it's an equality thing.                                                                         // 373
      constraints.push(equalityElementMatcher(subSelector));                                                 // 374
    });                                                                                                      // 375
                                                                                                             // 376
    // It appears that the first sort field is treated differently from the                                  // 377
    // others; we shouldn't create a key filter unless the first sort field is                               // 378
    // restricted, though after that point we can restrict the other sort fields                             // 379
    // or not as we wish.                                                                                    // 380
    if (_.isEmpty(constraintsByPath[self._sortSpecParts[0].path]))                                           // 381
      return;                                                                                                // 382
                                                                                                             // 383
    self._keyFilter = function (key) {                                                                       // 384
      return _.all(self._sortSpecParts, function (specPart, index) {                                         // 385
        return _.all(constraintsByPath[specPart.path], function (f) {                                        // 386
          return f(key[index]);                                                                              // 387
        });                                                                                                  // 388
      });                                                                                                    // 389
    };                                                                                                       // 390
  }                                                                                                          // 391
});                                                                                                          // 392
                                                                                                             // 393
// Given an array of comparators                                                                             // 394
// (functions (a,b)->(negative or positive or zero)), returns a single                                       // 395
// comparator which uses each comparator in order and returns the first                                      // 396
// non-zero value.                                                                                           // 397
var composeComparators = function (comparatorArray) {                                                        // 398
  return function (a, b) {                                                                                   // 399
    for (var i = 0; i < comparatorArray.length; ++i) {                                                       // 400
      var compare = comparatorArray[i](a, b);                                                                // 401
      if (compare !== 0)                                                                                     // 402
        return compare;                                                                                      // 403
    }                                                                                                        // 404
    return 0;                                                                                                // 405
  };                                                                                                         // 406
};                                                                                                           // 407
                                                                                                             // 408
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/projection.js                                                                          //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
// Knows how to compile a fields projection to a predicate function.                                         // 1
// @returns - Function: a closure that filters out an object according to the                                // 2
//            fields projection rules:                                                                       // 3
//            @param obj - Object: MongoDB-styled document                                                   // 4
//            @returns - Object: a document with the fields filtered out                                     // 5
//                       according to projection rules. Doesn't retain subfields                             // 6
//                       of passed argument.                                                                 // 7
LocalCollection._compileProjection = function (fields) {                                                     // 8
  LocalCollection._checkSupportedProjection(fields);                                                         // 9
                                                                                                             // 10
  var _idProjection = _.isUndefined(fields._id) ? true : fields._id;                                         // 11
  var details = projectionDetails(fields);                                                                   // 12
                                                                                                             // 13
  // returns transformed doc according to ruleTree                                                           // 14
  var transform = function (doc, ruleTree) {                                                                 // 15
    // Special case for "sets"                                                                               // 16
    if (_.isArray(doc))                                                                                      // 17
      return _.map(doc, function (subdoc) { return transform(subdoc, ruleTree); });                          // 18
                                                                                                             // 19
    var res = details.including ? {} : EJSON.clone(doc);                                                     // 20
    _.each(ruleTree, function (rule, key) {                                                                  // 21
      if (!_.has(doc, key))                                                                                  // 22
        return;                                                                                              // 23
      if (_.isObject(rule)) {                                                                                // 24
        // For sub-objects/subsets we branch                                                                 // 25
        if (_.isObject(doc[key]))                                                                            // 26
          res[key] = transform(doc[key], rule);                                                              // 27
        // Otherwise we don't even touch this subfield                                                       // 28
      } else if (details.including)                                                                          // 29
        res[key] = EJSON.clone(doc[key]);                                                                    // 30
      else                                                                                                   // 31
        delete res[key];                                                                                     // 32
    });                                                                                                      // 33
                                                                                                             // 34
    return res;                                                                                              // 35
  };                                                                                                         // 36
                                                                                                             // 37
  return function (obj) {                                                                                    // 38
    var res = transform(obj, details.tree);                                                                  // 39
                                                                                                             // 40
    if (_idProjection && _.has(obj, '_id'))                                                                  // 41
      res._id = obj._id;                                                                                     // 42
    if (!_idProjection && _.has(res, '_id'))                                                                 // 43
      delete res._id;                                                                                        // 44
    return res;                                                                                              // 45
  };                                                                                                         // 46
};                                                                                                           // 47
                                                                                                             // 48
// Traverses the keys of passed projection and constructs a tree where all                                   // 49
// leaves are either all True or all False                                                                   // 50
// @returns Object:                                                                                          // 51
//  - tree - Object - tree representation of keys involved in projection                                     // 52
//  (exception for '_id' as it is a special case handled separately)                                         // 53
//  - including - Boolean - "take only certain fields" type of projection                                    // 54
projectionDetails = function (fields) {                                                                      // 55
  // Find the non-_id keys (_id is handled specially because it is included unless                           // 56
  // explicitly excluded). Sort the keys, so that our code to detect overlaps                                // 57
  // like 'foo' and 'foo.bar' can assume that 'foo' comes first.                                             // 58
  var fieldsKeys = _.keys(fields).sort();                                                                    // 59
                                                                                                             // 60
  // If there are other rules other than '_id', treat '_id' differently in a                                 // 61
  // separate case. If '_id' is the only rule, use it to understand if it is                                 // 62
  // including/excluding projection.                                                                         // 63
  if (fieldsKeys.length > 0 && !(fieldsKeys.length === 1 && fieldsKeys[0] === '_id'))                        // 64
    fieldsKeys = _.reject(fieldsKeys, function (key) { return key === '_id'; });                             // 65
                                                                                                             // 66
  var including = null; // Unknown                                                                           // 67
                                                                                                             // 68
  _.each(fieldsKeys, function (keyPath) {                                                                    // 69
    var rule = !!fields[keyPath];                                                                            // 70
    if (including === null)                                                                                  // 71
      including = rule;                                                                                      // 72
    if (including !== rule)                                                                                  // 73
      // This error message is copies from MongoDB shell                                                     // 74
      throw MinimongoError("You cannot currently mix including and excluding fields.");                      // 75
  });                                                                                                        // 76
                                                                                                             // 77
                                                                                                             // 78
  var projectionRulesTree = pathsToTree(                                                                     // 79
    fieldsKeys,                                                                                              // 80
    function (path) { return including; },                                                                   // 81
    function (node, path, fullPath) {                                                                        // 82
      // Check passed projection fields' keys: If you have two rules such as                                 // 83
      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If                                  // 84
      // that happens, there is a probability you are doing something wrong,                                 // 85
      // framework should notify you about such mistake earlier on cursor                                    // 86
      // compilation step than later during runtime.  Note, that real mongo                                  // 87
      // doesn't do anything about it and the later rule appears in projection                               // 88
      // project, more priority it takes.                                                                    // 89
      //                                                                                                     // 90
      // Example, assume following in mongo shell:                                                           // 91
      // > db.coll.insert({ a: { b: 23, c: 44 } })                                                           // 92
      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })                                                            // 93
      // { "_id" : ObjectId("520bfe456024608e8ef24af3"), "a" : { "b" : 23 } }                                // 94
      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })                                                            // 95
      // { "_id" : ObjectId("520bfe456024608e8ef24af3"), "a" : { "b" : 23, "c" : 44 } }                      // 96
      //                                                                                                     // 97
      // Note, how second time the return set of keys is different.                                          // 98
                                                                                                             // 99
      var currentPath = fullPath;                                                                            // 100
      var anotherPath = path;                                                                                // 101
      throw MinimongoError("both " + currentPath + " and " + anotherPath +                                   // 102
                           " found in fields option, using both of them may trigger " +                      // 103
                           "unexpected behavior. Did you mean to use only one of them?");                    // 104
    });                                                                                                      // 105
                                                                                                             // 106
  return {                                                                                                   // 107
    tree: projectionRulesTree,                                                                               // 108
    including: including                                                                                     // 109
  };                                                                                                         // 110
};                                                                                                           // 111
                                                                                                             // 112
// paths - Array: list of mongo style paths                                                                  // 113
// newLeafFn - Function: of form function(path) should return a scalar value to                              // 114
//                       put into list created for that path                                                 // 115
// conflictFn - Function: of form function(node, path, fullPath) is called                                   // 116
//                        when building a tree path for 'fullPath' node on                                   // 117
//                        'path' was already a leaf with a value. Must return a                              // 118
//                        conflict resolution.                                                               // 119
// initial tree - Optional Object: starting tree.                                                            // 120
// @returns - Object: tree represented as a set of nested objects                                            // 121
pathsToTree = function (paths, newLeafFn, conflictFn, tree) {                                                // 122
  tree = tree || {};                                                                                         // 123
  _.each(paths, function (keyPath) {                                                                         // 124
    var treePos = tree;                                                                                      // 125
    var pathArr = keyPath.split('.');                                                                        // 126
                                                                                                             // 127
    // use _.all just for iteration with break                                                               // 128
    var success = _.all(pathArr.slice(0, -1), function (key, idx) {                                          // 129
      if (!_.has(treePos, key))                                                                              // 130
        treePos[key] = {};                                                                                   // 131
      else if (!_.isObject(treePos[key])) {                                                                  // 132
        treePos[key] = conflictFn(treePos[key],                                                              // 133
                                  pathArr.slice(0, idx + 1).join('.'),                                       // 134
                                  keyPath);                                                                  // 135
        // break out of loop if we are failing for this path                                                 // 136
        if (!_.isObject(treePos[key]))                                                                       // 137
          return false;                                                                                      // 138
      }                                                                                                      // 139
                                                                                                             // 140
      treePos = treePos[key];                                                                                // 141
      return true;                                                                                           // 142
    });                                                                                                      // 143
                                                                                                             // 144
    if (success) {                                                                                           // 145
      var lastKey = _.last(pathArr);                                                                         // 146
      if (!_.has(treePos, lastKey))                                                                          // 147
        treePos[lastKey] = newLeafFn(keyPath);                                                               // 148
      else                                                                                                   // 149
        treePos[lastKey] = conflictFn(treePos[lastKey], keyPath, keyPath);                                   // 150
    }                                                                                                        // 151
  });                                                                                                        // 152
                                                                                                             // 153
  return tree;                                                                                               // 154
};                                                                                                           // 155
                                                                                                             // 156
LocalCollection._checkSupportedProjection = function (fields) {                                              // 157
  if (!_.isObject(fields) || _.isArray(fields))                                                              // 158
    throw MinimongoError("fields option must be an object");                                                 // 159
                                                                                                             // 160
  _.each(fields, function (val, keyPath) {                                                                   // 161
    if (_.contains(keyPath.split('.'), '$'))                                                                 // 162
      throw MinimongoError("Minimongo doesn't support $ operator in projections yet.");                      // 163
    if (_.indexOf([1, 0, true, false], val) === -1)                                                          // 164
      throw MinimongoError("Projection values should be one of 1, 0, true, or false");                       // 165
  });                                                                                                        // 166
};                                                                                                           // 167
                                                                                                             // 168
                                                                                                             // 169
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/modify.js                                                                              //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
// XXX need a strategy for passing the binding of $ into this                                                // 1
// function, from the compiled selector                                                                      // 2
//                                                                                                           // 3
// maybe just {key.up.to.just.before.dollarsign: array_index}                                                // 4
//                                                                                                           // 5
// XXX atomicity: if one modification fails, do we roll back the whole                                       // 6
// change?                                                                                                   // 7
//                                                                                                           // 8
// options:                                                                                                  // 9
//   - isInsert is set when _modify is being called to compute the document to                               // 10
//     insert as part of an upsert operation. We use this primarily to figure                                // 11
//     out when to set the fields in $setOnInsert, if present.                                               // 12
LocalCollection._modify = function (doc, mod, options) {                                                     // 13
  options = options || {};                                                                                   // 14
  if (!isPlainObject(mod))                                                                                   // 15
    throw MinimongoError("Modifier must be an object");                                                      // 16
  var isModifier = isOperatorObject(mod);                                                                    // 17
                                                                                                             // 18
  var newDoc;                                                                                                // 19
                                                                                                             // 20
  if (!isModifier) {                                                                                         // 21
    if (mod._id && !EJSON.equals(doc._id, mod._id))                                                          // 22
      throw MinimongoError("Cannot change the _id of a document");                                           // 23
                                                                                                             // 24
    // replace the whole document                                                                            // 25
    for (var k in mod) {                                                                                     // 26
      if (/\./.test(k))                                                                                      // 27
        throw MinimongoError(                                                                                // 28
          "When replacing document, field name may not contain '.'");                                        // 29
    }                                                                                                        // 30
    newDoc = mod;                                                                                            // 31
  } else {                                                                                                   // 32
    // apply modifiers to the doc.                                                                           // 33
    newDoc = EJSON.clone(doc);                                                                               // 34
                                                                                                             // 35
    _.each(mod, function (operand, op) {                                                                     // 36
      var modFunc = MODIFIERS[op];                                                                           // 37
      // Treat $setOnInsert as $set if this is an insert.                                                    // 38
      if (options.isInsert && op === '$setOnInsert')                                                         // 39
        modFunc = MODIFIERS['$set'];                                                                         // 40
      if (!modFunc)                                                                                          // 41
        throw MinimongoError("Invalid modifier specified " + op);                                            // 42
      _.each(operand, function (arg, keypath) {                                                              // 43
        if (keypath === '') {                                                                                // 44
          throw MinimongoError("An empty update path is not valid.");                                        // 45
        }                                                                                                    // 46
                                                                                                             // 47
        if (keypath === '_id') {                                                                             // 48
          throw MinimongoError("Mod on _id not allowed");                                                    // 49
        }                                                                                                    // 50
                                                                                                             // 51
        var keyparts = keypath.split('.');                                                                   // 52
                                                                                                             // 53
        if (! _.all(keyparts, _.identity)) {                                                                 // 54
          throw MinimongoError(                                                                              // 55
            "The update path '" + keypath +                                                                  // 56
              "' contains an empty field name, which is not allowed.");                                      // 57
        }                                                                                                    // 58
                                                                                                             // 59
        var noCreate = _.has(NO_CREATE_MODIFIERS, op);                                                       // 60
        var forbidArray = (op === "$rename");                                                                // 61
        var target = findModTarget(newDoc, keyparts, {                                                       // 62
          noCreate: NO_CREATE_MODIFIERS[op],                                                                 // 63
          forbidArray: (op === "$rename"),                                                                   // 64
          arrayIndices: options.arrayIndices                                                                 // 65
        });                                                                                                  // 66
        var field = keyparts.pop();                                                                          // 67
        modFunc(target, field, arg, keypath, newDoc);                                                        // 68
      });                                                                                                    // 69
    });                                                                                                      // 70
  }                                                                                                          // 71
                                                                                                             // 72
  // move new document into place.                                                                           // 73
  _.each(_.keys(doc), function (k) {                                                                         // 74
    // Note: this used to be for (var k in doc) however, this does not                                       // 75
    // work right in Opera. Deleting from a doc while iterating over it                                      // 76
    // would sometimes cause opera to skip some keys.                                                        // 77
    if (k !== '_id')                                                                                         // 78
      delete doc[k];                                                                                         // 79
  });                                                                                                        // 80
  _.each(newDoc, function (v, k) {                                                                           // 81
    doc[k] = v;                                                                                              // 82
  });                                                                                                        // 83
};                                                                                                           // 84
                                                                                                             // 85
// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],                                       // 86
// and then you would operate on the 'e' property of the returned                                            // 87
// object.                                                                                                   // 88
//                                                                                                           // 89
// if options.noCreate is falsey, creates intermediate levels of                                             // 90
// structure as necessary, like mkdir -p (and raises an exception if                                         // 91
// that would mean giving a non-numeric property to an array.) if                                            // 92
// options.noCreate is true, return undefined instead.                                                       // 93
//                                                                                                           // 94
// may modify the last element of keyparts to signal to the caller that it needs                             // 95
// to use a different value to index into the returned object (for example,                                  // 96
// ['a', '01'] -> ['a', 1]).                                                                                 // 97
//                                                                                                           // 98
// if forbidArray is true, return null if the keypath goes through an array.                                 // 99
//                                                                                                           // 100
// if options.arrayIndices is set, use its first element for the (first) '$' in                              // 101
// the path.                                                                                                 // 102
var findModTarget = function (doc, keyparts, options) {                                                      // 103
  options = options || {};                                                                                   // 104
  var usedArrayIndex = false;                                                                                // 105
  for (var i = 0; i < keyparts.length; i++) {                                                                // 106
    var last = (i === keyparts.length - 1);                                                                  // 107
    var keypart = keyparts[i];                                                                               // 108
    var indexable = isIndexable(doc);                                                                        // 109
    if (!indexable) {                                                                                        // 110
      if (options.noCreate)                                                                                  // 111
        return undefined;                                                                                    // 112
      var e = MinimongoError(                                                                                // 113
        "cannot use the part '" + keypart + "' to traverse " + doc);                                         // 114
      e.setPropertyError = true;                                                                             // 115
      throw e;                                                                                               // 116
    }                                                                                                        // 117
    if (doc instanceof Array) {                                                                              // 118
      if (options.forbidArray)                                                                               // 119
        return null;                                                                                         // 120
      if (keypart === '$') {                                                                                 // 121
        if (usedArrayIndex)                                                                                  // 122
          throw MinimongoError("Too many positional (i.e. '$') elements");                                   // 123
        if (!options.arrayIndices || !options.arrayIndices.length) {                                         // 124
          throw MinimongoError("The positional operator did not find the " +                                 // 125
                               "match needed from the query");                                               // 126
        }                                                                                                    // 127
        keypart = options.arrayIndices[0];                                                                   // 128
        usedArrayIndex = true;                                                                               // 129
      } else if (isNumericKey(keypart)) {                                                                    // 130
        keypart = parseInt(keypart);                                                                         // 131
      } else {                                                                                               // 132
        if (options.noCreate)                                                                                // 133
          return undefined;                                                                                  // 134
        throw MinimongoError(                                                                                // 135
          "can't append to array using string field name ["                                                  // 136
                    + keypart + "]");                                                                        // 137
      }                                                                                                      // 138
      if (last)                                                                                              // 139
        // handle 'a.01'                                                                                     // 140
        keyparts[i] = keypart;                                                                               // 141
      if (options.noCreate && keypart >= doc.length)                                                         // 142
        return undefined;                                                                                    // 143
      while (doc.length < keypart)                                                                           // 144
        doc.push(null);                                                                                      // 145
      if (!last) {                                                                                           // 146
        if (doc.length === keypart)                                                                          // 147
          doc.push({});                                                                                      // 148
        else if (typeof doc[keypart] !== "object")                                                           // 149
          throw MinimongoError("can't modify field '" + keyparts[i + 1] +                                    // 150
                      "' of list value " + JSON.stringify(doc[keypart]));                                    // 151
      }                                                                                                      // 152
    } else {                                                                                                 // 153
      if (keypart.length && keypart.substr(0, 1) === '$')                                                    // 154
        throw MinimongoError("can't set field named " + keypart);                                            // 155
      if (!(keypart in doc)) {                                                                               // 156
        if (options.noCreate)                                                                                // 157
          return undefined;                                                                                  // 158
        if (!last)                                                                                           // 159
          doc[keypart] = {};                                                                                 // 160
      }                                                                                                      // 161
    }                                                                                                        // 162
                                                                                                             // 163
    if (last)                                                                                                // 164
      return doc;                                                                                            // 165
    doc = doc[keypart];                                                                                      // 166
  }                                                                                                          // 167
                                                                                                             // 168
  // notreached                                                                                              // 169
};                                                                                                           // 170
                                                                                                             // 171
var NO_CREATE_MODIFIERS = {                                                                                  // 172
  $unset: true,                                                                                              // 173
  $pop: true,                                                                                                // 174
  $rename: true,                                                                                             // 175
  $pull: true,                                                                                               // 176
  $pullAll: true                                                                                             // 177
};                                                                                                           // 178
                                                                                                             // 179
var MODIFIERS = {                                                                                            // 180
  $inc: function (target, field, arg) {                                                                      // 181
    if (typeof arg !== "number")                                                                             // 182
      throw MinimongoError("Modifier $inc allowed for numbers only");                                        // 183
    if (field in target) {                                                                                   // 184
      if (typeof target[field] !== "number")                                                                 // 185
        throw MinimongoError("Cannot apply $inc modifier to non-number");                                    // 186
      target[field] += arg;                                                                                  // 187
    } else {                                                                                                 // 188
      target[field] = arg;                                                                                   // 189
    }                                                                                                        // 190
  },                                                                                                         // 191
  $set: function (target, field, arg) {                                                                      // 192
    if (!_.isObject(target)) { // not an array or an object                                                  // 193
      var e = MinimongoError("Cannot set property on non-object field");                                     // 194
      e.setPropertyError = true;                                                                             // 195
      throw e;                                                                                               // 196
    }                                                                                                        // 197
    if (target === null) {                                                                                   // 198
      var e = MinimongoError("Cannot set property on null");                                                 // 199
      e.setPropertyError = true;                                                                             // 200
      throw e;                                                                                               // 201
    }                                                                                                        // 202
    target[field] = EJSON.clone(arg);                                                                        // 203
  },                                                                                                         // 204
  $setOnInsert: function (target, field, arg) {                                                              // 205
    // converted to `$set` in `_modify`                                                                      // 206
  },                                                                                                         // 207
  $unset: function (target, field, arg) {                                                                    // 208
    if (target !== undefined) {                                                                              // 209
      if (target instanceof Array) {                                                                         // 210
        if (field in target)                                                                                 // 211
          target[field] = null;                                                                              // 212
      } else                                                                                                 // 213
        delete target[field];                                                                                // 214
    }                                                                                                        // 215
  },                                                                                                         // 216
  $push: function (target, field, arg) {                                                                     // 217
    if (target[field] === undefined)                                                                         // 218
      target[field] = [];                                                                                    // 219
    if (!(target[field] instanceof Array))                                                                   // 220
      throw MinimongoError("Cannot apply $push modifier to non-array");                                      // 221
                                                                                                             // 222
    if (!(arg && arg.$each)) {                                                                               // 223
      // Simple mode: not $each                                                                              // 224
      target[field].push(EJSON.clone(arg));                                                                  // 225
      return;                                                                                                // 226
    }                                                                                                        // 227
                                                                                                             // 228
    // Fancy mode: $each (and maybe $slice and $sort)                                                        // 229
    var toPush = arg.$each;                                                                                  // 230
    if (!(toPush instanceof Array))                                                                          // 231
      throw MinimongoError("$each must be an array");                                                        // 232
                                                                                                             // 233
    // Parse $slice.                                                                                         // 234
    var slice = undefined;                                                                                   // 235
    if ('$slice' in arg) {                                                                                   // 236
      if (typeof arg.$slice !== "number")                                                                    // 237
        throw MinimongoError("$slice must be a numeric value");                                              // 238
      // XXX should check to make sure integer                                                               // 239
      if (arg.$slice > 0)                                                                                    // 240
        throw MinimongoError("$slice in $push must be zero or negative");                                    // 241
      slice = arg.$slice;                                                                                    // 242
    }                                                                                                        // 243
                                                                                                             // 244
    // Parse $sort.                                                                                          // 245
    var sortFunction = undefined;                                                                            // 246
    if (arg.$sort) {                                                                                         // 247
      if (slice === undefined)                                                                               // 248
        throw MinimongoError("$sort requires $slice to be present");                                         // 249
      // XXX this allows us to use a $sort whose value is an array, but that's                               // 250
      // actually an extension of the Node driver, so it won't work                                          // 251
      // server-side. Could be confusing!                                                                    // 252
      // XXX is it correct that we don't do geo-stuff here?                                                  // 253
      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();                                        // 254
      for (var i = 0; i < toPush.length; i++) {                                                              // 255
        if (LocalCollection._f._type(toPush[i]) !== 3) {                                                     // 256
          throw MinimongoError("$push like modifiers using $sort " +                                         // 257
                      "require all elements to be objects");                                                 // 258
        }                                                                                                    // 259
      }                                                                                                      // 260
    }                                                                                                        // 261
                                                                                                             // 262
    // Actually push.                                                                                        // 263
    for (var j = 0; j < toPush.length; j++)                                                                  // 264
      target[field].push(EJSON.clone(toPush[j]));                                                            // 265
                                                                                                             // 266
    // Actually sort.                                                                                        // 267
    if (sortFunction)                                                                                        // 268
      target[field].sort(sortFunction);                                                                      // 269
                                                                                                             // 270
    // Actually slice.                                                                                       // 271
    if (slice !== undefined) {                                                                               // 272
      if (slice === 0)                                                                                       // 273
        target[field] = [];  // differs from Array.slice!                                                    // 274
      else                                                                                                   // 275
        target[field] = target[field].slice(slice);                                                          // 276
    }                                                                                                        // 277
  },                                                                                                         // 278
  $pushAll: function (target, field, arg) {                                                                  // 279
    if (!(typeof arg === "object" && arg instanceof Array))                                                  // 280
      throw MinimongoError("Modifier $pushAll/pullAll allowed for arrays only");                             // 281
    var x = target[field];                                                                                   // 282
    if (x === undefined)                                                                                     // 283
      target[field] = arg;                                                                                   // 284
    else if (!(x instanceof Array))                                                                          // 285
      throw MinimongoError("Cannot apply $pushAll modifier to non-array");                                   // 286
    else {                                                                                                   // 287
      for (var i = 0; i < arg.length; i++)                                                                   // 288
        x.push(arg[i]);                                                                                      // 289
    }                                                                                                        // 290
  },                                                                                                         // 291
  $addToSet: function (target, field, arg) {                                                                 // 292
    var isEach = false;                                                                                      // 293
    if (typeof arg === "object") {                                                                           // 294
      //check if first key is '$each'                                                                        // 295
      for (var k in arg) {                                                                                   // 296
        if (k === "$each")                                                                                   // 297
          isEach = true;                                                                                     // 298
        break;                                                                                               // 299
      }                                                                                                      // 300
    }                                                                                                        // 301
    var values = isEach ? arg["$each"] : [arg];                                                              // 302
    var x = target[field];                                                                                   // 303
    if (x === undefined)                                                                                     // 304
      target[field] = values;                                                                                // 305
    else if (!(x instanceof Array))                                                                          // 306
      throw MinimongoError("Cannot apply $addToSet modifier to non-array");                                  // 307
    else {                                                                                                   // 308
      _.each(values, function (value) {                                                                      // 309
        for (var i = 0; i < x.length; i++)                                                                   // 310
          if (LocalCollection._f._equal(value, x[i]))                                                        // 311
            return;                                                                                          // 312
        x.push(EJSON.clone(value));                                                                          // 313
      });                                                                                                    // 314
    }                                                                                                        // 315
  },                                                                                                         // 316
  $pop: function (target, field, arg) {                                                                      // 317
    if (target === undefined)                                                                                // 318
      return;                                                                                                // 319
    var x = target[field];                                                                                   // 320
    if (x === undefined)                                                                                     // 321
      return;                                                                                                // 322
    else if (!(x instanceof Array))                                                                          // 323
      throw MinimongoError("Cannot apply $pop modifier to non-array");                                       // 324
    else {                                                                                                   // 325
      if (typeof arg === 'number' && arg < 0)                                                                // 326
        x.splice(0, 1);                                                                                      // 327
      else                                                                                                   // 328
        x.pop();                                                                                             // 329
    }                                                                                                        // 330
  },                                                                                                         // 331
  $pull: function (target, field, arg) {                                                                     // 332
    if (target === undefined)                                                                                // 333
      return;                                                                                                // 334
    var x = target[field];                                                                                   // 335
    if (x === undefined)                                                                                     // 336
      return;                                                                                                // 337
    else if (!(x instanceof Array))                                                                          // 338
      throw MinimongoError("Cannot apply $pull/pullAll modifier to non-array");                              // 339
    else {                                                                                                   // 340
      var out = [];                                                                                          // 341
      if (typeof arg === "object" && !(arg instanceof Array)) {                                              // 342
        // XXX would be much nicer to compile this once, rather than                                         // 343
        // for each document we modify.. but usually we're not                                               // 344
        // modifying that many documents, so we'll let it slide for                                          // 345
        // now                                                                                               // 346
                                                                                                             // 347
        // XXX Minimongo.Matcher isn't up for the job, because we need                                       // 348
        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something                                           // 349
        // like {$gt: 4} is not normally a complete selector.                                                // 350
        // same issue as $elemMatch possibly?                                                                // 351
        var matcher = new Minimongo.Matcher(arg);                                                            // 352
        for (var i = 0; i < x.length; i++)                                                                   // 353
          if (!matcher.documentMatches(x[i]).result)                                                         // 354
            out.push(x[i]);                                                                                  // 355
      } else {                                                                                               // 356
        for (var i = 0; i < x.length; i++)                                                                   // 357
          if (!LocalCollection._f._equal(x[i], arg))                                                         // 358
            out.push(x[i]);                                                                                  // 359
      }                                                                                                      // 360
      target[field] = out;                                                                                   // 361
    }                                                                                                        // 362
  },                                                                                                         // 363
  $pullAll: function (target, field, arg) {                                                                  // 364
    if (!(typeof arg === "object" && arg instanceof Array))                                                  // 365
      throw MinimongoError("Modifier $pushAll/pullAll allowed for arrays only");                             // 366
    if (target === undefined)                                                                                // 367
      return;                                                                                                // 368
    var x = target[field];                                                                                   // 369
    if (x === undefined)                                                                                     // 370
      return;                                                                                                // 371
    else if (!(x instanceof Array))                                                                          // 372
      throw MinimongoError("Cannot apply $pull/pullAll modifier to non-array");                              // 373
    else {                                                                                                   // 374
      var out = [];                                                                                          // 375
      for (var i = 0; i < x.length; i++) {                                                                   // 376
        var exclude = false;                                                                                 // 377
        for (var j = 0; j < arg.length; j++) {                                                               // 378
          if (LocalCollection._f._equal(x[i], arg[j])) {                                                     // 379
            exclude = true;                                                                                  // 380
            break;                                                                                           // 381
          }                                                                                                  // 382
        }                                                                                                    // 383
        if (!exclude)                                                                                        // 384
          out.push(x[i]);                                                                                    // 385
      }                                                                                                      // 386
      target[field] = out;                                                                                   // 387
    }                                                                                                        // 388
  },                                                                                                         // 389
  $rename: function (target, field, arg, keypath, doc) {                                                     // 390
    if (keypath === arg)                                                                                     // 391
      // no idea why mongo has this restriction..                                                            // 392
      throw MinimongoError("$rename source must differ from target");                                        // 393
    if (target === null)                                                                                     // 394
      throw MinimongoError("$rename source field invalid");                                                  // 395
    if (typeof arg !== "string")                                                                             // 396
      throw MinimongoError("$rename target must be a string");                                               // 397
    if (target === undefined)                                                                                // 398
      return;                                                                                                // 399
    var v = target[field];                                                                                   // 400
    delete target[field];                                                                                    // 401
                                                                                                             // 402
    var keyparts = arg.split('.');                                                                           // 403
    var target2 = findModTarget(doc, keyparts, {forbidArray: true});                                         // 404
    if (target2 === null)                                                                                    // 405
      throw MinimongoError("$rename target field invalid");                                                  // 406
    var field2 = keyparts.pop();                                                                             // 407
    target2[field2] = v;                                                                                     // 408
  },                                                                                                         // 409
  $bit: function (target, field, arg) {                                                                      // 410
    // XXX mongo only supports $bit on integers, and we only support                                         // 411
    // native javascript numbers (doubles) so far, so we can't support $bit                                  // 412
    throw MinimongoError("$bit is not supported");                                                           // 413
  }                                                                                                          // 414
};                                                                                                           // 415
                                                                                                             // 416
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/diff.js                                                                                //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
// ordered: bool.                                                                                            // 1
// old_results and new_results: collections of documents.                                                    // 2
//    if ordered, they are arrays.                                                                           // 3
//    if unordered, they are IdMaps                                                                          // 4
LocalCollection._diffQueryChanges = function (ordered, oldResults, newResults,                               // 5
                                              observer, options) {                                           // 6
  if (ordered)                                                                                               // 7
    LocalCollection._diffQueryOrderedChanges(                                                                // 8
      oldResults, newResults, observer, options);                                                            // 9
  else                                                                                                       // 10
    LocalCollection._diffQueryUnorderedChanges(                                                              // 11
      oldResults, newResults, observer, options);                                                            // 12
};                                                                                                           // 13
                                                                                                             // 14
LocalCollection._diffQueryUnorderedChanges = function (oldResults, newResults,                               // 15
                                                       observer, options) {                                  // 16
  options = options || {};                                                                                   // 17
  var projectionFn = options.projectionFn || EJSON.clone;                                                    // 18
                                                                                                             // 19
  if (observer.movedBefore) {                                                                                // 20
    throw new Error("_diffQueryUnordered called with a movedBefore observer!");                              // 21
  }                                                                                                          // 22
                                                                                                             // 23
  newResults.forEach(function (newDoc, id) {                                                                 // 24
    var oldDoc = oldResults.get(id);                                                                         // 25
    if (oldDoc) {                                                                                            // 26
      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {                                               // 27
        var projectedNew = projectionFn(newDoc);                                                             // 28
        var projectedOld = projectionFn(oldDoc);                                                             // 29
        var changedFields =                                                                                  // 30
              LocalCollection._makeChangedFields(projectedNew, projectedOld);                                // 31
        if (! _.isEmpty(changedFields)) {                                                                    // 32
          observer.changed(id, changedFields);                                                               // 33
        }                                                                                                    // 34
      }                                                                                                      // 35
    } else if (observer.added) {                                                                             // 36
      var fields = projectionFn(newDoc);                                                                     // 37
      delete fields._id;                                                                                     // 38
      observer.added(newDoc._id, fields);                                                                    // 39
    }                                                                                                        // 40
  });                                                                                                        // 41
                                                                                                             // 42
  if (observer.removed) {                                                                                    // 43
    oldResults.forEach(function (oldDoc, id) {                                                               // 44
      if (!newResults.has(id))                                                                               // 45
        observer.removed(id);                                                                                // 46
    });                                                                                                      // 47
  }                                                                                                          // 48
};                                                                                                           // 49
                                                                                                             // 50
                                                                                                             // 51
LocalCollection._diffQueryOrderedChanges = function (old_results, new_results,                               // 52
                                                     observer, options) {                                    // 53
  options = options || {};                                                                                   // 54
  var projectionFn = options.projectionFn || EJSON.clone;                                                    // 55
                                                                                                             // 56
  var new_presence_of_id = {};                                                                               // 57
  _.each(new_results, function (doc) {                                                                       // 58
    if (new_presence_of_id[doc._id])                                                                         // 59
      Meteor._debug("Duplicate _id in new_results");                                                         // 60
    new_presence_of_id[doc._id] = true;                                                                      // 61
  });                                                                                                        // 62
                                                                                                             // 63
  var old_index_of_id = {};                                                                                  // 64
  _.each(old_results, function (doc, i) {                                                                    // 65
    if (doc._id in old_index_of_id)                                                                          // 66
      Meteor._debug("Duplicate _id in old_results");                                                         // 67
    old_index_of_id[doc._id] = i;                                                                            // 68
  });                                                                                                        // 69
                                                                                                             // 70
  // ALGORITHM:                                                                                              // 71
  //                                                                                                         // 72
  // To determine which docs should be considered "moved" (and which                                         // 73
  // merely change position because of other docs moving) we run                                             // 74
  // a "longest common subsequence" (LCS) algorithm.  The LCS of the                                         // 75
  // old doc IDs and the new doc IDs gives the docs that should NOT be                                       // 76
  // considered moved.                                                                                       // 77
                                                                                                             // 78
  // To actually call the appropriate callbacks to get from the old state to the                             // 79
  // new state:                                                                                              // 80
                                                                                                             // 81
  // First, we call removed() on all the items that only appear in the old                                   // 82
  // state.                                                                                                  // 83
                                                                                                             // 84
  // Then, once we have the items that should not move, we walk through the new                              // 85
  // results array group-by-group, where a "group" is a set of items that have                               // 86
  // moved, anchored on the end by an item that should not move.  One by one, we                             // 87
  // move each of those elements into place "before" the anchoring end-of-group                              // 88
  // item, and fire changed events on them if necessary.  Then we fire a changed                             // 89
  // event on the anchor, and move on to the next group.  There is always at                                 // 90
  // least one group; the last group is anchored by a virtual "null" id at the                               // 91
  // end.                                                                                                    // 92
                                                                                                             // 93
  // Asymptotically: O(N k) where k is number of ops, or potentially                                         // 94
  // O(N log N) if inner loop of LCS were made to be binary search.                                          // 95
                                                                                                             // 96
                                                                                                             // 97
  //////// LCS (longest common sequence, with respect to _id)                                                // 98
  // (see Wikipedia article on Longest Increasing Subsequence,                                               // 99
  // where the LIS is taken of the sequence of old indices of the                                            // 100
  // docs in new_results)                                                                                    // 101
  //                                                                                                         // 102
  // unmoved: the output of the algorithm; members of the LCS,                                               // 103
  // in the form of indices into new_results                                                                 // 104
  var unmoved = [];                                                                                          // 105
  // max_seq_len: length of LCS found so far                                                                 // 106
  var max_seq_len = 0;                                                                                       // 107
  // seq_ends[i]: the index into new_results of the last doc in a                                            // 108
  // common subsequence of length of i+1 <= max_seq_len                                                      // 109
  var N = new_results.length;                                                                                // 110
  var seq_ends = new Array(N);                                                                               // 111
  // ptrs:  the common subsequence ending with new_results[n] extends                                        // 112
  // a common subsequence ending with new_results[ptr[n]], unless                                            // 113
  // ptr[n] is -1.                                                                                           // 114
  var ptrs = new Array(N);                                                                                   // 115
  // virtual sequence of old indices of new results                                                          // 116
  var old_idx_seq = function(i_new) {                                                                        // 117
    return old_index_of_id[new_results[i_new]._id];                                                          // 118
  };                                                                                                         // 119
  // for each item in new_results, use it to extend a common subsequence                                     // 120
  // of length j <= max_seq_len                                                                              // 121
  for(var i=0; i<N; i++) {                                                                                   // 122
    if (old_index_of_id[new_results[i]._id] !== undefined) {                                                 // 123
      var j = max_seq_len;                                                                                   // 124
      // this inner loop would traditionally be a binary search,                                             // 125
      // but scanning backwards we will likely find a subseq to extend                                       // 126
      // pretty soon, bounded for example by the total number of ops.                                        // 127
      // If this were to be changed to a binary search, we'd still want                                      // 128
      // to scan backwards a bit as an optimization.                                                         // 129
      while (j > 0) {                                                                                        // 130
        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))                                                     // 131
          break;                                                                                             // 132
        j--;                                                                                                 // 133
      }                                                                                                      // 134
                                                                                                             // 135
      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);                                                              // 136
      seq_ends[j] = i;                                                                                       // 137
      if (j+1 > max_seq_len)                                                                                 // 138
        max_seq_len = j+1;                                                                                   // 139
    }                                                                                                        // 140
  }                                                                                                          // 141
                                                                                                             // 142
  // pull out the LCS/LIS into unmoved                                                                       // 143
  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);                                              // 144
  while (idx >= 0) {                                                                                         // 145
    unmoved.push(idx);                                                                                       // 146
    idx = ptrs[idx];                                                                                         // 147
  }                                                                                                          // 148
  // the unmoved item list is built backwards, so fix that                                                   // 149
  unmoved.reverse();                                                                                         // 150
                                                                                                             // 151
  // the last group is always anchored by the end of the result list, which is                               // 152
  // an id of "null"                                                                                         // 153
  unmoved.push(new_results.length);                                                                          // 154
                                                                                                             // 155
  _.each(old_results, function (doc) {                                                                       // 156
    if (!new_presence_of_id[doc._id])                                                                        // 157
      observer.removed && observer.removed(doc._id);                                                         // 158
  });                                                                                                        // 159
  // for each group of things in the new_results that is anchored by an unmoved                              // 160
  // element, iterate through the things before it.                                                          // 161
  var startOfGroup = 0;                                                                                      // 162
  _.each(unmoved, function (endOfGroup) {                                                                    // 163
    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;                              // 164
    var oldDoc, newDoc, fields, projectedNew, projectedOld;                                                  // 165
    for (var i = startOfGroup; i < endOfGroup; i++) {                                                        // 166
      newDoc = new_results[i];                                                                               // 167
      if (!_.has(old_index_of_id, newDoc._id)) {                                                             // 168
        fields = projectionFn(newDoc);                                                                       // 169
        delete fields._id;                                                                                   // 170
        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);                           // 171
        observer.added && observer.added(newDoc._id, fields);                                                // 172
      } else {                                                                                               // 173
        // moved                                                                                             // 174
        oldDoc = old_results[old_index_of_id[newDoc._id]];                                                   // 175
        projectedNew = projectionFn(newDoc);                                                                 // 176
        projectedOld = projectionFn(oldDoc);                                                                 // 177
        fields = LocalCollection._makeChangedFields(projectedNew, projectedOld);                             // 178
        if (!_.isEmpty(fields)) {                                                                            // 179
          observer.changed && observer.changed(newDoc._id, fields);                                          // 180
        }                                                                                                    // 181
        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);                                   // 182
      }                                                                                                      // 183
    }                                                                                                        // 184
    if (groupId) {                                                                                           // 185
      newDoc = new_results[endOfGroup];                                                                      // 186
      oldDoc = old_results[old_index_of_id[newDoc._id]];                                                     // 187
      projectedNew = projectionFn(newDoc);                                                                   // 188
      projectedOld = projectionFn(oldDoc);                                                                   // 189
      fields = LocalCollection._makeChangedFields(projectedNew, projectedOld);                               // 190
      if (!_.isEmpty(fields)) {                                                                              // 191
        observer.changed && observer.changed(newDoc._id, fields);                                            // 192
      }                                                                                                      // 193
    }                                                                                                        // 194
    startOfGroup = endOfGroup+1;                                                                             // 195
  });                                                                                                        // 196
                                                                                                             // 197
                                                                                                             // 198
};                                                                                                           // 199
                                                                                                             // 200
                                                                                                             // 201
// General helper for diff-ing two objects.                                                                  // 202
// callbacks is an object like so:                                                                           // 203
// { leftOnly: function (key, leftValue) {...},                                                              // 204
//   rightOnly: function (key, rightValue) {...},                                                            // 205
//   both: function (key, leftValue, rightValue) {...},                                                      // 206
// }                                                                                                         // 207
LocalCollection._diffObjects = function (left, right, callbacks) {                                           // 208
  _.each(left, function (leftValue, key) {                                                                   // 209
    if (_.has(right, key))                                                                                   // 210
      callbacks.both && callbacks.both(key, leftValue, right[key]);                                          // 211
    else                                                                                                     // 212
      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);                                              // 213
  });                                                                                                        // 214
  if (callbacks.rightOnly) {                                                                                 // 215
    _.each(right, function(rightValue, key) {                                                                // 216
      if (!_.has(left, key))                                                                                 // 217
        callbacks.rightOnly(key, rightValue);                                                                // 218
    });                                                                                                      // 219
  }                                                                                                          // 220
};                                                                                                           // 221
                                                                                                             // 222
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/id_map.js                                                                              //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
LocalCollection._IdMap = function () {                                                                       // 1
  var self = this;                                                                                           // 2
  IdMap.call(self, LocalCollection._idStringify, LocalCollection._idParse);                                  // 3
};                                                                                                           // 4
                                                                                                             // 5
Meteor._inherits(LocalCollection._IdMap, IdMap);                                                             // 6
                                                                                                             // 7
                                                                                                             // 8
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/observe.js                                                                             //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
// XXX maybe move these into another ObserveHelpers package or something                                     // 1
                                                                                                             // 2
// _CachingChangeObserver is an object which receives observeChanges callbacks                               // 3
// and keeps a cache of the current cursor state up to date in self.docs. Users                              // 4
// of this class should read the docs field but not modify it. You should pass                               // 5
// the "applyChange" field as the callbacks to the underlying observeChanges                                 // 6
// call. Optionally, you can specify your own observeChanges callbacks which are                             // 7
// invoked immediately before the docs field is updated; this object is made                                 // 8
// available as `this` to those callbacks.                                                                   // 9
LocalCollection._CachingChangeObserver = function (options) {                                                // 10
  var self = this;                                                                                           // 11
  options = options || {};                                                                                   // 12
                                                                                                             // 13
  var orderedFromCallbacks = options.callbacks &&                                                            // 14
        LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);                               // 15
  if (_.has(options, 'ordered')) {                                                                           // 16
    self.ordered = options.ordered;                                                                          // 17
    if (options.callbacks && options.ordered !== orderedFromCallbacks)                                       // 18
      throw Error("ordered option doesn't match callbacks");                                                 // 19
  } else if (options.callbacks) {                                                                            // 20
    self.ordered = orderedFromCallbacks;                                                                     // 21
  } else {                                                                                                   // 22
    throw Error("must provide ordered or callbacks");                                                        // 23
  }                                                                                                          // 24
  var callbacks = options.callbacks || {};                                                                   // 25
                                                                                                             // 26
  if (self.ordered) {                                                                                        // 27
    self.docs = new OrderedDict(LocalCollection._idStringify);                                               // 28
    self.applyChange = {                                                                                     // 29
      addedBefore: function (id, fields, before) {                                                           // 30
        var doc = EJSON.clone(fields);                                                                       // 31
        doc._id = id;                                                                                        // 32
        callbacks.addedBefore && callbacks.addedBefore.call(                                                 // 33
          self, id, fields, before);                                                                         // 34
        // This line triggers if we provide added with movedBefore.                                          // 35
        callbacks.added && callbacks.added.call(self, id, fields);                                           // 36
        // XXX could `before` be a falsy ID?  Technically                                                    // 37
        // idStringify seems to allow for them -- though                                                     // 38
        // OrderedDict won't call stringify on a falsy arg.                                                  // 39
        self.docs.putBefore(id, doc, before || null);                                                        // 40
      },                                                                                                     // 41
      movedBefore: function (id, before) {                                                                   // 42
        var doc = self.docs.get(id);                                                                         // 43
        callbacks.movedBefore && callbacks.movedBefore.call(self, id, before);                               // 44
        self.docs.moveBefore(id, before || null);                                                            // 45
      }                                                                                                      // 46
    };                                                                                                       // 47
  } else {                                                                                                   // 48
    self.docs = new LocalCollection._IdMap;                                                                  // 49
    self.applyChange = {                                                                                     // 50
      added: function (id, fields) {                                                                         // 51
        var doc = EJSON.clone(fields);                                                                       // 52
        callbacks.added && callbacks.added.call(self, id, fields);                                           // 53
        doc._id = id;                                                                                        // 54
        self.docs.set(id,  doc);                                                                             // 55
      }                                                                                                      // 56
    };                                                                                                       // 57
  }                                                                                                          // 58
                                                                                                             // 59
  // The methods in _IdMap and OrderedDict used by these callbacks are                                       // 60
  // identical.                                                                                              // 61
  self.applyChange.changed = function (id, fields) {                                                         // 62
    var doc = self.docs.get(id);                                                                             // 63
    if (!doc)                                                                                                // 64
      throw new Error("Unknown id for changed: " + id);                                                      // 65
    callbacks.changed && callbacks.changed.call(                                                             // 66
      self, id, EJSON.clone(fields));                                                                        // 67
    LocalCollection._applyChanges(doc, fields);                                                              // 68
  };                                                                                                         // 69
  self.applyChange.removed = function (id) {                                                                 // 70
    callbacks.removed && callbacks.removed.call(self, id);                                                   // 71
    self.docs.remove(id);                                                                                    // 72
  };                                                                                                         // 73
};                                                                                                           // 74
                                                                                                             // 75
LocalCollection._observeFromObserveChanges = function (cursor, observeCallbacks) {                           // 76
  var transform = cursor.getTransform() || function (doc) {return doc;};                                     // 77
  var suppressed = !!observeCallbacks._suppress_initial;                                                     // 78
                                                                                                             // 79
  var observeChangesCallbacks;                                                                               // 80
  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {                                       // 81
    // The "_no_indices" option sets all index arguments to -1 and skips the                                 // 82
    // linear scans required to generate them.  This lets observers that don't                               // 83
    // need absolute indices benefit from the other features of this API --                                  // 84
    // relative order, transforms, and applyChanges -- without the speed hit.                                // 85
    var indices = !observeCallbacks._no_indices;                                                             // 86
    observeChangesCallbacks = {                                                                              // 87
      addedBefore: function (id, fields, before) {                                                           // 88
        var self = this;                                                                                     // 89
        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added))                             // 90
          return;                                                                                            // 91
        var doc = transform(_.extend(fields, {_id: id}));                                                    // 92
        if (observeCallbacks.addedAt) {                                                                      // 93
          var index = indices                                                                                // 94
                ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;                              // 95
          observeCallbacks.addedAt(doc, index, before);                                                      // 96
        } else {                                                                                             // 97
          observeCallbacks.added(doc);                                                                       // 98
        }                                                                                                    // 99
      },                                                                                                     // 100
      changed: function (id, fields) {                                                                       // 101
        var self = this;                                                                                     // 102
        if (!(observeCallbacks.changedAt || observeCallbacks.changed))                                       // 103
          return;                                                                                            // 104
        var doc = EJSON.clone(self.docs.get(id));                                                            // 105
        if (!doc)                                                                                            // 106
          throw new Error("Unknown id for changed: " + id);                                                  // 107
        var oldDoc = transform(EJSON.clone(doc));                                                            // 108
        LocalCollection._applyChanges(doc, fields);                                                          // 109
        doc = transform(doc);                                                                                // 110
        if (observeCallbacks.changedAt) {                                                                    // 111
          var index = indices ? self.docs.indexOf(id) : -1;                                                  // 112
          observeCallbacks.changedAt(doc, oldDoc, index);                                                    // 113
        } else {                                                                                             // 114
          observeCallbacks.changed(doc, oldDoc);                                                             // 115
        }                                                                                                    // 116
      },                                                                                                     // 117
      movedBefore: function (id, before) {                                                                   // 118
        var self = this;                                                                                     // 119
        if (!observeCallbacks.movedTo)                                                                       // 120
          return;                                                                                            // 121
        var from = indices ? self.docs.indexOf(id) : -1;                                                     // 122
                                                                                                             // 123
        var to = indices                                                                                     // 124
              ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;                                // 125
        // When not moving backwards, adjust for the fact that removing the                                  // 126
        // document slides everything back one slot.                                                         // 127
        if (to > from)                                                                                       // 128
          --to;                                                                                              // 129
        observeCallbacks.movedTo(transform(EJSON.clone(self.docs.get(id))),                                  // 130
                                 from, to, before || null);                                                  // 131
      },                                                                                                     // 132
      removed: function (id) {                                                                               // 133
        var self = this;                                                                                     // 134
        if (!(observeCallbacks.removedAt || observeCallbacks.removed))                                       // 135
          return;                                                                                            // 136
        // technically maybe there should be an EJSON.clone here, but it's about                             // 137
        // to be removed from self.docs!                                                                     // 138
        var doc = transform(self.docs.get(id));                                                              // 139
        if (observeCallbacks.removedAt) {                                                                    // 140
          var index = indices ? self.docs.indexOf(id) : -1;                                                  // 141
          observeCallbacks.removedAt(doc, index);                                                            // 142
        } else {                                                                                             // 143
          observeCallbacks.removed(doc);                                                                     // 144
        }                                                                                                    // 145
      }                                                                                                      // 146
    };                                                                                                       // 147
  } else {                                                                                                   // 148
    observeChangesCallbacks = {                                                                              // 149
      added: function (id, fields) {                                                                         // 150
        if (!suppressed && observeCallbacks.added) {                                                         // 151
          var doc = _.extend(fields, {_id:  id});                                                            // 152
          observeCallbacks.added(transform(doc));                                                            // 153
        }                                                                                                    // 154
      },                                                                                                     // 155
      changed: function (id, fields) {                                                                       // 156
        var self = this;                                                                                     // 157
        if (observeCallbacks.changed) {                                                                      // 158
          var oldDoc = self.docs.get(id);                                                                    // 159
          var doc = EJSON.clone(oldDoc);                                                                     // 160
          LocalCollection._applyChanges(doc, fields);                                                        // 161
          observeCallbacks.changed(transform(doc),                                                           // 162
                                   transform(EJSON.clone(oldDoc)));                                          // 163
        }                                                                                                    // 164
      },                                                                                                     // 165
      removed: function (id) {                                                                               // 166
        var self = this;                                                                                     // 167
        if (observeCallbacks.removed) {                                                                      // 168
          observeCallbacks.removed(transform(self.docs.get(id)));                                            // 169
        }                                                                                                    // 170
      }                                                                                                      // 171
    };                                                                                                       // 172
  }                                                                                                          // 173
                                                                                                             // 174
  var changeObserver = new LocalCollection._CachingChangeObserver(                                           // 175
    {callbacks: observeChangesCallbacks});                                                                   // 176
  var handle = cursor.observeChanges(changeObserver.applyChange);                                            // 177
  suppressed = false;                                                                                        // 178
                                                                                                             // 179
  return handle;                                                                                             // 180
};                                                                                                           // 181
                                                                                                             // 182
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                           //
// packages/minimongo/objectid.js                                                                            //
//                                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                             //
LocalCollection._looksLikeObjectID = function (str) {                                                        // 1
  return str.length === 24 && str.match(/^[0-9a-f]*$/);                                                      // 2
};                                                                                                           // 3
                                                                                                             // 4
LocalCollection._ObjectID = function (hexString) {                                                           // 5
  //random-based impl of Mongo ObjectID                                                                      // 6
  var self = this;                                                                                           // 7
  if (hexString) {                                                                                           // 8
    hexString = hexString.toLowerCase();                                                                     // 9
    if (!LocalCollection._looksLikeObjectID(hexString)) {                                                    // 10
      throw new Error("Invalid hexadecimal string for creating an ObjectID");                                // 11
    }                                                                                                        // 12
    // meant to work with _.isEqual(), which relies on structural equality                                   // 13
    self._str = hexString;                                                                                   // 14
  } else {                                                                                                   // 15
    self._str = Random.hexString(24);                                                                        // 16
  }                                                                                                          // 17
};                                                                                                           // 18
                                                                                                             // 19
LocalCollection._ObjectID.prototype.toString = function () {                                                 // 20
  var self = this;                                                                                           // 21
  return "ObjectID(\"" + self._str + "\")";                                                                  // 22
};                                                                                                           // 23
                                                                                                             // 24
LocalCollection._ObjectID.prototype.equals = function (other) {                                              // 25
  var self = this;                                                                                           // 26
  return other instanceof LocalCollection._ObjectID &&                                                       // 27
    self.valueOf() === other.valueOf();                                                                      // 28
};                                                                                                           // 29
                                                                                                             // 30
LocalCollection._ObjectID.prototype.clone = function () {                                                    // 31
  var self = this;                                                                                           // 32
  return new LocalCollection._ObjectID(self._str);                                                           // 33
};                                                                                                           // 34
                                                                                                             // 35
LocalCollection._ObjectID.prototype.typeName = function() {                                                  // 36
  return "oid";                                                                                              // 37
};                                                                                                           // 38
                                                                                                             // 39
LocalCollection._ObjectID.prototype.getTimestamp = function() {                                              // 40
  var self = this;                                                                                           // 41
  return parseInt(self._str.substr(0, 8), 16);                                                               // 42
};                                                                                                           // 43
                                                                                                             // 44
LocalCollection._ObjectID.prototype.valueOf =                                                                // 45
    LocalCollection._ObjectID.prototype.toJSONValue =                                                        // 46
    LocalCollection._ObjectID.prototype.toHexString =                                                        // 47
    function () { return this._str; };                                                                       // 48
                                                                                                             // 49
// Is this selector just shorthand for lookup by _id?                                                        // 50
LocalCollection._selectorIsId = function (selector) {                                                        // 51
  return (typeof selector === "string") ||                                                                   // 52
    (typeof selector === "number") ||                                                                        // 53
    selector instanceof LocalCollection._ObjectID;                                                           // 54
};                                                                                                           // 55
                                                                                                             // 56
// Is the selector just lookup by _id (shorthand or not)?                                                    // 57
LocalCollection._selectorIsIdPerhapsAsObject = function (selector) {                                         // 58
  return LocalCollection._selectorIsId(selector) ||                                                          // 59
    (selector && typeof selector === "object" &&                                                             // 60
     selector._id && LocalCollection._selectorIsId(selector._id) &&                                          // 61
     _.size(selector) === 1);                                                                                // 62
};                                                                                                           // 63
                                                                                                             // 64
// If this is a selector which explicitly constrains the match by ID to a finite                             // 65
// number of documents, returns a list of their IDs.  Otherwise returns                                      // 66
// null. Note that the selector may have other restrictions so it may not even                               // 67
// match those document!  We care about $in and $and since those are generated                               // 68
// access-controlled update and remove.                                                                      // 69
LocalCollection._idsMatchedBySelector = function (selector) {                                                // 70
  // Is the selector just an ID?                                                                             // 71
  if (LocalCollection._selectorIsId(selector))                                                               // 72
    return [selector];                                                                                       // 73
  if (!selector)                                                                                             // 74
    return null;                                                                                             // 75
                                                                                                             // 76
  // Do we have an _id clause?                                                                               // 77
  if (_.has(selector, '_id')) {                                                                              // 78
    // Is the _id clause just an ID?                                                                         // 79
    if (LocalCollection._selectorIsId(selector._id))                                                         // 80
      return [selector._id];                                                                                 // 81
    // Is the _id clause {_id: {$in: ["x", "y", "z"]}}?                                                      // 82
    if (selector._id && selector._id.$in                                                                     // 83
        && _.isArray(selector._id.$in)                                                                       // 84
        && !_.isEmpty(selector._id.$in)                                                                      // 85
        && _.all(selector._id.$in, LocalCollection._selectorIsId)) {                                         // 86
      return selector._id.$in;                                                                               // 87
    }                                                                                                        // 88
    return null;                                                                                             // 89
  }                                                                                                          // 90
                                                                                                             // 91
  // If this is a top-level $and, and any of the clauses constrain their                                     // 92
  // documents, then the whole selector is constrained by any one clause's                                   // 93
  // constraint. (Well, by their intersection, but that seems unlikely.)                                     // 94
  if (selector.$and && _.isArray(selector.$and)) {                                                           // 95
    for (var i = 0; i < selector.$and.length; ++i) {                                                         // 96
      var subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);                                  // 97
      if (subIds)                                                                                            // 98
        return subIds;                                                                                       // 99
    }                                                                                                        // 100
  }                                                                                                          // 101
                                                                                                             // 102
  return null;                                                                                               // 103
};                                                                                                           // 104
                                                                                                             // 105
EJSON.addType("oid",  function (str) {                                                                       // 106
  return new LocalCollection._ObjectID(str);                                                                 // 107
});                                                                                                          // 108
                                                                                                             // 109
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.minimongo = {
  LocalCollection: LocalCollection,
  Minimongo: Minimongo,
  MinimongoTest: MinimongoTest
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var Log;

(function () {

/////////////////////////////////////////////////////////////////////////////////////////
//                                                                                     //
// packages/logging/logging.js                                                         //
//                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////
                                                                                       //
Log = function () {                                                                    // 1
  return Log.info.apply(this, arguments);                                              // 2
};                                                                                     // 3
                                                                                       // 4
/// FOR TESTING                                                                        // 5
var intercept = 0;                                                                     // 6
var interceptedLines = [];                                                             // 7
var suppress = 0;                                                                      // 8
                                                                                       // 9
// Intercept the next 'count' calls to a Log function. The actual                      // 10
// lines printed to the console can be cleared and read by calling                     // 11
// Log._intercepted().                                                                 // 12
Log._intercept = function (count) {                                                    // 13
  intercept += count;                                                                  // 14
};                                                                                     // 15
                                                                                       // 16
// Suppress the next 'count' calls to a Log function. Use this to stop                 // 17
// tests from spamming the console, especially with red errors that                    // 18
// might look like a failing test.                                                     // 19
Log._suppress = function (count) {                                                     // 20
  suppress += count;                                                                   // 21
};                                                                                     // 22
                                                                                       // 23
// Returns intercepted lines and resets the intercept counter.                         // 24
Log._intercepted = function () {                                                       // 25
  var lines = interceptedLines;                                                        // 26
  interceptedLines = [];                                                               // 27
  intercept = 0;                                                                       // 28
  return lines;                                                                        // 29
};                                                                                     // 30
                                                                                       // 31
// Either 'json' or 'colored-text'.                                                    // 32
//                                                                                     // 33
// When this is set to 'json', print JSON documents that are parsed by another         // 34
// process ('satellite' or 'meteor run'). This other process should call               // 35
// 'Log.format' for nice output.                                                       // 36
//                                                                                     // 37
// When this is set to 'colored-text', call 'Log.format' before printing.              // 38
// This should be used for logging from within satellite, since there is no            // 39
// other process that will be reading its standard output.                             // 40
Log.outputFormat = 'json';                                                             // 41
                                                                                       // 42
var LEVEL_COLORS = {                                                                   // 43
  debug: 'green',                                                                      // 44
  // leave info as the default color                                                   // 45
  warn: 'magenta',                                                                     // 46
  error: 'red'                                                                         // 47
};                                                                                     // 48
                                                                                       // 49
var META_COLOR = 'blue';                                                               // 50
                                                                                       // 51
// XXX package                                                                         // 52
var RESTRICTED_KEYS = ['time', 'timeInexact', 'level', 'file', 'line',                 // 53
                        'program', 'originApp', 'satellite', 'stderr'];                // 54
                                                                                       // 55
var FORMATTED_KEYS = RESTRICTED_KEYS.concat(['app', 'message']);                       // 56
                                                                                       // 57
var logInBrowser = function (obj) {                                                    // 58
  var str = Log.format(obj);                                                           // 59
                                                                                       // 60
  // XXX Some levels should be probably be sent to the server                          // 61
  var level = obj.level;                                                               // 62
                                                                                       // 63
  if ((typeof console !== 'undefined') && console[level]) {                            // 64
    console[level](str);                                                               // 65
  } else {                                                                             // 66
    // XXX Uses of Meteor._debug should probably be replaced by Log.debug or           // 67
    //     Log.info, and we should have another name for "do your best to              // 68
    //     call call console.log".                                                     // 69
    Meteor._debug(str);                                                                // 70
  }                                                                                    // 71
};                                                                                     // 72
                                                                                       // 73
// @returns {Object: { line: Number, file: String }}                                   // 74
Log._getCallerDetails = function () {                                                  // 75
  var getStack = function () {                                                         // 76
    // We do NOT use Error.prepareStackTrace here (a V8 extension that gets us a       // 77
    // pre-parsed stack) since it's impossible to compose it with the use of           // 78
    // Error.prepareStackTrace used on the server for source maps.                     // 79
    var err = new Error;                                                               // 80
    var stack = err.stack;                                                             // 81
    return stack;                                                                      // 82
  };                                                                                   // 83
                                                                                       // 84
  var stack = getStack();                                                              // 85
                                                                                       // 86
  if (!stack) return {};                                                               // 87
                                                                                       // 88
  var lines = stack.split('\n');                                                       // 89
                                                                                       // 90
  // looking for the first line outside the logging package (or an                     // 91
  // eval if we find that first)                                                       // 92
  var line;                                                                            // 93
  for (var i = 1; i < lines.length; ++i) {                                             // 94
    line = lines[i];                                                                   // 95
    if (line.match(/^\s*at eval \(eval/)) {                                            // 96
      return {file: "eval"};                                                           // 97
    }                                                                                  // 98
                                                                                       // 99
    if (!line.match(/packages\/(?:local-test:)?logging(?:\/|\.js)/))                   // 100
      break;                                                                           // 101
  }                                                                                    // 102
                                                                                       // 103
  var details = {};                                                                    // 104
                                                                                       // 105
  // The format for FF is 'functionName@filePath:lineNumber'                           // 106
  // The format for V8 is 'functionName (packages/logging/logging.js:81)' or           // 107
  //                      'packages/logging/logging.js:81'                             // 108
  var match = /(?:[@(]| at )([^(]+?):([0-9:]+)(?:\)|$)/.exec(line);                    // 109
  if (!match)                                                                          // 110
    return details;                                                                    // 111
  // in case the matched block here is line:column                                     // 112
  details.line = match[2].split(':')[0];                                               // 113
                                                                                       // 114
  // Possible format: https://foo.bar.com/scripts/file.js?random=foobar                // 115
  // XXX: if you can write the following in better way, please do it                   // 116
  // XXX: what about evals?                                                            // 117
  details.file = match[1].split('/').slice(-1)[0].split('?')[0];                       // 118
                                                                                       // 119
  return details;                                                                      // 120
};                                                                                     // 121
                                                                                       // 122
_.each(['debug', 'info', 'warn', 'error'], function (level) {                          // 123
  // @param arg {String|Object}                                                        // 124
  Log[level] = function (arg) {                                                        // 125
    if (suppress) {                                                                    // 126
      suppress--;                                                                      // 127
      return;                                                                          // 128
    }                                                                                  // 129
                                                                                       // 130
    var intercepted = false;                                                           // 131
    if (intercept) {                                                                   // 132
      intercept--;                                                                     // 133
      intercepted = true;                                                              // 134
    }                                                                                  // 135
                                                                                       // 136
    var obj = (_.isObject(arg) && !_.isRegExp(arg) && !_.isDate(arg) ) ?               // 137
              arg : {message: new String(arg).toString() };                            // 138
                                                                                       // 139
    _.each(RESTRICTED_KEYS, function (key) {                                           // 140
      if (obj[key])                                                                    // 141
        throw new Error("Can't set '" + key + "' in log message");                     // 142
    });                                                                                // 143
                                                                                       // 144
    if (_.has(obj, 'message') && !_.isString(obj.message))                             // 145
      throw new Error("The 'message' field in log objects must be a string");          // 146
    if (!obj.omitCallerDetails)                                                        // 147
      obj = _.extend(Log._getCallerDetails(), obj);                                    // 148
    obj.time = new Date();                                                             // 149
    obj.level = level;                                                                 // 150
                                                                                       // 151
    // XXX allow you to enable 'debug', probably per-package                           // 152
    if (level === 'debug')                                                             // 153
      return;                                                                          // 154
                                                                                       // 155
    if (intercepted) {                                                                 // 156
      interceptedLines.push(EJSON.stringify(obj));                                     // 157
    } else if (Meteor.isServer) {                                                      // 158
      if (Log.outputFormat === 'colored-text') {                                       // 159
        console.log(Log.format(obj, {color: true}));                                   // 160
      } else if (Log.outputFormat === 'json') {                                        // 161
        console.log(EJSON.stringify(obj));                                             // 162
      } else {                                                                         // 163
        throw new Error("Unknown logging output format: " + Log.outputFormat);         // 164
      }                                                                                // 165
    } else {                                                                           // 166
      logInBrowser(obj);                                                               // 167
    }                                                                                  // 168
  };                                                                                   // 169
});                                                                                    // 170
                                                                                       // 171
// tries to parse line as EJSON. returns object if parse is successful, or null if not // 172
Log.parse = function (line) {                                                          // 173
  var obj = null;                                                                      // 174
  if (line && line.charAt(0) === '{') { // might be json generated from calling 'Log'  // 175
    try { obj = EJSON.parse(line); } catch (e) {}                                      // 176
  }                                                                                    // 177
                                                                                       // 178
  // XXX should probably check fields other than 'time'                                // 179
  if (obj && obj.time && (obj.time instanceof Date))                                   // 180
    return obj;                                                                        // 181
  else                                                                                 // 182
    return null;                                                                       // 183
};                                                                                     // 184
                                                                                       // 185
// formats a log object into colored human and machine-readable text                   // 186
Log.format = function (obj, options) {                                                 // 187
  obj = EJSON.clone(obj); // don't mutate the argument                                 // 188
  options = options || {};                                                             // 189
                                                                                       // 190
  var time = obj.time;                                                                 // 191
  if (!(time instanceof Date))                                                         // 192
    throw new Error("'time' must be a Date object");                                   // 193
  var timeInexact = obj.timeInexact;                                                   // 194
                                                                                       // 195
  // store fields that are in FORMATTED_KEYS since we strip them                       // 196
  var level = obj.level || 'info';                                                     // 197
  var file = obj.file;                                                                 // 198
  var lineNumber = obj.line;                                                           // 199
  var appName = obj.app || '';                                                         // 200
  var originApp = obj.originApp;                                                       // 201
  var message = obj.message || '';                                                     // 202
  var program = obj.program || '';                                                     // 203
  var satellite = obj.satellite;                                                       // 204
  var stderr = obj.stderr || '';                                                       // 205
                                                                                       // 206
  _.each(FORMATTED_KEYS, function(key) {                                               // 207
    delete obj[key];                                                                   // 208
  });                                                                                  // 209
                                                                                       // 210
  if (!_.isEmpty(obj)) {                                                               // 211
    if (message) message += " ";                                                       // 212
    message += EJSON.stringify(obj);                                                   // 213
  }                                                                                    // 214
                                                                                       // 215
  var pad2 = function(n) { return n < 10 ? '0' + n : n.toString(); };                  // 216
  var pad3 = function(n) { return n < 100 ? '0' + pad2(n) : n.toString(); };           // 217
                                                                                       // 218
  var dateStamp = time.getFullYear().toString() +                                      // 219
    pad2(time.getMonth() + 1 /*0-based*/) +                                            // 220
    pad2(time.getDate());                                                              // 221
  var timeStamp = pad2(time.getHours()) +                                              // 222
        ':' +                                                                          // 223
        pad2(time.getMinutes()) +                                                      // 224
        ':' +                                                                          // 225
        pad2(time.getSeconds()) +                                                      // 226
        '.' +                                                                          // 227
        pad3(time.getMilliseconds());                                                  // 228
                                                                                       // 229
  // eg in San Francisco in June this will be '(-7)'                                   // 230
  var utcOffsetStr = '(' + (-(new Date().getTimezoneOffset() / 60)) + ')';             // 231
                                                                                       // 232
  var appInfo = '';                                                                    // 233
  if (appName) appInfo += appName;                                                     // 234
  if (originApp && originApp !== appName) appInfo += ' via ' + originApp;              // 235
  if (appInfo) appInfo = '[' + appInfo + '] ';                                         // 236
                                                                                       // 237
  var sourceInfoParts = [];                                                            // 238
  if (program) sourceInfoParts.push(program);                                          // 239
  if (file) sourceInfoParts.push(file);                                                // 240
  if (lineNumber) sourceInfoParts.push(lineNumber);                                    // 241
  var sourceInfo = _.isEmpty(sourceInfoParts) ?                                        // 242
    '' : '(' + sourceInfoParts.join(':') + ') ';                                       // 243
                                                                                       // 244
  if (satellite)                                                                       // 245
    sourceInfo += ['[', satellite, ']'].join('');                                      // 246
                                                                                       // 247
  var stderrIndicator = stderr ? '(STDERR) ' : '';                                     // 248
                                                                                       // 249
  var metaPrefix = [                                                                   // 250
    level.charAt(0).toUpperCase(),                                                     // 251
    dateStamp,                                                                         // 252
    '-',                                                                               // 253
    timeStamp,                                                                         // 254
    utcOffsetStr,                                                                      // 255
    timeInexact ? '? ' : ' ',                                                          // 256
    appInfo,                                                                           // 257
    sourceInfo,                                                                        // 258
    stderrIndicator].join('');                                                         // 259
                                                                                       // 260
  var prettify = function (line, color) {                                              // 261
    return (options.color && Meteor.isServer && color) ?                               // 262
      Npm.require('cli-color')[color](line) : line;                                    // 263
  };                                                                                   // 264
                                                                                       // 265
  return prettify(metaPrefix, options.metaColor || META_COLOR) +                       // 266
    prettify(message, LEVEL_COLORS[level]);                                            // 267
};                                                                                     // 268
                                                                                       // 269
// Turn a line of text into a loggable object.                                         // 270
// @param line {String}                                                                // 271
// @param override {Object}                                                            // 272
Log.objFromText = function (line, override) {                                          // 273
  var obj = {message: line, level: "info", time: new Date(), timeInexact: true};       // 274
  return _.extend(obj, override);                                                      // 275
};                                                                                     // 276
                                                                                       // 277
/////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.logging = {
  Log: Log
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var check = Package.check.check;
var Match = Package.check.Match;
var Random = Package.random.Random;
var EJSON = Package.ejson.EJSON;
var JSON = Package.json.JSON;
var _ = Package.underscore._;
var Tracker = Package.tracker.Tracker;
var Deps = Package.tracker.Deps;
var Log = Package.logging.Log;
var Retry = Package.retry.Retry;
var LocalCollection = Package.minimongo.LocalCollection;
var Minimongo = Package.minimongo.Minimongo;

/* Package-scope variables */
var DDP, LivedataTest, SockJS, toSockjsUrl, toWebsocketUrl, Heartbeat, SUPPORTED_DDP_VERSIONS, MethodInvocation, parseDDP, stringifyDDP, RandomStream, makeRpcSeed, allConnections;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/ddp/common.js                                                                                         //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
/**                                                                                                               // 1
 * @namespace DDP                                                                                                 // 2
 * @summary The namespace for DDP-related methods.                                                                // 3
 */                                                                                                               // 4
DDP = {};                                                                                                         // 5
LivedataTest = {};                                                                                                // 6
                                                                                                                  // 7
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/ddp/sockjs-0.3.4.js                                                                                   //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// XXX METEOR changes in <METEOR>                                                                                 // 1
                                                                                                                  // 2
/* SockJS client, version 0.3.4, http://sockjs.org, MIT License                                                   // 3
                                                                                                                  // 4
Copyright (c) 2011-2012 VMware, Inc.                                                                              // 5
                                                                                                                  // 6
Permission is hereby granted, free of charge, to any person obtaining a copy                                      // 7
of this software and associated documentation files (the "Software"), to deal                                     // 8
in the Software without restriction, including without limitation the rights                                      // 9
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                                         // 10
copies of the Software, and to permit persons to whom the Software is                                             // 11
furnished to do so, subject to the following conditions:                                                          // 12
                                                                                                                  // 13
The above copyright notice and this permission notice shall be included in                                        // 14
all copies or substantial portions of the Software.                                                               // 15
                                                                                                                  // 16
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                        // 17
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                          // 18
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                       // 19
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                            // 20
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                     // 21
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN                                         // 22
THE SOFTWARE.                                                                                                     // 23
*/                                                                                                                // 24
                                                                                                                  // 25
// <METEOR> Commented out JSO implementation (use json package instead).                                          // 26
// JSON2 by Douglas Crockford (minified).                                                                         // 27
// var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i=="object"&&typeof i.toJSON=="function"&&(i=i.toJSON(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g;return e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function f(a){return a<10?"0"+a:a}"use strict",typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;typeof JSON.stringify!="function"&&(JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")}),typeof JSON.parse!="function"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver=="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")})}()
// </METEOR>                                                                                                      // 29
                                                                                                                  // 30
//     [*] Including lib/index.js                                                                                 // 31
// Public object                                                                                                  // 32
SockJS = (function(){                                                                                             // 33
              var _document = document;                                                                           // 34
              var _window = window;                                                                               // 35
              var utils = {};                                                                                     // 36
                                                                                                                  // 37
                                                                                                                  // 38
//         [*] Including lib/reventtarget.js                                                                      // 39
/*                                                                                                                // 40
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 41
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 42
 *                                                                                                                // 43
 * For the license see COPYING.                                                                                   // 44
 * ***** END LICENSE BLOCK *****                                                                                  // 45
 */                                                                                                               // 46
                                                                                                                  // 47
/* Simplified implementation of DOM2 EventTarget.                                                                 // 48
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget                                       // 49
 */                                                                                                               // 50
var REventTarget = function() {};                                                                                 // 51
REventTarget.prototype.addEventListener = function (eventType, listener) {                                        // 52
    if(!this._listeners) {                                                                                        // 53
         this._listeners = {};                                                                                    // 54
    }                                                                                                             // 55
    if(!(eventType in this._listeners)) {                                                                         // 56
        this._listeners[eventType] = [];                                                                          // 57
    }                                                                                                             // 58
    var arr = this._listeners[eventType];                                                                         // 59
    if(utils.arrIndexOf(arr, listener) === -1) {                                                                  // 60
        arr.push(listener);                                                                                       // 61
    }                                                                                                             // 62
    return;                                                                                                       // 63
};                                                                                                                // 64
                                                                                                                  // 65
REventTarget.prototype.removeEventListener = function (eventType, listener) {                                     // 66
    if(!(this._listeners && (eventType in this._listeners))) {                                                    // 67
        return;                                                                                                   // 68
    }                                                                                                             // 69
    var arr = this._listeners[eventType];                                                                         // 70
    var idx = utils.arrIndexOf(arr, listener);                                                                    // 71
    if (idx !== -1) {                                                                                             // 72
        if(arr.length > 1) {                                                                                      // 73
            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );                            // 74
        } else {                                                                                                  // 75
            delete this._listeners[eventType];                                                                    // 76
        }                                                                                                         // 77
        return;                                                                                                   // 78
    }                                                                                                             // 79
    return;                                                                                                       // 80
};                                                                                                                // 81
                                                                                                                  // 82
REventTarget.prototype.dispatchEvent = function (event) {                                                         // 83
    var t = event.type;                                                                                           // 84
    var args = Array.prototype.slice.call(arguments, 0);                                                          // 85
    if (this['on'+t]) {                                                                                           // 86
        this['on'+t].apply(this, args);                                                                           // 87
    }                                                                                                             // 88
    if (this._listeners && t in this._listeners) {                                                                // 89
        for(var i=0; i < this._listeners[t].length; i++) {                                                        // 90
            this._listeners[t][i].apply(this, args);                                                              // 91
        }                                                                                                         // 92
    }                                                                                                             // 93
};                                                                                                                // 94
//         [*] End of lib/reventtarget.js                                                                         // 95
                                                                                                                  // 96
                                                                                                                  // 97
//         [*] Including lib/simpleevent.js                                                                       // 98
/*                                                                                                                // 99
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 100
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 101
 *                                                                                                                // 102
 * For the license see COPYING.                                                                                   // 103
 * ***** END LICENSE BLOCK *****                                                                                  // 104
 */                                                                                                               // 105
                                                                                                                  // 106
var SimpleEvent = function(type, obj) {                                                                           // 107
    this.type = type;                                                                                             // 108
    if (typeof obj !== 'undefined') {                                                                             // 109
        for(var k in obj) {                                                                                       // 110
            if (!obj.hasOwnProperty(k)) continue;                                                                 // 111
            this[k] = obj[k];                                                                                     // 112
        }                                                                                                         // 113
    }                                                                                                             // 114
};                                                                                                                // 115
                                                                                                                  // 116
SimpleEvent.prototype.toString = function() {                                                                     // 117
    var r = [];                                                                                                   // 118
    for(var k in this) {                                                                                          // 119
        if (!this.hasOwnProperty(k)) continue;                                                                    // 120
        var v = this[k];                                                                                          // 121
        if (typeof v === 'function') v = '[function]';                                                            // 122
        r.push(k + '=' + v);                                                                                      // 123
    }                                                                                                             // 124
    return 'SimpleEvent(' + r.join(', ') + ')';                                                                   // 125
};                                                                                                                // 126
//         [*] End of lib/simpleevent.js                                                                          // 127
                                                                                                                  // 128
                                                                                                                  // 129
//         [*] Including lib/eventemitter.js                                                                      // 130
/*                                                                                                                // 131
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 132
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 133
 *                                                                                                                // 134
 * For the license see COPYING.                                                                                   // 135
 * ***** END LICENSE BLOCK *****                                                                                  // 136
 */                                                                                                               // 137
                                                                                                                  // 138
var EventEmitter = function(events) {                                                                             // 139
    var that = this;                                                                                              // 140
    that._events = events || [];                                                                                  // 141
    that._listeners = {};                                                                                         // 142
};                                                                                                                // 143
EventEmitter.prototype.emit = function(type) {                                                                    // 144
    var that = this;                                                                                              // 145
    that._verifyType(type);                                                                                       // 146
    if (that._nuked) return;                                                                                      // 147
                                                                                                                  // 148
    var args = Array.prototype.slice.call(arguments, 1);                                                          // 149
    if (that['on'+type]) {                                                                                        // 150
        that['on'+type].apply(that, args);                                                                        // 151
    }                                                                                                             // 152
    if (type in that._listeners) {                                                                                // 153
        for(var i = 0; i < that._listeners[type].length; i++) {                                                   // 154
            that._listeners[type][i].apply(that, args);                                                           // 155
        }                                                                                                         // 156
    }                                                                                                             // 157
};                                                                                                                // 158
                                                                                                                  // 159
EventEmitter.prototype.on = function(type, callback) {                                                            // 160
    var that = this;                                                                                              // 161
    that._verifyType(type);                                                                                       // 162
    if (that._nuked) return;                                                                                      // 163
                                                                                                                  // 164
    if (!(type in that._listeners)) {                                                                             // 165
        that._listeners[type] = [];                                                                               // 166
    }                                                                                                             // 167
    that._listeners[type].push(callback);                                                                         // 168
};                                                                                                                // 169
                                                                                                                  // 170
EventEmitter.prototype._verifyType = function(type) {                                                             // 171
    var that = this;                                                                                              // 172
    if (utils.arrIndexOf(that._events, type) === -1) {                                                            // 173
        utils.log('Event ' + JSON.stringify(type) +                                                               // 174
                  ' not listed ' + JSON.stringify(that._events) +                                                 // 175
                  ' in ' + that);                                                                                 // 176
    }                                                                                                             // 177
};                                                                                                                // 178
                                                                                                                  // 179
EventEmitter.prototype.nuke = function() {                                                                        // 180
    var that = this;                                                                                              // 181
    that._nuked = true;                                                                                           // 182
    for(var i=0; i<that._events.length; i++) {                                                                    // 183
        delete that[that._events[i]];                                                                             // 184
    }                                                                                                             // 185
    that._listeners = {};                                                                                         // 186
};                                                                                                                // 187
//         [*] End of lib/eventemitter.js                                                                         // 188
                                                                                                                  // 189
                                                                                                                  // 190
//         [*] Including lib/utils.js                                                                             // 191
/*                                                                                                                // 192
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 193
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 194
 *                                                                                                                // 195
 * For the license see COPYING.                                                                                   // 196
 * ***** END LICENSE BLOCK *****                                                                                  // 197
 */                                                                                                               // 198
                                                                                                                  // 199
var random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';                                                // 200
utils.random_string = function(length, max) {                                                                     // 201
    max = max || random_string_chars.length;                                                                      // 202
    var i, ret = [];                                                                                              // 203
    for(i=0; i < length; i++) {                                                                                   // 204
        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );                                // 205
    }                                                                                                             // 206
    return ret.join('');                                                                                          // 207
};                                                                                                                // 208
utils.random_number = function(max) {                                                                             // 209
    return Math.floor(Math.random() * max);                                                                       // 210
};                                                                                                                // 211
utils.random_number_string = function(max) {                                                                      // 212
    var t = (''+(max - 1)).length;                                                                                // 213
    var p = Array(t+1).join('0');                                                                                 // 214
    return (p + utils.random_number(max)).slice(-t);                                                              // 215
};                                                                                                                // 216
                                                                                                                  // 217
// Assuming that url looks like: http://asdasd:111/asd                                                            // 218
utils.getOrigin = function(url) {                                                                                 // 219
    url += '/';                                                                                                   // 220
    var parts = url.split('/').slice(0, 3);                                                                       // 221
    return parts.join('/');                                                                                       // 222
};                                                                                                                // 223
                                                                                                                  // 224
utils.isSameOriginUrl = function(url_a, url_b) {                                                                  // 225
    // location.origin would do, but it's not always available.                                                   // 226
    if (!url_b) url_b = _window.location.href;                                                                    // 227
                                                                                                                  // 228
    return (url_a.split('/').slice(0,3).join('/')                                                                 // 229
                ===                                                                                               // 230
            url_b.split('/').slice(0,3).join('/'));                                                               // 231
};                                                                                                                // 232
                                                                                                                  // 233
// <METEOR>                                                                                                       // 234
// https://github.com/sockjs/sockjs-client/issues/79                                                              // 235
utils.isSameOriginScheme = function(url_a, url_b) {                                                               // 236
    if (!url_b) url_b = _window.location.href;                                                                    // 237
                                                                                                                  // 238
    return (url_a.split(':')[0]                                                                                   // 239
                ===                                                                                               // 240
            url_b.split(':')[0]);                                                                                 // 241
};                                                                                                                // 242
// </METEOR>                                                                                                      // 243
                                                                                                                  // 244
                                                                                                                  // 245
utils.getParentDomain = function(url) {                                                                           // 246
    // ipv4 ip address                                                                                            // 247
    if (/^[0-9.]*$/.test(url)) return url;                                                                        // 248
    // ipv6 ip address                                                                                            // 249
    if (/^\[/.test(url)) return url;                                                                              // 250
    // no dots                                                                                                    // 251
    if (!(/[.]/.test(url))) return url;                                                                           // 252
                                                                                                                  // 253
    var parts = url.split('.').slice(1);                                                                          // 254
    return parts.join('.');                                                                                       // 255
};                                                                                                                // 256
                                                                                                                  // 257
utils.objectExtend = function(dst, src) {                                                                         // 258
    for(var k in src) {                                                                                           // 259
        if (src.hasOwnProperty(k)) {                                                                              // 260
            dst[k] = src[k];                                                                                      // 261
        }                                                                                                         // 262
    }                                                                                                             // 263
    return dst;                                                                                                   // 264
};                                                                                                                // 265
                                                                                                                  // 266
var WPrefix = '_jp';                                                                                              // 267
                                                                                                                  // 268
utils.polluteGlobalNamespace = function() {                                                                       // 269
    if (!(WPrefix in _window)) {                                                                                  // 270
        _window[WPrefix] = {};                                                                                    // 271
    }                                                                                                             // 272
};                                                                                                                // 273
                                                                                                                  // 274
utils.closeFrame = function (code, reason) {                                                                      // 275
    return 'c'+JSON.stringify([code, reason]);                                                                    // 276
};                                                                                                                // 277
                                                                                                                  // 278
utils.userSetCode = function (code) {                                                                             // 279
    return code === 1000 || (code >= 3000 && code <= 4999);                                                       // 280
};                                                                                                                // 281
                                                                                                                  // 282
// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/                                         // 283
// and RFC 2988.                                                                                                  // 284
utils.countRTO = function (rtt) {                                                                                 // 285
    var rto;                                                                                                      // 286
    if (rtt > 100) {                                                                                              // 287
        rto = 3 * rtt; // rto > 300msec                                                                           // 288
    } else {                                                                                                      // 289
        rto = rtt + 200; // 200msec < rto <= 300msec                                                              // 290
    }                                                                                                             // 291
    return rto;                                                                                                   // 292
}                                                                                                                 // 293
                                                                                                                  // 294
utils.log = function() {                                                                                          // 295
    if (_window.console && console.log && console.log.apply) {                                                    // 296
        console.log.apply(console, arguments);                                                                    // 297
    }                                                                                                             // 298
};                                                                                                                // 299
                                                                                                                  // 300
utils.bind = function(fun, that) {                                                                                // 301
    if (fun.bind) {                                                                                               // 302
        return fun.bind(that);                                                                                    // 303
    } else {                                                                                                      // 304
        return function() {                                                                                       // 305
            return fun.apply(that, arguments);                                                                    // 306
        };                                                                                                        // 307
    }                                                                                                             // 308
};                                                                                                                // 309
                                                                                                                  // 310
utils.flatUrl = function(url) {                                                                                   // 311
    return url.indexOf('?') === -1 && url.indexOf('#') === -1;                                                    // 312
};                                                                                                                // 313
                                                                                                                  // 314
// `relativeTo` is an optional absolute URL. If provided, `url` will be                                           // 315
// interpreted relative to `relativeTo`. Defaults to `document.location`.                                         // 316
// <METEOR>                                                                                                       // 317
utils.amendUrl = function(url, relativeTo) {                                                                      // 318
    var baseUrl;                                                                                                  // 319
    if (relativeTo === undefined) {                                                                               // 320
      baseUrl = _document.location;                                                                               // 321
    } else {                                                                                                      // 322
      var protocolMatch = /^([a-z0-9.+-]+:)/i.exec(relativeTo);                                                   // 323
      if (protocolMatch) {                                                                                        // 324
        var protocol = protocolMatch[0].toLowerCase();                                                            // 325
        var rest = relativeTo.substring(protocol.length);                                                         // 326
        var hostMatch = /[a-z0-9\.-]+(:[0-9]+)?/.exec(rest);                                                      // 327
        if (hostMatch)                                                                                            // 328
          var host = hostMatch[0];                                                                                // 329
      }                                                                                                           // 330
      if (! protocol || ! host)                                                                                   // 331
        throw new Error("relativeTo must be an absolute url");                                                    // 332
      baseUrl = {                                                                                                 // 333
        protocol: protocol,                                                                                       // 334
        host: host                                                                                                // 335
      };                                                                                                          // 336
    }                                                                                                             // 337
    if (!url) {                                                                                                   // 338
        throw new Error('Wrong url for SockJS');                                                                  // 339
    }                                                                                                             // 340
    if (!utils.flatUrl(url)) {                                                                                    // 341
        throw new Error('Only basic urls are supported in SockJS');                                               // 342
    }                                                                                                             // 343
                                                                                                                  // 344
    //  '//abc' --> 'http://abc'                                                                                  // 345
    if (url.indexOf('//') === 0) {                                                                                // 346
        url = baseUrl.protocol + url;                                                                             // 347
    }                                                                                                             // 348
    // '/abc' --> 'http://localhost:1234/abc'                                                                     // 349
    if (url.indexOf('/') === 0) {                                                                                 // 350
        url = baseUrl.protocol + '//' + baseUrl.host + url;                                                       // 351
    }                                                                                                             // 352
    // </METEOR>                                                                                                  // 353
    // strip trailing slashes                                                                                     // 354
    url = url.replace(/[/]+$/,'');                                                                                // 355
                                                                                                                  // 356
    // We have a full url here, with proto and host. For some browsers                                            // 357
    // http://localhost:80/ is not in the same origin as http://localhost/                                        // 358
	// Remove explicit :80 or :443 in such cases. See #74                                                            // 359
    var parts = url.split("/");                                                                                   // 360
    if ((parts[0] === "http:" && /:80$/.test(parts[2])) ||                                                        // 361
	    (parts[0] === "https:" && /:443$/.test(parts[2]))) {                                                         // 362
		parts[2] = parts[2].replace(/:(80|443)$/, "");                                                                  // 363
	}                                                                                                                // 364
    url = parts.join("/");                                                                                        // 365
    return url;                                                                                                   // 366
};                                                                                                                // 367
                                                                                                                  // 368
// IE doesn't support [].indexOf.                                                                                 // 369
utils.arrIndexOf = function(arr, obj){                                                                            // 370
    for(var i=0; i < arr.length; i++){                                                                            // 371
        if(arr[i] === obj){                                                                                       // 372
            return i;                                                                                             // 373
        }                                                                                                         // 374
    }                                                                                                             // 375
    return -1;                                                                                                    // 376
};                                                                                                                // 377
                                                                                                                  // 378
utils.arrSkip = function(arr, obj) {                                                                              // 379
    var idx = utils.arrIndexOf(arr, obj);                                                                         // 380
    if (idx === -1) {                                                                                             // 381
        return arr.slice();                                                                                       // 382
    } else {                                                                                                      // 383
        var dst = arr.slice(0, idx);                                                                              // 384
        return dst.concat(arr.slice(idx+1));                                                                      // 385
    }                                                                                                             // 386
};                                                                                                                // 387
                                                                                                                  // 388
// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df                                  // 389
utils.isArray = Array.isArray || function(value) {                                                                // 390
    return {}.toString.call(value).indexOf('Array') >= 0                                                          // 391
};                                                                                                                // 392
                                                                                                                  // 393
utils.delay = function(t, fun) {                                                                                  // 394
    if(typeof t === 'function') {                                                                                 // 395
        fun = t;                                                                                                  // 396
        t = 0;                                                                                                    // 397
    }                                                                                                             // 398
    return setTimeout(fun, t);                                                                                    // 399
};                                                                                                                // 400
                                                                                                                  // 401
                                                                                                                  // 402
// Chars worth escaping, as defined by Douglas Crockford:                                                         // 403
//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196      // 404
var json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    json_lookup = {                                                                                               // 406
"\u0000":"\\u0000","\u0001":"\\u0001","\u0002":"\\u0002","\u0003":"\\u0003",                                      // 407
"\u0004":"\\u0004","\u0005":"\\u0005","\u0006":"\\u0006","\u0007":"\\u0007",                                      // 408
"\b":"\\b","\t":"\\t","\n":"\\n","\u000b":"\\u000b","\f":"\\f","\r":"\\r",                                        // 409
"\u000e":"\\u000e","\u000f":"\\u000f","\u0010":"\\u0010","\u0011":"\\u0011",                                      // 410
"\u0012":"\\u0012","\u0013":"\\u0013","\u0014":"\\u0014","\u0015":"\\u0015",                                      // 411
"\u0016":"\\u0016","\u0017":"\\u0017","\u0018":"\\u0018","\u0019":"\\u0019",                                      // 412
"\u001a":"\\u001a","\u001b":"\\u001b","\u001c":"\\u001c","\u001d":"\\u001d",                                      // 413
"\u001e":"\\u001e","\u001f":"\\u001f","\"":"\\\"","\\":"\\\\",                                                    // 414
"\u007f":"\\u007f","\u0080":"\\u0080","\u0081":"\\u0081","\u0082":"\\u0082",                                      // 415
"\u0083":"\\u0083","\u0084":"\\u0084","\u0085":"\\u0085","\u0086":"\\u0086",                                      // 416
"\u0087":"\\u0087","\u0088":"\\u0088","\u0089":"\\u0089","\u008a":"\\u008a",                                      // 417
"\u008b":"\\u008b","\u008c":"\\u008c","\u008d":"\\u008d","\u008e":"\\u008e",                                      // 418
"\u008f":"\\u008f","\u0090":"\\u0090","\u0091":"\\u0091","\u0092":"\\u0092",                                      // 419
"\u0093":"\\u0093","\u0094":"\\u0094","\u0095":"\\u0095","\u0096":"\\u0096",                                      // 420
"\u0097":"\\u0097","\u0098":"\\u0098","\u0099":"\\u0099","\u009a":"\\u009a",                                      // 421
"\u009b":"\\u009b","\u009c":"\\u009c","\u009d":"\\u009d","\u009e":"\\u009e",                                      // 422
"\u009f":"\\u009f","\u00ad":"\\u00ad","\u0600":"\\u0600","\u0601":"\\u0601",                                      // 423
"\u0602":"\\u0602","\u0603":"\\u0603","\u0604":"\\u0604","\u070f":"\\u070f",                                      // 424
"\u17b4":"\\u17b4","\u17b5":"\\u17b5","\u200c":"\\u200c","\u200d":"\\u200d",                                      // 425
"\u200e":"\\u200e","\u200f":"\\u200f","\u2028":"\\u2028","\u2029":"\\u2029",                                      // 426
"\u202a":"\\u202a","\u202b":"\\u202b","\u202c":"\\u202c","\u202d":"\\u202d",                                      // 427
"\u202e":"\\u202e","\u202f":"\\u202f","\u2060":"\\u2060","\u2061":"\\u2061",                                      // 428
"\u2062":"\\u2062","\u2063":"\\u2063","\u2064":"\\u2064","\u2065":"\\u2065",                                      // 429
"\u2066":"\\u2066","\u2067":"\\u2067","\u2068":"\\u2068","\u2069":"\\u2069",                                      // 430
"\u206a":"\\u206a","\u206b":"\\u206b","\u206c":"\\u206c","\u206d":"\\u206d",                                      // 431
"\u206e":"\\u206e","\u206f":"\\u206f","\ufeff":"\\ufeff","\ufff0":"\\ufff0",                                      // 432
"\ufff1":"\\ufff1","\ufff2":"\\ufff2","\ufff3":"\\ufff3","\ufff4":"\\ufff4",                                      // 433
"\ufff5":"\\ufff5","\ufff6":"\\ufff6","\ufff7":"\\ufff7","\ufff8":"\\ufff8",                                      // 434
"\ufff9":"\\ufff9","\ufffa":"\\ufffa","\ufffb":"\\ufffb","\ufffc":"\\ufffc",                                      // 435
"\ufffd":"\\ufffd","\ufffe":"\\ufffe","\uffff":"\\uffff"};                                                        // 436
                                                                                                                  // 437
// Some extra characters that Chrome gets wrong, and substitutes with                                             // 438
// something else on the wire.                                                                                    // 439
var extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
    extra_lookup;                                                                                                 // 441
                                                                                                                  // 442
// JSON Quote string. Use native implementation when possible.                                                    // 443
var JSONQuote = (JSON && JSON.stringify) || function(string) {                                                    // 444
    json_escapable.lastIndex = 0;                                                                                 // 445
    if (json_escapable.test(string)) {                                                                            // 446
        string = string.replace(json_escapable, function(a) {                                                     // 447
            return json_lookup[a];                                                                                // 448
        });                                                                                                       // 449
    }                                                                                                             // 450
    return '"' + string + '"';                                                                                    // 451
};                                                                                                                // 452
                                                                                                                  // 453
// This may be quite slow, so let's delay until user actually uses bad                                            // 454
// characters.                                                                                                    // 455
var unroll_lookup = function(escapable) {                                                                         // 456
    var i;                                                                                                        // 457
    var unrolled = {}                                                                                             // 458
    var c = []                                                                                                    // 459
    for(i=0; i<65536; i++) {                                                                                      // 460
        c.push( String.fromCharCode(i) );                                                                         // 461
    }                                                                                                             // 462
    escapable.lastIndex = 0;                                                                                      // 463
    c.join('').replace(escapable, function (a) {                                                                  // 464
        unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                                // 465
        return '';                                                                                                // 466
    });                                                                                                           // 467
    escapable.lastIndex = 0;                                                                                      // 468
    return unrolled;                                                                                              // 469
};                                                                                                                // 470
                                                                                                                  // 471
// Quote string, also taking care of unicode characters that browsers                                             // 472
// often break. Especially, take care of unicode surrogates:                                                      // 473
//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates                                       // 474
utils.quote = function(string) {                                                                                  // 475
    var quoted = JSONQuote(string);                                                                               // 476
                                                                                                                  // 477
    // In most cases this should be very fast and good enough.                                                    // 478
    extra_escapable.lastIndex = 0;                                                                                // 479
    if(!extra_escapable.test(quoted)) {                                                                           // 480
        return quoted;                                                                                            // 481
    }                                                                                                             // 482
                                                                                                                  // 483
    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);                                              // 484
                                                                                                                  // 485
    return quoted.replace(extra_escapable, function(a) {                                                          // 486
        return extra_lookup[a];                                                                                   // 487
    });                                                                                                           // 488
}                                                                                                                 // 489
                                                                                                                  // 490
var _all_protocols = ['websocket',                                                                                // 491
                      'xdr-streaming',                                                                            // 492
                      'xhr-streaming',                                                                            // 493
                      'iframe-eventsource',                                                                       // 494
                      'iframe-htmlfile',                                                                          // 495
                      'xdr-polling',                                                                              // 496
                      'xhr-polling',                                                                              // 497
                      'iframe-xhr-polling',                                                                       // 498
                      'jsonp-polling'];                                                                           // 499
                                                                                                                  // 500
utils.probeProtocols = function() {                                                                               // 501
    var probed = {};                                                                                              // 502
    for(var i=0; i<_all_protocols.length; i++) {                                                                  // 503
        var protocol = _all_protocols[i];                                                                         // 504
        // User can have a typo in protocol name.                                                                 // 505
        probed[protocol] = SockJS[protocol] &&                                                                    // 506
                           SockJS[protocol].enabled();                                                            // 507
    }                                                                                                             // 508
    return probed;                                                                                                // 509
};                                                                                                                // 510
                                                                                                                  // 511
utils.detectProtocols = function(probed, protocols_whitelist, info) {                                             // 512
    var pe = {},                                                                                                  // 513
        protocols = [];                                                                                           // 514
    if (!protocols_whitelist) protocols_whitelist = _all_protocols;                                               // 515
    for(var i=0; i<protocols_whitelist.length; i++) {                                                             // 516
        var protocol = protocols_whitelist[i];                                                                    // 517
        pe[protocol] = probed[protocol];                                                                          // 518
    }                                                                                                             // 519
    var maybe_push = function(protos) {                                                                           // 520
        var proto = protos.shift();                                                                               // 521
        if (pe[proto]) {                                                                                          // 522
            protocols.push(proto);                                                                                // 523
        } else {                                                                                                  // 524
            if (protos.length > 0) {                                                                              // 525
                maybe_push(protos);                                                                               // 526
            }                                                                                                     // 527
        }                                                                                                         // 528
    }                                                                                                             // 529
                                                                                                                  // 530
    // 1. Websocket                                                                                               // 531
    if (info.websocket !== false) {                                                                               // 532
        maybe_push(['websocket']);                                                                                // 533
    }                                                                                                             // 534
                                                                                                                  // 535
    // 2. Streaming                                                                                               // 536
    if (pe['xhr-streaming'] && !info.null_origin) {                                                               // 537
        protocols.push('xhr-streaming');                                                                          // 538
    } else {                                                                                                      // 539
        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {                                    // 540
            protocols.push('xdr-streaming');                                                                      // 541
        } else {                                                                                                  // 542
            maybe_push(['iframe-eventsource',                                                                     // 543
                        'iframe-htmlfile']);                                                                      // 544
        }                                                                                                         // 545
    }                                                                                                             // 546
                                                                                                                  // 547
    // 3. Polling                                                                                                 // 548
    if (pe['xhr-polling'] && !info.null_origin) {                                                                 // 549
        protocols.push('xhr-polling');                                                                            // 550
    } else {                                                                                                      // 551
        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {                                      // 552
            protocols.push('xdr-polling');                                                                        // 553
        } else {                                                                                                  // 554
            maybe_push(['iframe-xhr-polling',                                                                     // 555
                        'jsonp-polling']);                                                                        // 556
        }                                                                                                         // 557
    }                                                                                                             // 558
    return protocols;                                                                                             // 559
}                                                                                                                 // 560
//         [*] End of lib/utils.js                                                                                // 561
                                                                                                                  // 562
                                                                                                                  // 563
//         [*] Including lib/dom.js                                                                               // 564
/*                                                                                                                // 565
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 566
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 567
 *                                                                                                                // 568
 * For the license see COPYING.                                                                                   // 569
 * ***** END LICENSE BLOCK *****                                                                                  // 570
 */                                                                                                               // 571
                                                                                                                  // 572
// May be used by htmlfile jsonp and transports.                                                                  // 573
var MPrefix = '_sockjs_global';                                                                                   // 574
utils.createHook = function() {                                                                                   // 575
    var window_id = 'a' + utils.random_string(8);                                                                 // 576
    if (!(MPrefix in _window)) {                                                                                  // 577
        var map = {};                                                                                             // 578
        _window[MPrefix] = function(window_id) {                                                                  // 579
            if (!(window_id in map)) {                                                                            // 580
                map[window_id] = {                                                                                // 581
                    id: window_id,                                                                                // 582
                    del: function() {delete map[window_id];}                                                      // 583
                };                                                                                                // 584
            }                                                                                                     // 585
            return map[window_id];                                                                                // 586
        }                                                                                                         // 587
    }                                                                                                             // 588
    return _window[MPrefix](window_id);                                                                           // 589
};                                                                                                                // 590
                                                                                                                  // 591
                                                                                                                  // 592
                                                                                                                  // 593
utils.attachMessage = function(listener) {                                                                        // 594
    utils.attachEvent('message', listener);                                                                       // 595
};                                                                                                                // 596
utils.attachEvent = function(event, listener) {                                                                   // 597
    if (typeof _window.addEventListener !== 'undefined') {                                                        // 598
        _window.addEventListener(event, listener, false);                                                         // 599
    } else {                                                                                                      // 600
        // IE quirks.                                                                                             // 601
        // According to: http://stevesouders.com/misc/test-postmessage.php                                        // 602
        // the message gets delivered only to 'document', not 'window'.                                           // 603
        _document.attachEvent("on" + event, listener);                                                            // 604
        // I get 'window' for ie8.                                                                                // 605
        _window.attachEvent("on" + event, listener);                                                              // 606
    }                                                                                                             // 607
};                                                                                                                // 608
                                                                                                                  // 609
utils.detachMessage = function(listener) {                                                                        // 610
    utils.detachEvent('message', listener);                                                                       // 611
};                                                                                                                // 612
utils.detachEvent = function(event, listener) {                                                                   // 613
    if (typeof _window.addEventListener !== 'undefined') {                                                        // 614
        _window.removeEventListener(event, listener, false);                                                      // 615
    } else {                                                                                                      // 616
        _document.detachEvent("on" + event, listener);                                                            // 617
        _window.detachEvent("on" + event, listener);                                                              // 618
    }                                                                                                             // 619
};                                                                                                                // 620
                                                                                                                  // 621
                                                                                                                  // 622
var on_unload = {};                                                                                               // 623
// Things registered after beforeunload are to be called immediately.                                             // 624
var after_unload = false;                                                                                         // 625
                                                                                                                  // 626
var trigger_unload_callbacks = function() {                                                                       // 627
    for(var ref in on_unload) {                                                                                   // 628
        on_unload[ref]();                                                                                         // 629
        delete on_unload[ref];                                                                                    // 630
    };                                                                                                            // 631
};                                                                                                                // 632
                                                                                                                  // 633
var unload_triggered = function() {                                                                               // 634
    if(after_unload) return;                                                                                      // 635
    after_unload = true;                                                                                          // 636
    trigger_unload_callbacks();                                                                                   // 637
};                                                                                                                // 638
                                                                                                                  // 639
// 'unload' alone is not reliable in opera within an iframe, but we                                               // 640
// can't use `beforeunload` as IE fires it on javascript: links.                                                  // 641
utils.attachEvent('unload', unload_triggered);                                                                    // 642
                                                                                                                  // 643
utils.unload_add = function(listener) {                                                                           // 644
    var ref = utils.random_string(8);                                                                             // 645
    on_unload[ref] = listener;                                                                                    // 646
    if (after_unload) {                                                                                           // 647
        utils.delay(trigger_unload_callbacks);                                                                    // 648
    }                                                                                                             // 649
    return ref;                                                                                                   // 650
};                                                                                                                // 651
utils.unload_del = function(ref) {                                                                                // 652
    if (ref in on_unload)                                                                                         // 653
        delete on_unload[ref];                                                                                    // 654
};                                                                                                                // 655
                                                                                                                  // 656
                                                                                                                  // 657
utils.createIframe = function (iframe_url, error_callback) {                                                      // 658
    var iframe = _document.createElement('iframe');                                                               // 659
    var tref, unload_ref;                                                                                         // 660
    var unattach = function() {                                                                                   // 661
        clearTimeout(tref);                                                                                       // 662
        // Explorer had problems with that.                                                                       // 663
        try {iframe.onload = null;} catch (x) {}                                                                  // 664
        iframe.onerror = null;                                                                                    // 665
    };                                                                                                            // 666
    var cleanup = function() {                                                                                    // 667
        if (iframe) {                                                                                             // 668
            unattach();                                                                                           // 669
            // This timeout makes chrome fire onbeforeunload event                                                // 670
            // within iframe. Without the timeout it goes straight to                                             // 671
            // onunload.                                                                                          // 672
            setTimeout(function() {                                                                               // 673
                if(iframe) {                                                                                      // 674
                    iframe.parentNode.removeChild(iframe);                                                        // 675
                }                                                                                                 // 676
                iframe = null;                                                                                    // 677
            }, 0);                                                                                                // 678
            utils.unload_del(unload_ref);                                                                         // 679
        }                                                                                                         // 680
    };                                                                                                            // 681
    var onerror = function(r) {                                                                                   // 682
        if (iframe) {                                                                                             // 683
            cleanup();                                                                                            // 684
            error_callback(r);                                                                                    // 685
        }                                                                                                         // 686
    };                                                                                                            // 687
    var post = function(msg, origin) {                                                                            // 688
        try {                                                                                                     // 689
            // When the iframe is not loaded, IE raises an exception                                              // 690
            // on 'contentWindow'.                                                                                // 691
            if (iframe && iframe.contentWindow) {                                                                 // 692
                iframe.contentWindow.postMessage(msg, origin);                                                    // 693
            }                                                                                                     // 694
        } catch (x) {};                                                                                           // 695
    };                                                                                                            // 696
                                                                                                                  // 697
    iframe.src = iframe_url;                                                                                      // 698
    iframe.style.display = 'none';                                                                                // 699
    iframe.style.position = 'absolute';                                                                           // 700
    iframe.onerror = function(){onerror('onerror');};                                                             // 701
    iframe.onload = function() {                                                                                  // 702
        // `onload` is triggered before scripts on the iframe are                                                 // 703
        // executed. Give it few seconds to actually load stuff.                                                  // 704
        clearTimeout(tref);                                                                                       // 705
        tref = setTimeout(function(){onerror('onload timeout');}, 2000);                                          // 706
    };                                                                                                            // 707
    _document.body.appendChild(iframe);                                                                           // 708
    tref = setTimeout(function(){onerror('timeout');}, 15000);                                                    // 709
    unload_ref = utils.unload_add(cleanup);                                                                       // 710
    return {                                                                                                      // 711
        post: post,                                                                                               // 712
        cleanup: cleanup,                                                                                         // 713
        loaded: unattach                                                                                          // 714
    };                                                                                                            // 715
};                                                                                                                // 716
                                                                                                                  // 717
utils.createHtmlfile = function (iframe_url, error_callback) {                                                    // 718
    var doc = new ActiveXObject('htmlfile');                                                                      // 719
    var tref, unload_ref;                                                                                         // 720
    var iframe;                                                                                                   // 721
    var unattach = function() {                                                                                   // 722
        clearTimeout(tref);                                                                                       // 723
    };                                                                                                            // 724
    var cleanup = function() {                                                                                    // 725
        if (doc) {                                                                                                // 726
            unattach();                                                                                           // 727
            utils.unload_del(unload_ref);                                                                         // 728
            iframe.parentNode.removeChild(iframe);                                                                // 729
            iframe = doc = null;                                                                                  // 730
            CollectGarbage();                                                                                     // 731
        }                                                                                                         // 732
    };                                                                                                            // 733
    var onerror = function(r)  {                                                                                  // 734
        if (doc) {                                                                                                // 735
            cleanup();                                                                                            // 736
            error_callback(r);                                                                                    // 737
        }                                                                                                         // 738
    };                                                                                                            // 739
    var post = function(msg, origin) {                                                                            // 740
        try {                                                                                                     // 741
            // When the iframe is not loaded, IE raises an exception                                              // 742
            // on 'contentWindow'.                                                                                // 743
            if (iframe && iframe.contentWindow) {                                                                 // 744
                iframe.contentWindow.postMessage(msg, origin);                                                    // 745
            }                                                                                                     // 746
        } catch (x) {};                                                                                           // 747
    };                                                                                                            // 748
                                                                                                                  // 749
    doc.open();                                                                                                   // 750
    doc.write('<html><s' + 'cript>' +                                                                             // 751
              'document.domain="' + document.domain + '";' +                                                      // 752
              '</s' + 'cript></html>');                                                                           // 753
    doc.close();                                                                                                  // 754
    doc.parentWindow[WPrefix] = _window[WPrefix];                                                                 // 755
    var c = doc.createElement('div');                                                                             // 756
    doc.body.appendChild(c);                                                                                      // 757
    iframe = doc.createElement('iframe');                                                                         // 758
    c.appendChild(iframe);                                                                                        // 759
    iframe.src = iframe_url;                                                                                      // 760
    tref = setTimeout(function(){onerror('timeout');}, 15000);                                                    // 761
    unload_ref = utils.unload_add(cleanup);                                                                       // 762
    return {                                                                                                      // 763
        post: post,                                                                                               // 764
        cleanup: cleanup,                                                                                         // 765
        loaded: unattach                                                                                          // 766
    };                                                                                                            // 767
};                                                                                                                // 768
//         [*] End of lib/dom.js                                                                                  // 769
                                                                                                                  // 770
                                                                                                                  // 771
//         [*] Including lib/dom2.js                                                                              // 772
/*                                                                                                                // 773
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 774
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 775
 *                                                                                                                // 776
 * For the license see COPYING.                                                                                   // 777
 * ***** END LICENSE BLOCK *****                                                                                  // 778
 */                                                                                                               // 779
                                                                                                                  // 780
var AbstractXHRObject = function(){};                                                                             // 781
AbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);                                              // 782
                                                                                                                  // 783
AbstractXHRObject.prototype._start = function(method, url, payload, opts) {                                       // 784
    var that = this;                                                                                              // 785
                                                                                                                  // 786
    try {                                                                                                         // 787
        that.xhr = new XMLHttpRequest();                                                                          // 788
    } catch(x) {};                                                                                                // 789
                                                                                                                  // 790
    if (!that.xhr) {                                                                                              // 791
        try {                                                                                                     // 792
            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');                                            // 793
        } catch(x) {};                                                                                            // 794
    }                                                                                                             // 795
    if (_window.ActiveXObject || _window.XDomainRequest) {                                                        // 796
        // IE8 caches even POSTs                                                                                  // 797
        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);                                        // 798
    }                                                                                                             // 799
                                                                                                                  // 800
    // Explorer tends to keep connection open, even after the                                                     // 801
    // tab gets closed: http://bugs.jquery.com/ticket/5280                                                        // 802
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});                                         // 803
    try {                                                                                                         // 804
        that.xhr.open(method, url, true);                                                                         // 805
    } catch(e) {                                                                                                  // 806
        // IE raises an exception on wrong port.                                                                  // 807
        that.emit('finish', 0, '');                                                                               // 808
        that._cleanup();                                                                                          // 809
        return;                                                                                                   // 810
    };                                                                                                            // 811
                                                                                                                  // 812
    if (!opts || !opts.no_credentials) {                                                                          // 813
        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :                                    // 814
        // "This never affects same-site requests."                                                               // 815
        that.xhr.withCredentials = 'true';                                                                        // 816
    }                                                                                                             // 817
    if (opts && opts.headers) {                                                                                   // 818
        for(var key in opts.headers) {                                                                            // 819
            that.xhr.setRequestHeader(key, opts.headers[key]);                                                    // 820
        }                                                                                                         // 821
    }                                                                                                             // 822
                                                                                                                  // 823
    that.xhr.onreadystatechange = function() {                                                                    // 824
        if (that.xhr) {                                                                                           // 825
            var x = that.xhr;                                                                                     // 826
            switch (x.readyState) {                                                                               // 827
            case 3:                                                                                               // 828
                // IE doesn't like peeking into responseText or status                                            // 829
                // on Microsoft.XMLHTTP and readystate=3                                                          // 830
                try {                                                                                             // 831
                    var status = x.status;                                                                        // 832
                    var text = x.responseText;                                                                    // 833
                } catch (x) {};                                                                                   // 834
                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450                                    // 835
                if (status === 1223) status = 204;                                                                // 836
                                                                                                                  // 837
                // IE does return readystate == 3 for 404 answers.                                                // 838
                if (text && text.length > 0) {                                                                    // 839
                    that.emit('chunk', status, text);                                                             // 840
                }                                                                                                 // 841
                break;                                                                                            // 842
            case 4:                                                                                               // 843
                var status = x.status;                                                                            // 844
                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450                                    // 845
                if (status === 1223) status = 204;                                                                // 846
                                                                                                                  // 847
                that.emit('finish', status, x.responseText);                                                      // 848
                that._cleanup(false);                                                                             // 849
                break;                                                                                            // 850
            }                                                                                                     // 851
        }                                                                                                         // 852
    };                                                                                                            // 853
    that.xhr.send(payload);                                                                                       // 854
};                                                                                                                // 855
                                                                                                                  // 856
AbstractXHRObject.prototype._cleanup = function(abort) {                                                          // 857
    var that = this;                                                                                              // 858
    if (!that.xhr) return;                                                                                        // 859
    utils.unload_del(that.unload_ref);                                                                            // 860
                                                                                                                  // 861
    // IE needs this field to be a function                                                                       // 862
    that.xhr.onreadystatechange = function(){};                                                                   // 863
                                                                                                                  // 864
    if (abort) {                                                                                                  // 865
        try {                                                                                                     // 866
            that.xhr.abort();                                                                                     // 867
        } catch(x) {};                                                                                            // 868
    }                                                                                                             // 869
    that.unload_ref = that.xhr = null;                                                                            // 870
};                                                                                                                // 871
                                                                                                                  // 872
AbstractXHRObject.prototype.close = function() {                                                                  // 873
    var that = this;                                                                                              // 874
    that.nuke();                                                                                                  // 875
    that._cleanup(true);                                                                                          // 876
};                                                                                                                // 877
                                                                                                                  // 878
var XHRCorsObject = utils.XHRCorsObject = function() {                                                            // 879
    var that = this, args = arguments;                                                                            // 880
    utils.delay(function(){that._start.apply(that, args);});                                                      // 881
};                                                                                                                // 882
XHRCorsObject.prototype = new AbstractXHRObject();                                                                // 883
                                                                                                                  // 884
var XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {                                      // 885
    var that = this;                                                                                              // 886
    utils.delay(function(){                                                                                       // 887
        that._start(method, url, payload, {                                                                       // 888
            no_credentials: true                                                                                  // 889
        });                                                                                                       // 890
    });                                                                                                           // 891
};                                                                                                                // 892
XHRLocalObject.prototype = new AbstractXHRObject();                                                               // 893
                                                                                                                  // 894
                                                                                                                  // 895
                                                                                                                  // 896
// References:                                                                                                    // 897
//   http://ajaxian.com/archives/100-line-ajax-wrapper                                                            // 898
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx                                               // 899
var XDRObject = utils.XDRObject = function(method, url, payload) {                                                // 900
    var that = this;                                                                                              // 901
    utils.delay(function(){that._start(method, url, payload);});                                                  // 902
};                                                                                                                // 903
XDRObject.prototype = new EventEmitter(['chunk', 'finish']);                                                      // 904
XDRObject.prototype._start = function(method, url, payload) {                                                     // 905
    var that = this;                                                                                              // 906
    var xdr = new XDomainRequest();                                                                               // 907
    // IE caches even POSTs                                                                                       // 908
    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);                                            // 909
                                                                                                                  // 910
    var onerror = xdr.ontimeout = xdr.onerror = function() {                                                      // 911
        that.emit('finish', 0, '');                                                                               // 912
        that._cleanup(false);                                                                                     // 913
    };                                                                                                            // 914
    xdr.onprogress = function() {                                                                                 // 915
        that.emit('chunk', 200, xdr.responseText);                                                                // 916
    };                                                                                                            // 917
    xdr.onload = function() {                                                                                     // 918
        that.emit('finish', 200, xdr.responseText);                                                               // 919
        that._cleanup(false);                                                                                     // 920
    };                                                                                                            // 921
    that.xdr = xdr;                                                                                               // 922
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});                                         // 923
    try {                                                                                                         // 924
        // Fails with AccessDenied if port number is bogus                                                        // 925
        that.xdr.open(method, url);                                                                               // 926
        that.xdr.send(payload);                                                                                   // 927
    } catch(x) {                                                                                                  // 928
        onerror();                                                                                                // 929
    }                                                                                                             // 930
};                                                                                                                // 931
                                                                                                                  // 932
XDRObject.prototype._cleanup = function(abort) {                                                                  // 933
    var that = this;                                                                                              // 934
    if (!that.xdr) return;                                                                                        // 935
    utils.unload_del(that.unload_ref);                                                                            // 936
                                                                                                                  // 937
    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =                                                 // 938
        that.xdr.onload = null;                                                                                   // 939
    if (abort) {                                                                                                  // 940
        try {                                                                                                     // 941
            that.xdr.abort();                                                                                     // 942
        } catch(x) {};                                                                                            // 943
    }                                                                                                             // 944
    that.unload_ref = that.xdr = null;                                                                            // 945
};                                                                                                                // 946
                                                                                                                  // 947
XDRObject.prototype.close = function() {                                                                          // 948
    var that = this;                                                                                              // 949
    that.nuke();                                                                                                  // 950
    that._cleanup(true);                                                                                          // 951
};                                                                                                                // 952
                                                                                                                  // 953
// 1. Is natively via XHR                                                                                         // 954
// 2. Is natively via XDR                                                                                         // 955
// 3. Nope, but postMessage is there so it should work via the Iframe.                                            // 956
// 4. Nope, sorry.                                                                                                // 957
utils.isXHRCorsCapable = function() {                                                                             // 958
    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {                                    // 959
        return 1;                                                                                                 // 960
    }                                                                                                             // 961
    // XDomainRequest doesn't work if page is served from file://                                                 // 962
    if (_window.XDomainRequest && _document.domain) {                                                             // 963
        return 2;                                                                                                 // 964
    }                                                                                                             // 965
    if (IframeTransport.enabled()) {                                                                              // 966
        return 3;                                                                                                 // 967
    }                                                                                                             // 968
    return 4;                                                                                                     // 969
};                                                                                                                // 970
//         [*] End of lib/dom2.js                                                                                 // 971
                                                                                                                  // 972
                                                                                                                  // 973
//         [*] Including lib/sockjs.js                                                                            // 974
/*                                                                                                                // 975
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 976
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 977
 *                                                                                                                // 978
 * For the license see COPYING.                                                                                   // 979
 * ***** END LICENSE BLOCK *****                                                                                  // 980
 */                                                                                                               // 981
                                                                                                                  // 982
var SockJS = function(url, dep_protocols_whitelist, options) {                                                    // 983
    if (!(this instanceof SockJS)) {                                                                              // 984
        // makes `new` optional                                                                                   // 985
        return new SockJS(url, dep_protocols_whitelist, options);                                                 // 986
    }                                                                                                             // 987
                                                                                                                  // 988
    var that = this, protocols_whitelist;                                                                         // 989
    that._options = {devel: false, debug: false, protocols_whitelist: [],                                         // 990
                     info: undefined, rtt: undefined};                                                            // 991
    if (options) {                                                                                                // 992
        utils.objectExtend(that._options, options);                                                               // 993
    }                                                                                                             // 994
    that._base_url = utils.amendUrl(url);                                                                         // 995
    that._server = that._options.server || utils.random_number_string(1000);                                      // 996
    if (that._options.protocols_whitelist &&                                                                      // 997
        that._options.protocols_whitelist.length) {                                                               // 998
        protocols_whitelist = that._options.protocols_whitelist;                                                  // 999
    } else {                                                                                                      // 1000
        // Deprecated API                                                                                         // 1001
        if (typeof dep_protocols_whitelist === 'string' &&                                                        // 1002
            dep_protocols_whitelist.length > 0) {                                                                 // 1003
            protocols_whitelist = [dep_protocols_whitelist];                                                      // 1004
        } else if (utils.isArray(dep_protocols_whitelist)) {                                                      // 1005
            protocols_whitelist = dep_protocols_whitelist                                                         // 1006
        } else {                                                                                                  // 1007
            protocols_whitelist = null;                                                                           // 1008
        }                                                                                                         // 1009
        if (protocols_whitelist) {                                                                                // 1010
            that._debug('Deprecated API: Use "protocols_whitelist" option ' +                                     // 1011
                        'instead of supplying protocol list as a second ' +                                       // 1012
                        'parameter to SockJS constructor.');                                                      // 1013
        }                                                                                                         // 1014
    }                                                                                                             // 1015
    that._protocols = [];                                                                                         // 1016
    that.protocol = null;                                                                                         // 1017
    that.readyState = SockJS.CONNECTING;                                                                          // 1018
    that._ir = createInfoReceiver(that._base_url);                                                                // 1019
    that._ir.onfinish = function(info, rtt) {                                                                     // 1020
        that._ir = null;                                                                                          // 1021
        if (info) {                                                                                               // 1022
            if (that._options.info) {                                                                             // 1023
                // Override if user supplies the option                                                           // 1024
                info = utils.objectExtend(info, that._options.info);                                              // 1025
            }                                                                                                     // 1026
            if (that._options.rtt) {                                                                              // 1027
                rtt = that._options.rtt;                                                                          // 1028
            }                                                                                                     // 1029
            that._applyInfo(info, rtt, protocols_whitelist);                                                      // 1030
            that._didClose();                                                                                     // 1031
        } else {                                                                                                  // 1032
            that._didClose(1002, 'Can\'t connect to server', true);                                               // 1033
        }                                                                                                         // 1034
    };                                                                                                            // 1035
};                                                                                                                // 1036
// Inheritance                                                                                                    // 1037
SockJS.prototype = new REventTarget();                                                                            // 1038
                                                                                                                  // 1039
SockJS.version = "0.3.4";                                                                                         // 1040
                                                                                                                  // 1041
SockJS.CONNECTING = 0;                                                                                            // 1042
SockJS.OPEN = 1;                                                                                                  // 1043
SockJS.CLOSING = 2;                                                                                               // 1044
SockJS.CLOSED = 3;                                                                                                // 1045
                                                                                                                  // 1046
SockJS.prototype._debug = function() {                                                                            // 1047
    if (this._options.debug)                                                                                      // 1048
        utils.log.apply(utils, arguments);                                                                        // 1049
};                                                                                                                // 1050
                                                                                                                  // 1051
SockJS.prototype._dispatchOpen = function() {                                                                     // 1052
    var that = this;                                                                                              // 1053
    if (that.readyState === SockJS.CONNECTING) {                                                                  // 1054
        if (that._transport_tref) {                                                                               // 1055
            clearTimeout(that._transport_tref);                                                                   // 1056
            that._transport_tref = null;                                                                          // 1057
        }                                                                                                         // 1058
        that.readyState = SockJS.OPEN;                                                                            // 1059
        that.dispatchEvent(new SimpleEvent("open"));                                                              // 1060
    } else {                                                                                                      // 1061
        // The server might have been restarted, and lost track of our                                            // 1062
        // connection.                                                                                            // 1063
        that._didClose(1006, "Server lost session");                                                              // 1064
    }                                                                                                             // 1065
};                                                                                                                // 1066
                                                                                                                  // 1067
SockJS.prototype._dispatchMessage = function(data) {                                                              // 1068
    var that = this;                                                                                              // 1069
    if (that.readyState !== SockJS.OPEN)                                                                          // 1070
            return;                                                                                               // 1071
    that.dispatchEvent(new SimpleEvent("message", {data: data}));                                                 // 1072
};                                                                                                                // 1073
                                                                                                                  // 1074
SockJS.prototype._dispatchHeartbeat = function(data) {                                                            // 1075
    var that = this;                                                                                              // 1076
    if (that.readyState !== SockJS.OPEN)                                                                          // 1077
        return;                                                                                                   // 1078
    that.dispatchEvent(new SimpleEvent('heartbeat', {}));                                                         // 1079
};                                                                                                                // 1080
                                                                                                                  // 1081
SockJS.prototype._didClose = function(code, reason, force) {                                                      // 1082
    var that = this;                                                                                              // 1083
    if (that.readyState !== SockJS.CONNECTING &&                                                                  // 1084
        that.readyState !== SockJS.OPEN &&                                                                        // 1085
        that.readyState !== SockJS.CLOSING)                                                                       // 1086
            throw new Error('INVALID_STATE_ERR');                                                                 // 1087
    if (that._ir) {                                                                                               // 1088
        that._ir.nuke();                                                                                          // 1089
        that._ir = null;                                                                                          // 1090
    }                                                                                                             // 1091
                                                                                                                  // 1092
    if (that._transport) {                                                                                        // 1093
        that._transport.doCleanup();                                                                              // 1094
        that._transport = null;                                                                                   // 1095
    }                                                                                                             // 1096
                                                                                                                  // 1097
    var close_event = new SimpleEvent("close", {                                                                  // 1098
        code: code,                                                                                               // 1099
        reason: reason,                                                                                           // 1100
        wasClean: utils.userSetCode(code)});                                                                      // 1101
                                                                                                                  // 1102
    if (!utils.userSetCode(code) &&                                                                               // 1103
        that.readyState === SockJS.CONNECTING && !force) {                                                        // 1104
        if (that._try_next_protocol(close_event)) {                                                               // 1105
            return;                                                                                               // 1106
        }                                                                                                         // 1107
        close_event = new SimpleEvent("close", {code: 2000,                                                       // 1108
                                                reason: "All transports failed",                                  // 1109
                                                wasClean: false,                                                  // 1110
                                                last_event: close_event});                                        // 1111
    }                                                                                                             // 1112
    that.readyState = SockJS.CLOSED;                                                                              // 1113
                                                                                                                  // 1114
    utils.delay(function() {                                                                                      // 1115
                   that.dispatchEvent(close_event);                                                               // 1116
                });                                                                                               // 1117
};                                                                                                                // 1118
                                                                                                                  // 1119
SockJS.prototype._didMessage = function(data) {                                                                   // 1120
    var that = this;                                                                                              // 1121
    var type = data.slice(0, 1);                                                                                  // 1122
    switch(type) {                                                                                                // 1123
    case 'o':                                                                                                     // 1124
        that._dispatchOpen();                                                                                     // 1125
        break;                                                                                                    // 1126
    case 'a':                                                                                                     // 1127
        var payload = JSON.parse(data.slice(1) || '[]');                                                          // 1128
        for(var i=0; i < payload.length; i++){                                                                    // 1129
            that._dispatchMessage(payload[i]);                                                                    // 1130
        }                                                                                                         // 1131
        break;                                                                                                    // 1132
    case 'm':                                                                                                     // 1133
        var payload = JSON.parse(data.slice(1) || 'null');                                                        // 1134
        that._dispatchMessage(payload);                                                                           // 1135
        break;                                                                                                    // 1136
    case 'c':                                                                                                     // 1137
        var payload = JSON.parse(data.slice(1) || '[]');                                                          // 1138
        that._didClose(payload[0], payload[1]);                                                                   // 1139
        break;                                                                                                    // 1140
    case 'h':                                                                                                     // 1141
        that._dispatchHeartbeat();                                                                                // 1142
        break;                                                                                                    // 1143
    }                                                                                                             // 1144
};                                                                                                                // 1145
                                                                                                                  // 1146
SockJS.prototype._try_next_protocol = function(close_event) {                                                     // 1147
    var that = this;                                                                                              // 1148
    if (that.protocol) {                                                                                          // 1149
        that._debug('Closed transport:', that.protocol, ''+close_event);                                          // 1150
        that.protocol = null;                                                                                     // 1151
    }                                                                                                             // 1152
    if (that._transport_tref) {                                                                                   // 1153
        clearTimeout(that._transport_tref);                                                                       // 1154
        that._transport_tref = null;                                                                              // 1155
    }                                                                                                             // 1156
                                                                                                                  // 1157
    while(1) {                                                                                                    // 1158
        var protocol = that.protocol = that._protocols.shift();                                                   // 1159
        if (!protocol) {                                                                                          // 1160
            return false;                                                                                         // 1161
        }                                                                                                         // 1162
        // Some protocols require access to `body`, what if were in                                               // 1163
        // the `head`?                                                                                            // 1164
        if (SockJS[protocol] &&                                                                                   // 1165
            SockJS[protocol].need_body === true &&                                                                // 1166
            (!_document.body ||                                                                                   // 1167
             (typeof _document.readyState !== 'undefined'                                                         // 1168
              && _document.readyState !== 'complete'))) {                                                         // 1169
            that._protocols.unshift(protocol);                                                                    // 1170
            that.protocol = 'waiting-for-load';                                                                   // 1171
            utils.attachEvent('load', function(){                                                                 // 1172
                that._try_next_protocol();                                                                        // 1173
            });                                                                                                   // 1174
            return true;                                                                                          // 1175
        }                                                                                                         // 1176
                                                                                                                  // 1177
        if (!SockJS[protocol] ||                                                                                  // 1178
              !SockJS[protocol].enabled(that._options)) {                                                         // 1179
            that._debug('Skipping transport:', protocol);                                                         // 1180
        } else {                                                                                                  // 1181
            var roundTrips = SockJS[protocol].roundTrips || 1;                                                    // 1182
            var to = ((that._options.rto || 0) * roundTrips) || 5000;                                             // 1183
            that._transport_tref = utils.delay(to, function() {                                                   // 1184
                if (that.readyState === SockJS.CONNECTING) {                                                      // 1185
                    // I can't understand how it is possible to run                                               // 1186
                    // this timer, when the state is CLOSED, but                                                  // 1187
                    // apparently in IE everythin is possible.                                                    // 1188
                    that._didClose(2007, "Transport timeouted");                                                  // 1189
                }                                                                                                 // 1190
            });                                                                                                   // 1191
                                                                                                                  // 1192
            var connid = utils.random_string(8);                                                                  // 1193
            var trans_url = that._base_url + '/' + that._server + '/' + connid;                                   // 1194
            that._debug('Opening transport:', protocol, ' url:'+trans_url,                                        // 1195
                        ' RTO:'+that._options.rto);                                                               // 1196
            that._transport = new SockJS[protocol](that, trans_url,                                               // 1197
                                                   that._base_url);                                               // 1198
            return true;                                                                                          // 1199
        }                                                                                                         // 1200
    }                                                                                                             // 1201
};                                                                                                                // 1202
                                                                                                                  // 1203
SockJS.prototype.close = function(code, reason) {                                                                 // 1204
    var that = this;                                                                                              // 1205
    if (code && !utils.userSetCode(code))                                                                         // 1206
        throw new Error("INVALID_ACCESS_ERR");                                                                    // 1207
    if(that.readyState !== SockJS.CONNECTING &&                                                                   // 1208
       that.readyState !== SockJS.OPEN) {                                                                         // 1209
        return false;                                                                                             // 1210
    }                                                                                                             // 1211
    that.readyState = SockJS.CLOSING;                                                                             // 1212
    that._didClose(code || 1000, reason || "Normal closure");                                                     // 1213
    return true;                                                                                                  // 1214
};                                                                                                                // 1215
                                                                                                                  // 1216
SockJS.prototype.send = function(data) {                                                                          // 1217
    var that = this;                                                                                              // 1218
    if (that.readyState === SockJS.CONNECTING)                                                                    // 1219
        throw new Error('INVALID_STATE_ERR');                                                                     // 1220
    if (that.readyState === SockJS.OPEN) {                                                                        // 1221
        that._transport.doSend(utils.quote('' + data));                                                           // 1222
    }                                                                                                             // 1223
    return true;                                                                                                  // 1224
};                                                                                                                // 1225
                                                                                                                  // 1226
SockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {                                          // 1227
    var that = this;                                                                                              // 1228
    that._options.info = info;                                                                                    // 1229
    that._options.rtt = rtt;                                                                                      // 1230
    that._options.rto = utils.countRTO(rtt);                                                                      // 1231
    that._options.info.null_origin = !_document.domain;                                                           // 1232
    // Servers can override base_url, eg to provide a randomized domain name and                                  // 1233
    // avoid browser per-domain connection limits.                                                                // 1234
    if (info.base_url)                                                                                            // 1235
      // <METEOR>                                                                                                 // 1236
      that._base_url = utils.amendUrl(info.base_url, that._base_url);                                             // 1237
      // </METEOR>                                                                                                // 1238
    var probed = utils.probeProtocols();                                                                          // 1239
    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);                                   // 1240
// <METEOR>                                                                                                       // 1241
// https://github.com/sockjs/sockjs-client/issues/79                                                              // 1242
    // Hack to avoid XDR when using different protocols                                                           // 1243
    // We're on IE trying to do cross-protocol. jsonp only.                                                       // 1244
    if (!utils.isSameOriginScheme(that._base_url) &&                                                              // 1245
        2 === utils.isXHRCorsCapable()) {                                                                         // 1246
        that._protocols = ['jsonp-polling'];                                                                      // 1247
    }                                                                                                             // 1248
// </METEOR>                                                                                                      // 1249
};                                                                                                                // 1250
//         [*] End of lib/sockjs.js                                                                               // 1251
                                                                                                                  // 1252
                                                                                                                  // 1253
//         [*] Including lib/trans-websocket.js                                                                   // 1254
/*                                                                                                                // 1255
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1256
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1257
 *                                                                                                                // 1258
 * For the license see COPYING.                                                                                   // 1259
 * ***** END LICENSE BLOCK *****                                                                                  // 1260
 */                                                                                                               // 1261
                                                                                                                  // 1262
var WebSocketTransport = SockJS.websocket = function(ri, trans_url) {                                             // 1263
    var that = this;                                                                                              // 1264
    var url = trans_url + '/websocket';                                                                           // 1265
    if (url.slice(0, 5) === 'https') {                                                                            // 1266
        url = 'wss' + url.slice(5);                                                                               // 1267
    } else {                                                                                                      // 1268
        url = 'ws' + url.slice(4);                                                                                // 1269
    }                                                                                                             // 1270
    that.ri = ri;                                                                                                 // 1271
    that.url = url;                                                                                               // 1272
    var Constructor = _window.WebSocket || _window.MozWebSocket;                                                  // 1273
                                                                                                                  // 1274
    that.ws = new Constructor(that.url);                                                                          // 1275
    that.ws.onmessage = function(e) {                                                                             // 1276
        that.ri._didMessage(e.data);                                                                              // 1277
    };                                                                                                            // 1278
    // Firefox has an interesting bug. If a websocket connection is                                               // 1279
    // created after onunload, it stays alive even when user                                                      // 1280
    // navigates away from the page. In such situation let's lie -                                                // 1281
    // let's not open the ws connection at all. See:                                                              // 1282
    // https://github.com/sockjs/sockjs-client/issues/28                                                          // 1283
    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085                                                        // 1284
    that.unload_ref = utils.unload_add(function(){that.ws.close()});                                              // 1285
    that.ws.onclose = function() {                                                                                // 1286
        that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"));                               // 1287
    };                                                                                                            // 1288
};                                                                                                                // 1289
                                                                                                                  // 1290
WebSocketTransport.prototype.doSend = function(data) {                                                            // 1291
    this.ws.send('[' + data + ']');                                                                               // 1292
};                                                                                                                // 1293
                                                                                                                  // 1294
WebSocketTransport.prototype.doCleanup = function() {                                                             // 1295
    var that = this;                                                                                              // 1296
    var ws = that.ws;                                                                                             // 1297
    if (ws) {                                                                                                     // 1298
        ws.onmessage = ws.onclose = null;                                                                         // 1299
        ws.close();                                                                                               // 1300
        utils.unload_del(that.unload_ref);                                                                        // 1301
        that.unload_ref = that.ri = that.ws = null;                                                               // 1302
    }                                                                                                             // 1303
};                                                                                                                // 1304
                                                                                                                  // 1305
WebSocketTransport.enabled = function() {                                                                         // 1306
    return !!(_window.WebSocket || _window.MozWebSocket);                                                         // 1307
};                                                                                                                // 1308
                                                                                                                  // 1309
// In theory, ws should require 1 round trip. But in chrome, this is                                              // 1310
// not very stable over SSL. Most likely a ws connection requires a                                               // 1311
// separate SSL connection, in which case 2 round trips are an                                                    // 1312
// absolute minumum.                                                                                              // 1313
WebSocketTransport.roundTrips = 2;                                                                                // 1314
//         [*] End of lib/trans-websocket.js                                                                      // 1315
                                                                                                                  // 1316
                                                                                                                  // 1317
//         [*] Including lib/trans-sender.js                                                                      // 1318
/*                                                                                                                // 1319
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1320
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1321
 *                                                                                                                // 1322
 * For the license see COPYING.                                                                                   // 1323
 * ***** END LICENSE BLOCK *****                                                                                  // 1324
 */                                                                                                               // 1325
                                                                                                                  // 1326
var BufferedSender = function() {};                                                                               // 1327
BufferedSender.prototype.send_constructor = function(sender) {                                                    // 1328
    var that = this;                                                                                              // 1329
    that.send_buffer = [];                                                                                        // 1330
    that.sender = sender;                                                                                         // 1331
};                                                                                                                // 1332
BufferedSender.prototype.doSend = function(message) {                                                             // 1333
    var that = this;                                                                                              // 1334
    that.send_buffer.push(message);                                                                               // 1335
    if (!that.send_stop) {                                                                                        // 1336
        that.send_schedule();                                                                                     // 1337
    }                                                                                                             // 1338
};                                                                                                                // 1339
                                                                                                                  // 1340
// For polling transports in a situation when in the message callback,                                            // 1341
// new message is being send. If the sending connection was started                                               // 1342
// before receiving one, it is possible to saturate the network and                                               // 1343
// timeout due to the lack of receiving socket. To avoid that we delay                                            // 1344
// sending messages by some small time, in order to let receiving                                                 // 1345
// connection be started beforehand. This is only a halfmeasure and                                               // 1346
// does not fix the big problem, but it does make the tests go more                                               // 1347
// stable on slow networks.                                                                                       // 1348
BufferedSender.prototype.send_schedule_wait = function() {                                                        // 1349
    var that = this;                                                                                              // 1350
    var tref;                                                                                                     // 1351
    that.send_stop = function() {                                                                                 // 1352
        that.send_stop = null;                                                                                    // 1353
        clearTimeout(tref);                                                                                       // 1354
    };                                                                                                            // 1355
    tref = utils.delay(25, function() {                                                                           // 1356
        that.send_stop = null;                                                                                    // 1357
        that.send_schedule();                                                                                     // 1358
    });                                                                                                           // 1359
};                                                                                                                // 1360
                                                                                                                  // 1361
BufferedSender.prototype.send_schedule = function() {                                                             // 1362
    var that = this;                                                                                              // 1363
    if (that.send_buffer.length > 0) {                                                                            // 1364
        var payload = '[' + that.send_buffer.join(',') + ']';                                                     // 1365
        that.send_stop = that.sender(that.trans_url, payload, function(success, abort_reason) {                   // 1366
            that.send_stop = null;                                                                                // 1367
            if (success === false) {                                                                              // 1368
                that.ri._didClose(1006, 'Sending error ' + abort_reason);                                         // 1369
            } else {                                                                                              // 1370
                that.send_schedule_wait();                                                                        // 1371
            }                                                                                                     // 1372
        });                                                                                                       // 1373
        that.send_buffer = [];                                                                                    // 1374
    }                                                                                                             // 1375
};                                                                                                                // 1376
                                                                                                                  // 1377
BufferedSender.prototype.send_destructor = function() {                                                           // 1378
    var that = this;                                                                                              // 1379
    if (that._send_stop) {                                                                                        // 1380
        that._send_stop();                                                                                        // 1381
    }                                                                                                             // 1382
    that._send_stop = null;                                                                                       // 1383
};                                                                                                                // 1384
                                                                                                                  // 1385
var jsonPGenericSender = function(url, payload, callback) {                                                       // 1386
    var that = this;                                                                                              // 1387
                                                                                                                  // 1388
    if (!('_send_form' in that)) {                                                                                // 1389
        var form = that._send_form = _document.createElement('form');                                             // 1390
        var area = that._send_area = _document.createElement('textarea');                                         // 1391
        area.name = 'd';                                                                                          // 1392
        form.style.display = 'none';                                                                              // 1393
        form.style.position = 'absolute';                                                                         // 1394
        form.method = 'POST';                                                                                     // 1395
        form.enctype = 'application/x-www-form-urlencoded';                                                       // 1396
        form.acceptCharset = "UTF-8";                                                                             // 1397
        form.appendChild(area);                                                                                   // 1398
        _document.body.appendChild(form);                                                                         // 1399
    }                                                                                                             // 1400
    var form = that._send_form;                                                                                   // 1401
    var area = that._send_area;                                                                                   // 1402
    var id = 'a' + utils.random_string(8);                                                                        // 1403
    form.target = id;                                                                                             // 1404
    form.action = url + '/jsonp_send?i=' + id;                                                                    // 1405
                                                                                                                  // 1406
    var iframe;                                                                                                   // 1407
    try {                                                                                                         // 1408
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)                                    // 1409
        iframe = _document.createElement('<iframe name="'+ id +'">');                                             // 1410
    } catch(x) {                                                                                                  // 1411
        iframe = _document.createElement('iframe');                                                               // 1412
        iframe.name = id;                                                                                         // 1413
    }                                                                                                             // 1414
    iframe.id = id;                                                                                               // 1415
    form.appendChild(iframe);                                                                                     // 1416
    iframe.style.display = 'none';                                                                                // 1417
                                                                                                                  // 1418
    try {                                                                                                         // 1419
        area.value = payload;                                                                                     // 1420
    } catch(e) {                                                                                                  // 1421
        utils.log('Your browser is seriously broken. Go home! ' + e.message);                                     // 1422
    }                                                                                                             // 1423
    form.submit();                                                                                                // 1424
                                                                                                                  // 1425
    var completed = function(e) {                                                                                 // 1426
        if (!iframe.onerror) return;                                                                              // 1427
        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;                                        // 1428
        // Opera mini doesn't like if we GC iframe                                                                // 1429
        // immediately, thus this timeout.                                                                        // 1430
        utils.delay(500, function() {                                                                             // 1431
                       iframe.parentNode.removeChild(iframe);                                                     // 1432
                       iframe = null;                                                                             // 1433
                   });                                                                                            // 1434
        area.value = '';                                                                                          // 1435
        // It is not possible to detect if the iframe succeeded or                                                // 1436
        // failed to submit our form.                                                                             // 1437
        callback(true);                                                                                           // 1438
    };                                                                                                            // 1439
    iframe.onerror = iframe.onload = completed;                                                                   // 1440
    iframe.onreadystatechange = function(e) {                                                                     // 1441
        if (iframe.readyState == 'complete') completed();                                                         // 1442
    };                                                                                                            // 1443
    return completed;                                                                                             // 1444
};                                                                                                                // 1445
                                                                                                                  // 1446
var createAjaxSender = function(AjaxObject) {                                                                     // 1447
    return function(url, payload, callback) {                                                                     // 1448
        var xo = new AjaxObject('POST', url + '/xhr_send', payload);                                              // 1449
        xo.onfinish = function(status, text) {                                                                    // 1450
            callback(status === 200 || status === 204,                                                            // 1451
                     'http status ' + status);                                                                    // 1452
        };                                                                                                        // 1453
        return function(abort_reason) {                                                                           // 1454
            callback(false, abort_reason);                                                                        // 1455
        };                                                                                                        // 1456
    };                                                                                                            // 1457
};                                                                                                                // 1458
//         [*] End of lib/trans-sender.js                                                                         // 1459
                                                                                                                  // 1460
                                                                                                                  // 1461
//         [*] Including lib/trans-jsonp-receiver.js                                                              // 1462
/*                                                                                                                // 1463
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1464
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1465
 *                                                                                                                // 1466
 * For the license see COPYING.                                                                                   // 1467
 * ***** END LICENSE BLOCK *****                                                                                  // 1468
 */                                                                                                               // 1469
                                                                                                                  // 1470
// Parts derived from Socket.io:                                                                                  // 1471
//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js               // 1472
// and jQuery-JSONP:                                                                                              // 1473
//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js                             // 1474
var jsonPGenericReceiver = function(url, callback) {                                                              // 1475
    var tref;                                                                                                     // 1476
    var script = _document.createElement('script');                                                               // 1477
    var script2;  // Opera synchronous load trick.                                                                // 1478
    var close_script = function(frame) {                                                                          // 1479
        if (script2) {                                                                                            // 1480
            script2.parentNode.removeChild(script2);                                                              // 1481
            script2 = null;                                                                                       // 1482
        }                                                                                                         // 1483
        if (script) {                                                                                             // 1484
            clearTimeout(tref);                                                                                   // 1485
            // Unfortunately, you can't really abort script loading of                                            // 1486
            // the script.                                                                                        // 1487
            script.parentNode.removeChild(script);                                                                // 1488
            script.onreadystatechange = script.onerror =                                                          // 1489
                script.onload = script.onclick = null;                                                            // 1490
            script = null;                                                                                        // 1491
            callback(frame);                                                                                      // 1492
            callback = null;                                                                                      // 1493
        }                                                                                                         // 1494
    };                                                                                                            // 1495
                                                                                                                  // 1496
    // IE9 fires 'error' event after orsc or before, in random order.                                             // 1497
    var loaded_okay = false;                                                                                      // 1498
    var error_timer = null;                                                                                       // 1499
                                                                                                                  // 1500
    script.id = 'a' + utils.random_string(8);                                                                     // 1501
    script.src = url;                                                                                             // 1502
    script.type = 'text/javascript';                                                                              // 1503
    script.charset = 'UTF-8';                                                                                     // 1504
    script.onerror = function(e) {                                                                                // 1505
        if (!error_timer) {                                                                                       // 1506
            // Delay firing close_script.                                                                         // 1507
            error_timer = setTimeout(function() {                                                                 // 1508
                if (!loaded_okay) {                                                                               // 1509
                    close_script(utils.closeFrame(                                                                // 1510
                        1006,                                                                                     // 1511
                        "JSONP script loaded abnormally (onerror)"));                                             // 1512
                }                                                                                                 // 1513
            }, 1000);                                                                                             // 1514
        }                                                                                                         // 1515
    };                                                                                                            // 1516
    script.onload = function(e) {                                                                                 // 1517
        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"));                          // 1518
    };                                                                                                            // 1519
                                                                                                                  // 1520
    script.onreadystatechange = function(e) {                                                                     // 1521
        if (/loaded|closed/.test(script.readyState)) {                                                            // 1522
            if (script && script.htmlFor && script.onclick) {                                                     // 1523
                loaded_okay = true;                                                                               // 1524
                try {                                                                                             // 1525
                    // In IE, actually execute the script.                                                        // 1526
                    script.onclick();                                                                             // 1527
                } catch (x) {}                                                                                    // 1528
            }                                                                                                     // 1529
            if (script) {                                                                                         // 1530
                close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"));      // 1531
            }                                                                                                     // 1532
        }                                                                                                         // 1533
    };                                                                                                            // 1534
    // IE: event/htmlFor/onclick trick.                                                                           // 1535
    // One can't rely on proper order for onreadystatechange. In order to                                         // 1536
    // make sure, set a 'htmlFor' and 'event' properties, so that                                                 // 1537
    // script code will be installed as 'onclick' handler for the                                                 // 1538
    // script object. Later, onreadystatechange, manually execute this                                            // 1539
    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'                                                // 1540
    // set. For reference see:                                                                                    // 1541
    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html                                    // 1542
    // Also, read on that about script ordering:                                                                  // 1543
    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order                                               // 1544
    if (typeof script.async === 'undefined' && _document.attachEvent) {                                           // 1545
        // According to mozilla docs, in recent browsers script.async defaults                                    // 1546
        // to 'true', so we may use it to detect a good browser:                                                  // 1547
        // https://developer.mozilla.org/en/HTML/Element/script                                                   // 1548
        if (!/opera/i.test(navigator.userAgent)) {                                                                // 1549
            // Naively assume we're in IE                                                                         // 1550
            try {                                                                                                 // 1551
                script.htmlFor = script.id;                                                                       // 1552
                script.event = "onclick";                                                                         // 1553
            } catch (x) {}                                                                                        // 1554
            script.async = true;                                                                                  // 1555
        } else {                                                                                                  // 1556
            // Opera, second sync script hack                                                                     // 1557
            script2 = _document.createElement('script');                                                          // 1558
            script2.text = "try{var a = document.getElementById('"+script.id+"'); if(a)a.onerror();}catch(x){};"; // 1559
            script.async = script2.async = false;                                                                 // 1560
        }                                                                                                         // 1561
    }                                                                                                             // 1562
    if (typeof script.async !== 'undefined') {                                                                    // 1563
        script.async = true;                                                                                      // 1564
    }                                                                                                             // 1565
                                                                                                                  // 1566
    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.                                  // 1567
    tref = setTimeout(function() {                                                                                // 1568
                          close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"));       // 1569
                      }, 35000);                                                                                  // 1570
                                                                                                                  // 1571
    var head = _document.getElementsByTagName('head')[0];                                                         // 1572
    head.insertBefore(script, head.firstChild);                                                                   // 1573
    if (script2) {                                                                                                // 1574
        head.insertBefore(script2, head.firstChild);                                                              // 1575
    }                                                                                                             // 1576
    return close_script;                                                                                          // 1577
};                                                                                                                // 1578
//         [*] End of lib/trans-jsonp-receiver.js                                                                 // 1579
                                                                                                                  // 1580
                                                                                                                  // 1581
//         [*] Including lib/trans-jsonp-polling.js                                                               // 1582
/*                                                                                                                // 1583
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1584
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1585
 *                                                                                                                // 1586
 * For the license see COPYING.                                                                                   // 1587
 * ***** END LICENSE BLOCK *****                                                                                  // 1588
 */                                                                                                               // 1589
                                                                                                                  // 1590
// The simplest and most robust transport, using the well-know cross                                              // 1591
// domain hack - JSONP. This transport is quite inefficient - one                                                 // 1592
// mssage could use up to one http request. But at least it works almost                                          // 1593
// everywhere.                                                                                                    // 1594
// Known limitations:                                                                                             // 1595
//   o you will get a spinning cursor                                                                             // 1596
//   o for Konqueror a dumb timer is needed to detect errors                                                      // 1597
                                                                                                                  // 1598
                                                                                                                  // 1599
var JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {                                          // 1600
    utils.polluteGlobalNamespace();                                                                               // 1601
    var that = this;                                                                                              // 1602
    that.ri = ri;                                                                                                 // 1603
    that.trans_url = trans_url;                                                                                   // 1604
    that.send_constructor(jsonPGenericSender);                                                                    // 1605
    that._schedule_recv();                                                                                        // 1606
};                                                                                                                // 1607
                                                                                                                  // 1608
// Inheritnace                                                                                                    // 1609
JsonPTransport.prototype = new BufferedSender();                                                                  // 1610
                                                                                                                  // 1611
JsonPTransport.prototype._schedule_recv = function() {                                                            // 1612
    var that = this;                                                                                              // 1613
    var callback = function(data) {                                                                               // 1614
        that._recv_stop = null;                                                                                   // 1615
        if (data) {                                                                                               // 1616
            // no data - heartbeat;                                                                               // 1617
            if (!that._is_closing) {                                                                              // 1618
                that.ri._didMessage(data);                                                                        // 1619
            }                                                                                                     // 1620
        }                                                                                                         // 1621
        // The message can be a close message, and change is_closing state.                                       // 1622
        if (!that._is_closing) {                                                                                  // 1623
            that._schedule_recv();                                                                                // 1624
        }                                                                                                         // 1625
    };                                                                                                            // 1626
    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',                                             // 1627
                                           jsonPGenericReceiver, callback);                                       // 1628
};                                                                                                                // 1629
                                                                                                                  // 1630
JsonPTransport.enabled = function() {                                                                             // 1631
    return true;                                                                                                  // 1632
};                                                                                                                // 1633
                                                                                                                  // 1634
JsonPTransport.need_body = true;                                                                                  // 1635
                                                                                                                  // 1636
                                                                                                                  // 1637
JsonPTransport.prototype.doCleanup = function() {                                                                 // 1638
    var that = this;                                                                                              // 1639
    that._is_closing = true;                                                                                      // 1640
    if (that._recv_stop) {                                                                                        // 1641
        that._recv_stop();                                                                                        // 1642
    }                                                                                                             // 1643
    that.ri = that._recv_stop = null;                                                                             // 1644
    that.send_destructor();                                                                                       // 1645
};                                                                                                                // 1646
                                                                                                                  // 1647
                                                                                                                  // 1648
// Abstract away code that handles global namespace pollution.                                                    // 1649
var jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {                                      // 1650
    var id = 'a' + utils.random_string(6);                                                                        // 1651
    var url_id = url + '?c=' + escape(WPrefix + '.' + id);                                                        // 1652
                                                                                                                  // 1653
    // Unfortunately it is not possible to abort loading of the                                                   // 1654
    // script. We need to keep track of frake close frames.                                                       // 1655
    var aborting = 0;                                                                                             // 1656
                                                                                                                  // 1657
    // Callback will be called exactly once.                                                                      // 1658
    var callback = function(frame) {                                                                              // 1659
        switch(aborting) {                                                                                        // 1660
        case 0:                                                                                                   // 1661
            // Normal behaviour - delete hook _and_ emit message.                                                 // 1662
            delete _window[WPrefix][id];                                                                          // 1663
            user_callback(frame);                                                                                 // 1664
            break;                                                                                                // 1665
        case 1:                                                                                                   // 1666
            // Fake close frame - emit but don't delete hook.                                                     // 1667
            user_callback(frame);                                                                                 // 1668
            aborting = 2;                                                                                         // 1669
            break;                                                                                                // 1670
        case 2:                                                                                                   // 1671
            // Got frame after connection was closed, delete hook, don't emit.                                    // 1672
            delete _window[WPrefix][id];                                                                          // 1673
            break;                                                                                                // 1674
        }                                                                                                         // 1675
    };                                                                                                            // 1676
                                                                                                                  // 1677
    var close_script = constructReceiver(url_id, callback);                                                       // 1678
    _window[WPrefix][id] = close_script;                                                                          // 1679
    var stop = function() {                                                                                       // 1680
        if (_window[WPrefix][id]) {                                                                               // 1681
            aborting = 1;                                                                                         // 1682
            _window[WPrefix][id](utils.closeFrame(1000, "JSONP user aborted read"));                              // 1683
        }                                                                                                         // 1684
    };                                                                                                            // 1685
    return stop;                                                                                                  // 1686
};                                                                                                                // 1687
//         [*] End of lib/trans-jsonp-polling.js                                                                  // 1688
                                                                                                                  // 1689
                                                                                                                  // 1690
//         [*] Including lib/trans-xhr.js                                                                         // 1691
/*                                                                                                                // 1692
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1693
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1694
 *                                                                                                                // 1695
 * For the license see COPYING.                                                                                   // 1696
 * ***** END LICENSE BLOCK *****                                                                                  // 1697
 */                                                                                                               // 1698
                                                                                                                  // 1699
var AjaxBasedTransport = function() {};                                                                           // 1700
AjaxBasedTransport.prototype = new BufferedSender();                                                              // 1701
                                                                                                                  // 1702
AjaxBasedTransport.prototype.run = function(ri, trans_url,                                                        // 1703
                                            url_suffix, Receiver, AjaxObject) {                                   // 1704
    var that = this;                                                                                              // 1705
    that.ri = ri;                                                                                                 // 1706
    that.trans_url = trans_url;                                                                                   // 1707
    that.send_constructor(createAjaxSender(AjaxObject));                                                          // 1708
    that.poll = new Polling(ri, Receiver,                                                                         // 1709
                            trans_url + url_suffix, AjaxObject);                                                  // 1710
};                                                                                                                // 1711
                                                                                                                  // 1712
AjaxBasedTransport.prototype.doCleanup = function() {                                                             // 1713
    var that = this;                                                                                              // 1714
    if (that.poll) {                                                                                              // 1715
        that.poll.abort();                                                                                        // 1716
        that.poll = null;                                                                                         // 1717
    }                                                                                                             // 1718
};                                                                                                                // 1719
                                                                                                                  // 1720
// xhr-streaming                                                                                                  // 1721
var XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {                                   // 1722
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);                                  // 1723
};                                                                                                                // 1724
                                                                                                                  // 1725
XhrStreamingTransport.prototype = new AjaxBasedTransport();                                                       // 1726
                                                                                                                  // 1727
XhrStreamingTransport.enabled = function() {                                                                      // 1728
    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but                                                  // 1729
    // doesn't do streaming.                                                                                      // 1730
    return (_window.XMLHttpRequest &&                                                                             // 1731
            'withCredentials' in new XMLHttpRequest() &&                                                          // 1732
            (!/opera/i.test(navigator.userAgent)));                                                               // 1733
};                                                                                                                // 1734
XhrStreamingTransport.roundTrips = 2; // preflight, ajax                                                          // 1735
                                                                                                                  // 1736
// Safari gets confused when a streaming ajax request is started                                                  // 1737
// before onload. This causes the load indicator to spin indefinetely.                                            // 1738
XhrStreamingTransport.need_body = true;                                                                           // 1739
                                                                                                                  // 1740
                                                                                                                  // 1741
// According to:                                                                                                  // 1742
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests           // 1743
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/                                        // 1744
                                                                                                                  // 1745
                                                                                                                  // 1746
// xdr-streaming                                                                                                  // 1747
var XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {                                   // 1748
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);                                      // 1749
};                                                                                                                // 1750
                                                                                                                  // 1751
XdrStreamingTransport.prototype = new AjaxBasedTransport();                                                       // 1752
                                                                                                                  // 1753
XdrStreamingTransport.enabled = function() {                                                                      // 1754
    return !!_window.XDomainRequest;                                                                              // 1755
};                                                                                                                // 1756
XdrStreamingTransport.roundTrips = 2; // preflight, ajax                                                          // 1757
                                                                                                                  // 1758
                                                                                                                  // 1759
                                                                                                                  // 1760
// xhr-polling                                                                                                    // 1761
var XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {                                       // 1762
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);                                            // 1763
};                                                                                                                // 1764
                                                                                                                  // 1765
XhrPollingTransport.prototype = new AjaxBasedTransport();                                                         // 1766
                                                                                                                  // 1767
XhrPollingTransport.enabled = XhrStreamingTransport.enabled;                                                      // 1768
XhrPollingTransport.roundTrips = 2; // preflight, ajax                                                            // 1769
                                                                                                                  // 1770
                                                                                                                  // 1771
// xdr-polling                                                                                                    // 1772
var XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {                                       // 1773
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);                                                // 1774
};                                                                                                                // 1775
                                                                                                                  // 1776
XdrPollingTransport.prototype = new AjaxBasedTransport();                                                         // 1777
                                                                                                                  // 1778
XdrPollingTransport.enabled = XdrStreamingTransport.enabled;                                                      // 1779
XdrPollingTransport.roundTrips = 2; // preflight, ajax                                                            // 1780
//         [*] End of lib/trans-xhr.js                                                                            // 1781
                                                                                                                  // 1782
                                                                                                                  // 1783
//         [*] Including lib/trans-iframe.js                                                                      // 1784
/*                                                                                                                // 1785
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1786
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1787
 *                                                                                                                // 1788
 * For the license see COPYING.                                                                                   // 1789
 * ***** END LICENSE BLOCK *****                                                                                  // 1790
 */                                                                                                               // 1791
                                                                                                                  // 1792
// Few cool transports do work only for same-origin. In order to make                                             // 1793
// them working cross-domain we shall use iframe, served form the                                                 // 1794
// remote domain. New browsers, have capabilities to communicate with                                             // 1795
// cross domain iframe, using postMessage(). In IE it was implemented                                             // 1796
// from IE 8+, but of course, IE got some details wrong:                                                          // 1797
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx                                              // 1798
//    http://stevesouders.com/misc/test-postmessage.php                                                           // 1799
                                                                                                                  // 1800
var IframeTransport = function() {};                                                                              // 1801
                                                                                                                  // 1802
IframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {                                     // 1803
    var that = this;                                                                                              // 1804
    that.ri = ri;                                                                                                 // 1805
    that.origin = utils.getOrigin(base_url);                                                                      // 1806
    that.base_url = base_url;                                                                                     // 1807
    that.trans_url = trans_url;                                                                                   // 1808
                                                                                                                  // 1809
    var iframe_url = base_url + '/iframe.html';                                                                   // 1810
    if (that.ri._options.devel) {                                                                                 // 1811
        iframe_url += '?t=' + (+new Date);                                                                        // 1812
    }                                                                                                             // 1813
    that.window_id = utils.random_string(8);                                                                      // 1814
    iframe_url += '#' + that.window_id;                                                                           // 1815
                                                                                                                  // 1816
    that.iframeObj = utils.createIframe(iframe_url, function(r) {                                                 // 1817
                                            that.ri._didClose(1006, "Unable to load an iframe (" + r + ")");      // 1818
                                        });                                                                       // 1819
                                                                                                                  // 1820
    that.onmessage_cb = utils.bind(that.onmessage, that);                                                         // 1821
    utils.attachMessage(that.onmessage_cb);                                                                       // 1822
};                                                                                                                // 1823
                                                                                                                  // 1824
IframeTransport.prototype.doCleanup = function() {                                                                // 1825
    var that = this;                                                                                              // 1826
    if (that.iframeObj) {                                                                                         // 1827
        utils.detachMessage(that.onmessage_cb);                                                                   // 1828
        try {                                                                                                     // 1829
            // When the iframe is not loaded, IE raises an exception                                              // 1830
            // on 'contentWindow'.                                                                                // 1831
            if (that.iframeObj.iframe.contentWindow) {                                                            // 1832
                that.postMessage('c');                                                                            // 1833
            }                                                                                                     // 1834
        } catch (x) {}                                                                                            // 1835
        that.iframeObj.cleanup();                                                                                 // 1836
        that.iframeObj = null;                                                                                    // 1837
        that.onmessage_cb = that.iframeObj = null;                                                                // 1838
    }                                                                                                             // 1839
};                                                                                                                // 1840
                                                                                                                  // 1841
IframeTransport.prototype.onmessage = function(e) {                                                               // 1842
    var that = this;                                                                                              // 1843
    if (e.origin !== that.origin) return;                                                                         // 1844
    var window_id = e.data.slice(0, 8);                                                                           // 1845
    var type = e.data.slice(8, 9);                                                                                // 1846
    var data = e.data.slice(9);                                                                                   // 1847
                                                                                                                  // 1848
    if (window_id !== that.window_id) return;                                                                     // 1849
                                                                                                                  // 1850
    switch(type) {                                                                                                // 1851
    case 's':                                                                                                     // 1852
        that.iframeObj.loaded();                                                                                  // 1853
        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));    // 1854
        break;                                                                                                    // 1855
    case 't':                                                                                                     // 1856
        that.ri._didMessage(data);                                                                                // 1857
        break;                                                                                                    // 1858
    }                                                                                                             // 1859
};                                                                                                                // 1860
                                                                                                                  // 1861
IframeTransport.prototype.postMessage = function(type, data) {                                                    // 1862
    var that = this;                                                                                              // 1863
    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);                                       // 1864
};                                                                                                                // 1865
                                                                                                                  // 1866
IframeTransport.prototype.doSend = function (message) {                                                           // 1867
    this.postMessage('m', message);                                                                               // 1868
};                                                                                                                // 1869
                                                                                                                  // 1870
IframeTransport.enabled = function() {                                                                            // 1871
    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with                                // 1872
    // huge delay, or not at all.                                                                                 // 1873
    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;          // 1874
    return ((typeof _window.postMessage === 'function' ||                                                         // 1875
            typeof _window.postMessage === 'object') && (!konqueror));                                            // 1876
};                                                                                                                // 1877
//         [*] End of lib/trans-iframe.js                                                                         // 1878
                                                                                                                  // 1879
                                                                                                                  // 1880
//         [*] Including lib/trans-iframe-within.js                                                               // 1881
/*                                                                                                                // 1882
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1883
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1884
 *                                                                                                                // 1885
 * For the license see COPYING.                                                                                   // 1886
 * ***** END LICENSE BLOCK *****                                                                                  // 1887
 */                                                                                                               // 1888
                                                                                                                  // 1889
var curr_window_id;                                                                                               // 1890
                                                                                                                  // 1891
var postMessage = function (type, data) {                                                                         // 1892
    if(parent !== _window) {                                                                                      // 1893
        parent.postMessage(curr_window_id + type + (data || ''), '*');                                            // 1894
    } else {                                                                                                      // 1895
        utils.log("Can't postMessage, no parent window.", type, data);                                            // 1896
    }                                                                                                             // 1897
};                                                                                                                // 1898
                                                                                                                  // 1899
var FacadeJS = function() {};                                                                                     // 1900
FacadeJS.prototype._didClose = function (code, reason) {                                                          // 1901
    postMessage('t', utils.closeFrame(code, reason));                                                             // 1902
};                                                                                                                // 1903
FacadeJS.prototype._didMessage = function (frame) {                                                               // 1904
    postMessage('t', frame);                                                                                      // 1905
};                                                                                                                // 1906
FacadeJS.prototype._doSend = function (data) {                                                                    // 1907
    this._transport.doSend(data);                                                                                 // 1908
};                                                                                                                // 1909
FacadeJS.prototype._doCleanup = function () {                                                                     // 1910
    this._transport.doCleanup();                                                                                  // 1911
};                                                                                                                // 1912
                                                                                                                  // 1913
utils.parent_origin = undefined;                                                                                  // 1914
                                                                                                                  // 1915
SockJS.bootstrap_iframe = function() {                                                                            // 1916
    var facade;                                                                                                   // 1917
    curr_window_id = _document.location.hash.slice(1);                                                            // 1918
    var onMessage = function(e) {                                                                                 // 1919
        if(e.source !== parent) return;                                                                           // 1920
        if(typeof utils.parent_origin === 'undefined')                                                            // 1921
            utils.parent_origin = e.origin;                                                                       // 1922
        if (e.origin !== utils.parent_origin) return;                                                             // 1923
                                                                                                                  // 1924
        var window_id = e.data.slice(0, 8);                                                                       // 1925
        var type = e.data.slice(8, 9);                                                                            // 1926
        var data = e.data.slice(9);                                                                               // 1927
        if (window_id !== curr_window_id) return;                                                                 // 1928
        switch(type) {                                                                                            // 1929
        case 's':                                                                                                 // 1930
            var p = JSON.parse(data);                                                                             // 1931
            var version = p[0];                                                                                   // 1932
            var protocol = p[1];                                                                                  // 1933
            var trans_url = p[2];                                                                                 // 1934
            var base_url = p[3];                                                                                  // 1935
            if (version !== SockJS.version) {                                                                     // 1936
                utils.log("Incompatibile SockJS! Main site uses:" +                                               // 1937
                          " \"" + version + "\", the iframe:" +                                                   // 1938
                          " \"" + SockJS.version + "\".");                                                        // 1939
            }                                                                                                     // 1940
            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {                                          // 1941
                utils.log("Only basic urls are supported in SockJS");                                             // 1942
                return;                                                                                           // 1943
            }                                                                                                     // 1944
                                                                                                                  // 1945
            if (!utils.isSameOriginUrl(trans_url) ||                                                              // 1946
                !utils.isSameOriginUrl(base_url)) {                                                               // 1947
                utils.log("Can't connect to different domain from within an " +                                   // 1948
                          "iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) +            // 1949
                          ")");                                                                                   // 1950
                return;                                                                                           // 1951
            }                                                                                                     // 1952
            facade = new FacadeJS();                                                                              // 1953
            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);                              // 1954
            break;                                                                                                // 1955
        case 'm':                                                                                                 // 1956
            facade._doSend(data);                                                                                 // 1957
            break;                                                                                                // 1958
        case 'c':                                                                                                 // 1959
            if (facade)                                                                                           // 1960
                facade._doCleanup();                                                                              // 1961
            facade = null;                                                                                        // 1962
            break;                                                                                                // 1963
        }                                                                                                         // 1964
    };                                                                                                            // 1965
                                                                                                                  // 1966
    // alert('test ticker');                                                                                      // 1967
    // facade = new FacadeJS();                                                                                   // 1968
    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');   // 1969
                                                                                                                  // 1970
    utils.attachMessage(onMessage);                                                                               // 1971
                                                                                                                  // 1972
    // Start                                                                                                      // 1973
    postMessage('s');                                                                                             // 1974
};                                                                                                                // 1975
//         [*] End of lib/trans-iframe-within.js                                                                  // 1976
                                                                                                                  // 1977
                                                                                                                  // 1978
//         [*] Including lib/info.js                                                                              // 1979
/*                                                                                                                // 1980
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1981
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1982
 *                                                                                                                // 1983
 * For the license see COPYING.                                                                                   // 1984
 * ***** END LICENSE BLOCK *****                                                                                  // 1985
 */                                                                                                               // 1986
                                                                                                                  // 1987
var InfoReceiver = function(base_url, AjaxObject) {                                                               // 1988
    var that = this;                                                                                              // 1989
    utils.delay(function(){that.doXhr(base_url, AjaxObject);});                                                   // 1990
};                                                                                                                // 1991
                                                                                                                  // 1992
InfoReceiver.prototype = new EventEmitter(['finish']);                                                            // 1993
                                                                                                                  // 1994
InfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {                                                   // 1995
    var that = this;                                                                                              // 1996
    var t0 = (new Date()).getTime();                                                                              // 1997
                                                                                                                  // 1998
// <METEOR>                                                                                                       // 1999
  // https://github.com/sockjs/sockjs-client/pull/129                                                             // 2000
  // var xo = new AjaxObject('GET', base_url + '/info');                                                          // 2001
                                                                                                                  // 2002
    var xo = new AjaxObject(                                                                                      // 2003
      // add cachebusting parameter to url to work around a chrome bug:                                           // 2004
      // https://code.google.com/p/chromium/issues/detail?id=263981                                               // 2005
      // or misbehaving proxies.                                                                                  // 2006
      'GET', base_url + '/info?cb=' + utils.random_string(10))                                                    // 2007
// </METEOR>                                                                                                      // 2008
                                                                                                                  // 2009
    var tref = utils.delay(8000,                                                                                  // 2010
                           function(){xo.ontimeout();});                                                          // 2011
                                                                                                                  // 2012
    xo.onfinish = function(status, text) {                                                                        // 2013
        clearTimeout(tref);                                                                                       // 2014
        tref = null;                                                                                              // 2015
        if (status === 200) {                                                                                     // 2016
            var rtt = (new Date()).getTime() - t0;                                                                // 2017
            var info = JSON.parse(text);                                                                          // 2018
            if (typeof info !== 'object') info = {};                                                              // 2019
            that.emit('finish', info, rtt);                                                                       // 2020
        } else {                                                                                                  // 2021
            that.emit('finish');                                                                                  // 2022
        }                                                                                                         // 2023
    };                                                                                                            // 2024
    xo.ontimeout = function() {                                                                                   // 2025
        xo.close();                                                                                               // 2026
        that.emit('finish');                                                                                      // 2027
    };                                                                                                            // 2028
};                                                                                                                // 2029
                                                                                                                  // 2030
var InfoReceiverIframe = function(base_url) {                                                                     // 2031
    var that = this;                                                                                              // 2032
    var go = function() {                                                                                         // 2033
        var ifr = new IframeTransport();                                                                          // 2034
        ifr.protocol = 'w-iframe-info-receiver';                                                                  // 2035
        var fun = function(r) {                                                                                   // 2036
            if (typeof r === 'string' && r.substr(0,1) === 'm') {                                                 // 2037
                var d = JSON.parse(r.substr(1));                                                                  // 2038
                var info = d[0], rtt = d[1];                                                                      // 2039
                that.emit('finish', info, rtt);                                                                   // 2040
            } else {                                                                                              // 2041
                that.emit('finish');                                                                              // 2042
            }                                                                                                     // 2043
            ifr.doCleanup();                                                                                      // 2044
            ifr = null;                                                                                           // 2045
        };                                                                                                        // 2046
        var mock_ri = {                                                                                           // 2047
            _options: {},                                                                                         // 2048
            _didClose: fun,                                                                                       // 2049
            _didMessage: fun                                                                                      // 2050
        };                                                                                                        // 2051
        ifr.i_constructor(mock_ri, base_url, base_url);                                                           // 2052
    }                                                                                                             // 2053
    if(!_document.body) {                                                                                         // 2054
        utils.attachEvent('load', go);                                                                            // 2055
    } else {                                                                                                      // 2056
        go();                                                                                                     // 2057
    }                                                                                                             // 2058
};                                                                                                                // 2059
InfoReceiverIframe.prototype = new EventEmitter(['finish']);                                                      // 2060
                                                                                                                  // 2061
                                                                                                                  // 2062
var InfoReceiverFake = function() {                                                                               // 2063
    // It may not be possible to do cross domain AJAX to get the info                                             // 2064
    // data, for example for IE7. But we want to run JSONP, so let's                                              // 2065
    // fake the response, with rtt=2s (rto=6s).                                                                   // 2066
    var that = this;                                                                                              // 2067
    utils.delay(function() {                                                                                      // 2068
        that.emit('finish', {}, 2000);                                                                            // 2069
    });                                                                                                           // 2070
};                                                                                                                // 2071
InfoReceiverFake.prototype = new EventEmitter(['finish']);                                                        // 2072
                                                                                                                  // 2073
var createInfoReceiver = function(base_url) {                                                                     // 2074
    if (utils.isSameOriginUrl(base_url)) {                                                                        // 2075
        // If, for some reason, we have SockJS locally - there's no                                               // 2076
        // need to start up the complex machinery. Just use ajax.                                                 // 2077
        return new InfoReceiver(base_url, utils.XHRLocalObject);                                                  // 2078
    }                                                                                                             // 2079
    switch (utils.isXHRCorsCapable()) {                                                                           // 2080
    case 1:                                                                                                       // 2081
        // XHRLocalObject -> no_credentials=true                                                                  // 2082
        return new InfoReceiver(base_url, utils.XHRLocalObject);                                                  // 2083
    case 2:                                                                                                       // 2084
// <METEOR>                                                                                                       // 2085
// https://github.com/sockjs/sockjs-client/issues/79                                                              // 2086
        // XDR doesn't work across different schemes                                                              // 2087
        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
        if (utils.isSameOriginScheme(base_url))                                                                   // 2089
            return new InfoReceiver(base_url, utils.XDRObject);                                                   // 2090
        else                                                                                                      // 2091
            return new InfoReceiverFake();                                                                        // 2092
// </METEOR>                                                                                                      // 2093
    case 3:                                                                                                       // 2094
        // Opera                                                                                                  // 2095
        return new InfoReceiverIframe(base_url);                                                                  // 2096
    default:                                                                                                      // 2097
        // IE 7                                                                                                   // 2098
        return new InfoReceiverFake();                                                                            // 2099
    };                                                                                                            // 2100
};                                                                                                                // 2101
                                                                                                                  // 2102
                                                                                                                  // 2103
var WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {               // 2104
    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);                                                    // 2105
    ir.onfinish = function(info, rtt) {                                                                           // 2106
        ri._didMessage('m'+JSON.stringify([info, rtt]));                                                          // 2107
        ri._didClose();                                                                                           // 2108
    }                                                                                                             // 2109
};                                                                                                                // 2110
WInfoReceiverIframe.prototype.doCleanup = function() {};                                                          // 2111
//         [*] End of lib/info.js                                                                                 // 2112
                                                                                                                  // 2113
                                                                                                                  // 2114
//         [*] Including lib/trans-iframe-eventsource.js                                                          // 2115
/*                                                                                                                // 2116
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2117
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2118
 *                                                                                                                // 2119
 * For the license see COPYING.                                                                                   // 2120
 * ***** END LICENSE BLOCK *****                                                                                  // 2121
 */                                                                                                               // 2122
                                                                                                                  // 2123
var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {                                     // 2124
    var that = this;                                                                                              // 2125
    that.protocol = 'w-iframe-eventsource';                                                                       // 2126
    that.i_constructor.apply(that, arguments);                                                                    // 2127
};                                                                                                                // 2128
                                                                                                                  // 2129
EventSourceIframeTransport.prototype = new IframeTransport();                                                     // 2130
                                                                                                                  // 2131
EventSourceIframeTransport.enabled = function () {                                                                // 2132
    return ('EventSource' in _window) && IframeTransport.enabled();                                               // 2133
};                                                                                                                // 2134
                                                                                                                  // 2135
EventSourceIframeTransport.need_body = true;                                                                      // 2136
EventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource                                       // 2137
                                                                                                                  // 2138
                                                                                                                  // 2139
// w-iframe-eventsource                                                                                           // 2140
var EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {                           // 2141
    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);                           // 2142
}                                                                                                                 // 2143
EventSourceTransport.prototype = new AjaxBasedTransport();                                                        // 2144
//         [*] End of lib/trans-iframe-eventsource.js                                                             // 2145
                                                                                                                  // 2146
                                                                                                                  // 2147
//         [*] Including lib/trans-iframe-xhr-polling.js                                                          // 2148
/*                                                                                                                // 2149
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2150
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2151
 *                                                                                                                // 2152
 * For the license see COPYING.                                                                                   // 2153
 * ***** END LICENSE BLOCK *****                                                                                  // 2154
 */                                                                                                               // 2155
                                                                                                                  // 2156
var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {                                      // 2157
    var that = this;                                                                                              // 2158
    that.protocol = 'w-iframe-xhr-polling';                                                                       // 2159
    that.i_constructor.apply(that, arguments);                                                                    // 2160
};                                                                                                                // 2161
                                                                                                                  // 2162
XhrPollingIframeTransport.prototype = new IframeTransport();                                                      // 2163
                                                                                                                  // 2164
XhrPollingIframeTransport.enabled = function () {                                                                 // 2165
    return _window.XMLHttpRequest && IframeTransport.enabled();                                                   // 2166
};                                                                                                                // 2167
                                                                                                                  // 2168
XhrPollingIframeTransport.need_body = true;                                                                       // 2169
XhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr                                                // 2170
                                                                                                                  // 2171
                                                                                                                  // 2172
// w-iframe-xhr-polling                                                                                           // 2173
var XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {                           // 2174
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);                                           // 2175
};                                                                                                                // 2176
                                                                                                                  // 2177
XhrPollingITransport.prototype = new AjaxBasedTransport();                                                        // 2178
//         [*] End of lib/trans-iframe-xhr-polling.js                                                             // 2179
                                                                                                                  // 2180
                                                                                                                  // 2181
//         [*] Including lib/trans-iframe-htmlfile.js                                                             // 2182
/*                                                                                                                // 2183
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2184
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2185
 *                                                                                                                // 2186
 * For the license see COPYING.                                                                                   // 2187
 * ***** END LICENSE BLOCK *****                                                                                  // 2188
 */                                                                                                               // 2189
                                                                                                                  // 2190
// This transport generally works in any browser, but will cause a                                                // 2191
// spinning cursor to appear in any browser other than IE.                                                        // 2192
// We may test this transport in all browsers - why not, but in                                                   // 2193
// production it should be only run in IE.                                                                        // 2194
                                                                                                                  // 2195
var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {                                           // 2196
    var that = this;                                                                                              // 2197
    that.protocol = 'w-iframe-htmlfile';                                                                          // 2198
    that.i_constructor.apply(that, arguments);                                                                    // 2199
};                                                                                                                // 2200
                                                                                                                  // 2201
// Inheritance.                                                                                                   // 2202
HtmlFileIframeTransport.prototype = new IframeTransport();                                                        // 2203
                                                                                                                  // 2204
HtmlFileIframeTransport.enabled = function() {                                                                    // 2205
    return IframeTransport.enabled();                                                                             // 2206
};                                                                                                                // 2207
                                                                                                                  // 2208
HtmlFileIframeTransport.need_body = true;                                                                         // 2209
HtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile                                             // 2210
                                                                                                                  // 2211
                                                                                                                  // 2212
// w-iframe-htmlfile                                                                                              // 2213
var HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {                                 // 2214
    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);                                 // 2215
};                                                                                                                // 2216
HtmlFileTransport.prototype = new AjaxBasedTransport();                                                           // 2217
//         [*] End of lib/trans-iframe-htmlfile.js                                                                // 2218
                                                                                                                  // 2219
                                                                                                                  // 2220
//         [*] Including lib/trans-polling.js                                                                     // 2221
/*                                                                                                                // 2222
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2223
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2224
 *                                                                                                                // 2225
 * For the license see COPYING.                                                                                   // 2226
 * ***** END LICENSE BLOCK *****                                                                                  // 2227
 */                                                                                                               // 2228
                                                                                                                  // 2229
var Polling = function(ri, Receiver, recv_url, AjaxObject) {                                                      // 2230
    var that = this;                                                                                              // 2231
    that.ri = ri;                                                                                                 // 2232
    that.Receiver = Receiver;                                                                                     // 2233
    that.recv_url = recv_url;                                                                                     // 2234
    that.AjaxObject = AjaxObject;                                                                                 // 2235
    that._scheduleRecv();                                                                                         // 2236
};                                                                                                                // 2237
                                                                                                                  // 2238
Polling.prototype._scheduleRecv = function() {                                                                    // 2239
    var that = this;                                                                                              // 2240
    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);                                     // 2241
    var msg_counter = 0;                                                                                          // 2242
    poll.onmessage = function(e) {                                                                                // 2243
        msg_counter += 1;                                                                                         // 2244
        that.ri._didMessage(e.data);                                                                              // 2245
    };                                                                                                            // 2246
    poll.onclose = function(e) {                                                                                  // 2247
        that.poll = poll = poll.onmessage = poll.onclose = null;                                                  // 2248
        if (!that.poll_is_closing) {                                                                              // 2249
            if (e.reason === 'permanent') {                                                                       // 2250
                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');                                      // 2251
            } else {                                                                                              // 2252
                that._scheduleRecv();                                                                             // 2253
            }                                                                                                     // 2254
        }                                                                                                         // 2255
    };                                                                                                            // 2256
};                                                                                                                // 2257
                                                                                                                  // 2258
Polling.prototype.abort = function() {                                                                            // 2259
    var that = this;                                                                                              // 2260
    that.poll_is_closing = true;                                                                                  // 2261
    if (that.poll) {                                                                                              // 2262
        that.poll.abort();                                                                                        // 2263
    }                                                                                                             // 2264
};                                                                                                                // 2265
//         [*] End of lib/trans-polling.js                                                                        // 2266
                                                                                                                  // 2267
                                                                                                                  // 2268
//         [*] Including lib/trans-receiver-eventsource.js                                                        // 2269
/*                                                                                                                // 2270
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2271
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2272
 *                                                                                                                // 2273
 * For the license see COPYING.                                                                                   // 2274
 * ***** END LICENSE BLOCK *****                                                                                  // 2275
 */                                                                                                               // 2276
                                                                                                                  // 2277
var EventSourceReceiver = function(url) {                                                                         // 2278
    var that = this;                                                                                              // 2279
    var es = new EventSource(url);                                                                                // 2280
    es.onmessage = function(e) {                                                                                  // 2281
        that.dispatchEvent(new SimpleEvent('message',                                                             // 2282
                                           {'data': unescape(e.data)}));                                          // 2283
    };                                                                                                            // 2284
    that.es_close = es.onerror = function(e, abort_reason) {                                                      // 2285
        // ES on reconnection has readyState = 0 or 1.                                                            // 2286
        // on network error it's CLOSED = 2                                                                       // 2287
        var reason = abort_reason ? 'user' :                                                                      // 2288
            (es.readyState !== 2 ? 'network' : 'permanent');                                                      // 2289
        that.es_close = es.onmessage = es.onerror = null;                                                         // 2290
        // EventSource reconnects automatically.                                                                  // 2291
        es.close();                                                                                               // 2292
        es = null;                                                                                                // 2293
        // Safari and chrome < 15 crash if we close window before                                                 // 2294
        // waiting for ES cleanup. See:                                                                           // 2295
        //   https://code.google.com/p/chromium/issues/detail?id=89155                                            // 2296
        utils.delay(200, function() {                                                                             // 2297
                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));                           // 2298
                    });                                                                                           // 2299
    };                                                                                                            // 2300
};                                                                                                                // 2301
                                                                                                                  // 2302
EventSourceReceiver.prototype = new REventTarget();                                                               // 2303
                                                                                                                  // 2304
EventSourceReceiver.prototype.abort = function() {                                                                // 2305
    var that = this;                                                                                              // 2306
    if (that.es_close) {                                                                                          // 2307
        that.es_close({}, true);                                                                                  // 2308
    }                                                                                                             // 2309
};                                                                                                                // 2310
//         [*] End of lib/trans-receiver-eventsource.js                                                           // 2311
                                                                                                                  // 2312
                                                                                                                  // 2313
//         [*] Including lib/trans-receiver-htmlfile.js                                                           // 2314
/*                                                                                                                // 2315
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2316
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2317
 *                                                                                                                // 2318
 * For the license see COPYING.                                                                                   // 2319
 * ***** END LICENSE BLOCK *****                                                                                  // 2320
 */                                                                                                               // 2321
                                                                                                                  // 2322
var _is_ie_htmlfile_capable;                                                                                      // 2323
var isIeHtmlfileCapable = function() {                                                                            // 2324
    if (_is_ie_htmlfile_capable === undefined) {                                                                  // 2325
        if ('ActiveXObject' in _window) {                                                                         // 2326
            try {                                                                                                 // 2327
                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');                                        // 2328
            } catch (x) {}                                                                                        // 2329
        } else {                                                                                                  // 2330
            _is_ie_htmlfile_capable = false;                                                                      // 2331
        }                                                                                                         // 2332
    }                                                                                                             // 2333
    return _is_ie_htmlfile_capable;                                                                               // 2334
};                                                                                                                // 2335
                                                                                                                  // 2336
                                                                                                                  // 2337
var HtmlfileReceiver = function(url) {                                                                            // 2338
    var that = this;                                                                                              // 2339
    utils.polluteGlobalNamespace();                                                                               // 2340
                                                                                                                  // 2341
    that.id = 'a' + utils.random_string(6, 26);                                                                   // 2342
    url += ((url.indexOf('?') === -1) ? '?' : '&') +                                                              // 2343
        'c=' + escape(WPrefix + '.' + that.id);                                                                   // 2344
                                                                                                                  // 2345
    var constructor = isIeHtmlfileCapable() ?                                                                     // 2346
        utils.createHtmlfile : utils.createIframe;                                                                // 2347
                                                                                                                  // 2348
    var iframeObj;                                                                                                // 2349
    _window[WPrefix][that.id] = {                                                                                 // 2350
        start: function () {                                                                                      // 2351
            iframeObj.loaded();                                                                                   // 2352
        },                                                                                                        // 2353
        message: function (data) {                                                                                // 2354
            that.dispatchEvent(new SimpleEvent('message', {'data': data}));                                       // 2355
        },                                                                                                        // 2356
        stop: function () {                                                                                       // 2357
            that.iframe_close({}, 'network');                                                                     // 2358
        }                                                                                                         // 2359
    };                                                                                                            // 2360
    that.iframe_close = function(e, abort_reason) {                                                               // 2361
        iframeObj.cleanup();                                                                                      // 2362
        that.iframe_close = iframeObj = null;                                                                     // 2363
        delete _window[WPrefix][that.id];                                                                         // 2364
        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));                                     // 2365
    };                                                                                                            // 2366
    iframeObj = constructor(url, function(e) {                                                                    // 2367
                                that.iframe_close({}, 'permanent');                                               // 2368
                            });                                                                                   // 2369
};                                                                                                                // 2370
                                                                                                                  // 2371
HtmlfileReceiver.prototype = new REventTarget();                                                                  // 2372
                                                                                                                  // 2373
HtmlfileReceiver.prototype.abort = function() {                                                                   // 2374
    var that = this;                                                                                              // 2375
    if (that.iframe_close) {                                                                                      // 2376
        that.iframe_close({}, 'user');                                                                            // 2377
    }                                                                                                             // 2378
};                                                                                                                // 2379
//         [*] End of lib/trans-receiver-htmlfile.js                                                              // 2380
                                                                                                                  // 2381
                                                                                                                  // 2382
//         [*] Including lib/trans-receiver-xhr.js                                                                // 2383
/*                                                                                                                // 2384
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2385
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2386
 *                                                                                                                // 2387
 * For the license see COPYING.                                                                                   // 2388
 * ***** END LICENSE BLOCK *****                                                                                  // 2389
 */                                                                                                               // 2390
                                                                                                                  // 2391
var XhrReceiver = function(url, AjaxObject) {                                                                     // 2392
    var that = this;                                                                                              // 2393
    var buf_pos = 0;                                                                                              // 2394
                                                                                                                  // 2395
    that.xo = new AjaxObject('POST', url, null);                                                                  // 2396
    that.xo.onchunk = function(status, text) {                                                                    // 2397
        if (status !== 200) return;                                                                               // 2398
        while (1) {                                                                                               // 2399
            var buf = text.slice(buf_pos);                                                                        // 2400
            var p = buf.indexOf('\n');                                                                            // 2401
            if (p === -1) break;                                                                                  // 2402
            buf_pos += p+1;                                                                                       // 2403
            var msg = buf.slice(0, p);                                                                            // 2404
            that.dispatchEvent(new SimpleEvent('message', {data: msg}));                                          // 2405
        }                                                                                                         // 2406
    };                                                                                                            // 2407
    that.xo.onfinish = function(status, text) {                                                                   // 2408
        that.xo.onchunk(status, text);                                                                            // 2409
        that.xo = null;                                                                                           // 2410
        var reason = status === 200 ? 'network' : 'permanent';                                                    // 2411
        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));                                           // 2412
    }                                                                                                             // 2413
};                                                                                                                // 2414
                                                                                                                  // 2415
XhrReceiver.prototype = new REventTarget();                                                                       // 2416
                                                                                                                  // 2417
XhrReceiver.prototype.abort = function() {                                                                        // 2418
    var that = this;                                                                                              // 2419
    if (that.xo) {                                                                                                // 2420
        that.xo.close();                                                                                          // 2421
        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));                                           // 2422
        that.xo = null;                                                                                           // 2423
    }                                                                                                             // 2424
};                                                                                                                // 2425
//         [*] End of lib/trans-receiver-xhr.js                                                                   // 2426
                                                                                                                  // 2427
                                                                                                                  // 2428
//         [*] Including lib/test-hooks.js                                                                        // 2429
/*                                                                                                                // 2430
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2431
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2432
 *                                                                                                                // 2433
 * For the license see COPYING.                                                                                   // 2434
 * ***** END LICENSE BLOCK *****                                                                                  // 2435
 */                                                                                                               // 2436
                                                                                                                  // 2437
// For testing                                                                                                    // 2438
SockJS.getUtils = function(){                                                                                     // 2439
    return utils;                                                                                                 // 2440
};                                                                                                                // 2441
                                                                                                                  // 2442
SockJS.getIframeTransport = function(){                                                                           // 2443
    return IframeTransport;                                                                                       // 2444
};                                                                                                                // 2445
//         [*] End of lib/test-hooks.js                                                                           // 2446
                                                                                                                  // 2447
                  return SockJS;                                                                                  // 2448
          })();                                                                                                   // 2449
if ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);                                                    // 2450
                                                                                                                  // 2451
// AMD compliance                                                                                                 // 2452
if (typeof define === 'function' && define.amd) {                                                                 // 2453
    define('sockjs', [], function(){return SockJS;});                                                             // 2454
}                                                                                                                 // 2455
//     [*] End of lib/index.js                                                                                    // 2456
                                                                                                                  // 2457
// [*] End of lib/all.js                                                                                          // 2458
                                                                                                                  // 2459
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/ddp/stream_client_sockjs.js                                                                           //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// @param url {String} URL to Meteor app                                                                          // 1
//   "http://subdomain.meteor.com/" or "/" or                                                                     // 2
//   "ddp+sockjs://foo-**.meteor.com/sockjs"                                                                      // 3
LivedataTest.ClientStream = function (url, options) {                                                             // 4
  var self = this;                                                                                                // 5
  self.options = _.extend({                                                                                       // 6
    retry: true                                                                                                   // 7
  }, options);                                                                                                    // 8
  self._initCommon(self.options);                                                                                 // 9
                                                                                                                  // 10
  //// Constants                                                                                                  // 11
                                                                                                                  // 12
                                                                                                                  // 13
  // how long between hearing heartbeat from the server until we declare                                          // 14
  // the connection dead. heartbeats come every 45s (stream_server.js)                                            // 15
  //                                                                                                              // 16
  // NOTE: this is a older timeout mechanism. We now send heartbeats at                                           // 17
  // the DDP level (https://github.com/meteor/meteor/pull/1865), and                                              // 18
  // expect those timeouts to kill a non-responsive connection before                                             // 19
  // this timeout fires. This is kept around for compatibility (when                                              // 20
  // talking to a server that doesn't support DDP heartbeats) and can be                                          // 21
  // removed later.                                                                                               // 22
  self.HEARTBEAT_TIMEOUT = 100*1000;                                                                              // 23
                                                                                                                  // 24
  self.rawUrl = url;                                                                                              // 25
  self.socket = null;                                                                                             // 26
                                                                                                                  // 27
  self.heartbeatTimer = null;                                                                                     // 28
                                                                                                                  // 29
  // Listen to global 'online' event if we are running in a browser.                                              // 30
  // (IE8 does not support addEventListener)                                                                      // 31
  if (typeof window !== 'undefined' && window.addEventListener)                                                   // 32
    window.addEventListener("online", _.bind(self._online, self),                                                 // 33
                            false /* useCapture. make FF3.6 happy. */);                                           // 34
                                                                                                                  // 35
  //// Kickoff!                                                                                                   // 36
  self._launchConnection();                                                                                       // 37
};                                                                                                                // 38
                                                                                                                  // 39
_.extend(LivedataTest.ClientStream.prototype, {                                                                   // 40
                                                                                                                  // 41
  // data is a utf8 string. Data sent while not connected is dropped on                                           // 42
  // the floor, and it is up the user of this API to retransmit lost                                              // 43
  // messages on 'reset'                                                                                          // 44
  send: function (data) {                                                                                         // 45
    var self = this;                                                                                              // 46
    if (self.currentStatus.connected) {                                                                           // 47
      self.socket.send(data);                                                                                     // 48
    }                                                                                                             // 49
  },                                                                                                              // 50
                                                                                                                  // 51
  // Changes where this connection points                                                                         // 52
  _changeUrl: function (url) {                                                                                    // 53
    var self = this;                                                                                              // 54
    self.rawUrl = url;                                                                                            // 55
  },                                                                                                              // 56
                                                                                                                  // 57
  _connected: function () {                                                                                       // 58
    var self = this;                                                                                              // 59
                                                                                                                  // 60
    if (self.connectionTimer) {                                                                                   // 61
      clearTimeout(self.connectionTimer);                                                                         // 62
      self.connectionTimer = null;                                                                                // 63
    }                                                                                                             // 64
                                                                                                                  // 65
    if (self.currentStatus.connected) {                                                                           // 66
      // already connected. do nothing. this probably shouldn't happen.                                           // 67
      return;                                                                                                     // 68
    }                                                                                                             // 69
                                                                                                                  // 70
    // update status                                                                                              // 71
    self.currentStatus.status = "connected";                                                                      // 72
    self.currentStatus.connected = true;                                                                          // 73
    self.currentStatus.retryCount = 0;                                                                            // 74
    self.statusChanged();                                                                                         // 75
                                                                                                                  // 76
    // fire resets. This must come after status change so that clients                                            // 77
    // can call send from within a reset callback.                                                                // 78
    _.each(self.eventCallbacks.reset, function (callback) { callback(); });                                       // 79
                                                                                                                  // 80
  },                                                                                                              // 81
                                                                                                                  // 82
  _cleanup: function (maybeError) {                                                                               // 83
    var self = this;                                                                                              // 84
                                                                                                                  // 85
    self._clearConnectionAndHeartbeatTimers();                                                                    // 86
    if (self.socket) {                                                                                            // 87
      self.socket.onmessage = self.socket.onclose                                                                 // 88
        = self.socket.onerror = self.socket.onheartbeat = function () {};                                         // 89
      self.socket.close();                                                                                        // 90
      self.socket = null;                                                                                         // 91
    }                                                                                                             // 92
                                                                                                                  // 93
    _.each(self.eventCallbacks.disconnect, function (callback) {                                                  // 94
      callback(maybeError);                                                                                       // 95
    });                                                                                                           // 96
  },                                                                                                              // 97
                                                                                                                  // 98
  _clearConnectionAndHeartbeatTimers: function () {                                                               // 99
    var self = this;                                                                                              // 100
    if (self.connectionTimer) {                                                                                   // 101
      clearTimeout(self.connectionTimer);                                                                         // 102
      self.connectionTimer = null;                                                                                // 103
    }                                                                                                             // 104
    if (self.heartbeatTimer) {                                                                                    // 105
      clearTimeout(self.heartbeatTimer);                                                                          // 106
      self.heartbeatTimer = null;                                                                                 // 107
    }                                                                                                             // 108
  },                                                                                                              // 109
                                                                                                                  // 110
  _heartbeat_timeout: function () {                                                                               // 111
    var self = this;                                                                                              // 112
    Meteor._debug("Connection timeout. No sockjs heartbeat received.");                                           // 113
    self._lostConnection(new DDP.ConnectionError("Heartbeat timed out"));                                         // 114
  },                                                                                                              // 115
                                                                                                                  // 116
  _heartbeat_received: function () {                                                                              // 117
    var self = this;                                                                                              // 118
    // If we've already permanently shut down this stream, the timeout is                                         // 119
    // already cleared, and we don't need to set it again.                                                        // 120
    if (self._forcedToDisconnect)                                                                                 // 121
      return;                                                                                                     // 122
    if (self.heartbeatTimer)                                                                                      // 123
      clearTimeout(self.heartbeatTimer);                                                                          // 124
    self.heartbeatTimer = setTimeout(                                                                             // 125
      _.bind(self._heartbeat_timeout, self),                                                                      // 126
      self.HEARTBEAT_TIMEOUT);                                                                                    // 127
  },                                                                                                              // 128
                                                                                                                  // 129
  _sockjsProtocolsWhitelist: function () {                                                                        // 130
    // only allow polling protocols. no streaming.  streaming                                                     // 131
    // makes safari spin.                                                                                         // 132
    var protocolsWhitelist = [                                                                                    // 133
      'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'];                                       // 134
                                                                                                                  // 135
    // iOS 4 and 5 and below crash when using websockets over certain                                             // 136
    // proxies. this seems to be resolved with iOS 6. eg                                                          // 137
    // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.                                   // 138
    //                                                                                                            // 139
    // iOS <4 doesn't support websockets at all so sockjs will just                                               // 140
    // immediately fall back to http                                                                              // 141
    var noWebsockets = navigator &&                                                                               // 142
          /iPhone|iPad|iPod/.test(navigator.userAgent) &&                                                         // 143
          /OS 4_|OS 5_/.test(navigator.userAgent);                                                                // 144
                                                                                                                  // 145
    if (!noWebsockets)                                                                                            // 146
      protocolsWhitelist = ['websocket'].concat(protocolsWhitelist);                                              // 147
                                                                                                                  // 148
    return protocolsWhitelist;                                                                                    // 149
  },                                                                                                              // 150
                                                                                                                  // 151
  _launchConnection: function () {                                                                                // 152
    var self = this;                                                                                              // 153
    self._cleanup(); // cleanup the old socket, if there was one.                                                 // 154
                                                                                                                  // 155
    var options = _.extend({                                                                                      // 156
      protocols_whitelist:self._sockjsProtocolsWhitelist()                                                        // 157
    }, self.options._sockjsOptions);                                                                              // 158
                                                                                                                  // 159
    // Convert raw URL to SockJS URL each time we open a connection, so that we                                   // 160
    // can connect to random hostnames and get around browser per-host                                            // 161
    // connection limits.                                                                                         // 162
    self.socket = new SockJS(toSockjsUrl(self.rawUrl), undefined, options);                                       // 163
    self.socket.onopen = function (data) {                                                                        // 164
      self._connected();                                                                                          // 165
    };                                                                                                            // 166
    self.socket.onmessage = function (data) {                                                                     // 167
      self._heartbeat_received();                                                                                 // 168
                                                                                                                  // 169
      if (self.currentStatus.connected)                                                                           // 170
        _.each(self.eventCallbacks.message, function (callback) {                                                 // 171
          callback(data.data);                                                                                    // 172
        });                                                                                                       // 173
    };                                                                                                            // 174
    self.socket.onclose = function () {                                                                           // 175
      self._lostConnection();                                                                                     // 176
    };                                                                                                            // 177
    self.socket.onerror = function () {                                                                           // 178
      // XXX is this ever called?                                                                                 // 179
      Meteor._debug("stream error", _.toArray(arguments), (new Date()).toDateString());                           // 180
    };                                                                                                            // 181
                                                                                                                  // 182
    self.socket.onheartbeat =  function () {                                                                      // 183
      self._heartbeat_received();                                                                                 // 184
    };                                                                                                            // 185
                                                                                                                  // 186
    if (self.connectionTimer)                                                                                     // 187
      clearTimeout(self.connectionTimer);                                                                         // 188
    self.connectionTimer = setTimeout(function () {                                                               // 189
      self._lostConnection(                                                                                       // 190
        new DDP.ConnectionError("DDP connection timed out"));                                                     // 191
    }, self.CONNECT_TIMEOUT);                                                                                     // 192
  }                                                                                                               // 193
});                                                                                                               // 194
                                                                                                                  // 195
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/ddp/stream_client_common.js                                                                           //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// XXX from Underscore.String (http://epeli.github.com/underscore.string/)                                        // 1
var startsWith = function(str, starts) {                                                                          // 2
  return str.length >= starts.length &&                                                                           // 3
    str.substring(0, starts.length) === starts;                                                                   // 4
};                                                                                                                // 5
var endsWith = function(str, ends) {                                                                              // 6
  return str.length >= ends.length &&                                                                             // 7
    str.substring(str.length - ends.length) === ends;                                                             // 8
};                                                                                                                // 9
                                                                                                                  // 10
// @param url {String} URL to Meteor app, eg:                                                                     // 11
//   "/" or "madewith.meteor.com" or "https://foo.meteor.com"                                                     // 12
//   or "ddp+sockjs://ddp--****-foo.meteor.com/sockjs"                                                            // 13
// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.                               // 14
// for scheme "http" and subPath "sockjs"                                                                         // 15
//   "http://subdomain.meteor.com/sockjs" or "/sockjs"                                                            // 16
//   or "https://ddp--1234-foo.meteor.com/sockjs"                                                                 // 17
var translateUrl =  function(url, newSchemeBase, subPath) {                                                       // 18
  if (! newSchemeBase) {                                                                                          // 19
    newSchemeBase = "http";                                                                                       // 20
  }                                                                                                               // 21
                                                                                                                  // 22
  var ddpUrlMatch = url.match(/^ddp(i?)\+sockjs:\/\//);                                                           // 23
  var httpUrlMatch = url.match(/^http(s?):\/\//);                                                                 // 24
  var newScheme;                                                                                                  // 25
  if (ddpUrlMatch) {                                                                                              // 26
    // Remove scheme and split off the host.                                                                      // 27
    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);                                                          // 28
    newScheme = ddpUrlMatch[1] === "i" ? newSchemeBase : newSchemeBase + "s";                                     // 29
    var slashPos = urlAfterDDP.indexOf('/');                                                                      // 30
    var host =                                                                                                    // 31
          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);                                        // 32
    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);                                               // 33
                                                                                                                  // 34
    // In the host (ONLY!), change '*' characters into random digits. This                                        // 35
    // allows different stream connections to connect to different hostnames                                      // 36
    // and avoid browser per-hostname connection limits.                                                          // 37
    host = host.replace(/\*/g, function () {                                                                      // 38
      return Math.floor(Random.fraction()*10);                                                                    // 39
    });                                                                                                           // 40
                                                                                                                  // 41
    return newScheme + '://' + host + rest;                                                                       // 42
  } else if (httpUrlMatch) {                                                                                      // 43
    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + "s";                                           // 44
    var urlAfterHttp = url.substr(httpUrlMatch[0].length);                                                        // 45
    url = newScheme + "://" + urlAfterHttp;                                                                       // 46
  }                                                                                                               // 47
                                                                                                                  // 48
  // Prefix FQDNs but not relative URLs                                                                           // 49
  if (url.indexOf("://") === -1 && !startsWith(url, "/")) {                                                       // 50
    url = newSchemeBase + "://" + url;                                                                            // 51
  }                                                                                                               // 52
                                                                                                                  // 53
  // XXX This is not what we should be doing: if I have a site                                                    // 54
  // deployed at "/foo", then DDP.connect("/") should actually connect                                            // 55
  // to "/", not to "/foo". "/" is an absolute path. (Contrast: if                                                // 56
  // deployed at "/foo", it would be reasonable for DDP.connect("bar")                                            // 57
  // to connect to "/foo/bar").                                                                                   // 58
  //                                                                                                              // 59
  // We should make this properly honor absolute paths rather than                                                // 60
  // forcing the path to be relative to the site root. Simultaneously,                                            // 61
  // we should set DDP_DEFAULT_CONNECTION_URL to include the site                                                 // 62
  // root. See also client_convenience.js #RationalizingRelativeDDPURLs                                           // 63
  url = Meteor._relativeToSiteRootUrl(url);                                                                       // 64
                                                                                                                  // 65
  if (endsWith(url, "/"))                                                                                         // 66
    return url + subPath;                                                                                         // 67
  else                                                                                                            // 68
    return url + "/" + subPath;                                                                                   // 69
};                                                                                                                // 70
                                                                                                                  // 71
toSockjsUrl = function (url) {                                                                                    // 72
  return translateUrl(url, "http", "sockjs");                                                                     // 73
};                                                                                                                // 74
                                                                                                                  // 75
toWebsocketUrl = function (url) {                                                                                 // 76
  var ret = translateUrl(url, "ws", "websocket");                                                                 // 77
  return ret;                                                                                                     // 78
};                                                                                                                // 79
                                                                                                                  // 80
LivedataTest.toSockjsUrl = toSockjsUrl;                                                                           // 81
                                                                                                                  // 82
                                                                                                                  // 83
_.extend(LivedataTest.ClientStream.prototype, {                                                                   // 84
                                                                                                                  // 85
  // Register for callbacks.                                                                                      // 86
  on: function (name, callback) {                                                                                 // 87
    var self = this;                                                                                              // 88
                                                                                                                  // 89
    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')                                          // 90
      throw new Error("unknown event type: " + name);                                                             // 91
                                                                                                                  // 92
    if (!self.eventCallbacks[name])                                                                               // 93
      self.eventCallbacks[name] = [];                                                                             // 94
    self.eventCallbacks[name].push(callback);                                                                     // 95
  },                                                                                                              // 96
                                                                                                                  // 97
                                                                                                                  // 98
  _initCommon: function (options) {                                                                               // 99
    var self = this;                                                                                              // 100
    options = options || {};                                                                                      // 101
                                                                                                                  // 102
    //// Constants                                                                                                // 103
                                                                                                                  // 104
    // how long to wait until we declare the connection attempt                                                   // 105
    // failed.                                                                                                    // 106
    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;                                                     // 107
                                                                                                                  // 108
    self.eventCallbacks = {}; // name -> [callback]                                                               // 109
                                                                                                                  // 110
    self._forcedToDisconnect = false;                                                                             // 111
                                                                                                                  // 112
    //// Reactive status                                                                                          // 113
    self.currentStatus = {                                                                                        // 114
      status: "connecting",                                                                                       // 115
      connected: false,                                                                                           // 116
      retryCount: 0                                                                                               // 117
    };                                                                                                            // 118
                                                                                                                  // 119
                                                                                                                  // 120
    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;                              // 121
    self.statusChanged = function () {                                                                            // 122
      if (self.statusListeners)                                                                                   // 123
        self.statusListeners.changed();                                                                           // 124
    };                                                                                                            // 125
                                                                                                                  // 126
    //// Retry logic                                                                                              // 127
    self._retry = new Retry;                                                                                      // 128
    self.connectionTimer = null;                                                                                  // 129
                                                                                                                  // 130
  },                                                                                                              // 131
                                                                                                                  // 132
  // Trigger a reconnect.                                                                                         // 133
  reconnect: function (options) {                                                                                 // 134
    var self = this;                                                                                              // 135
    options = options || {};                                                                                      // 136
                                                                                                                  // 137
    if (options.url) {                                                                                            // 138
      self._changeUrl(options.url);                                                                               // 139
    }                                                                                                             // 140
                                                                                                                  // 141
    if (options._sockjsOptions) {                                                                                 // 142
      self.options._sockjsOptions = options._sockjsOptions;                                                       // 143
    }                                                                                                             // 144
                                                                                                                  // 145
    if (self.currentStatus.connected) {                                                                           // 146
      if (options._force || options.url) {                                                                        // 147
        // force reconnect.                                                                                       // 148
        self._lostConnection(new DDP.ForcedReconnectError);                                                       // 149
      } // else, noop.                                                                                            // 150
      return;                                                                                                     // 151
    }                                                                                                             // 152
                                                                                                                  // 153
    // if we're mid-connection, stop it.                                                                          // 154
    if (self.currentStatus.status === "connecting") {                                                             // 155
      // Pretend it's a clean close.                                                                              // 156
      self._lostConnection();                                                                                     // 157
    }                                                                                                             // 158
                                                                                                                  // 159
    self._retry.clear();                                                                                          // 160
    self.currentStatus.retryCount -= 1; // don't count manual retries                                             // 161
    self._retryNow();                                                                                             // 162
  },                                                                                                              // 163
                                                                                                                  // 164
  disconnect: function (options) {                                                                                // 165
    var self = this;                                                                                              // 166
    options = options || {};                                                                                      // 167
                                                                                                                  // 168
    // Failed is permanent. If we're failed, don't let people go back                                             // 169
    // online by calling 'disconnect' then 'reconnect'.                                                           // 170
    if (self._forcedToDisconnect)                                                                                 // 171
      return;                                                                                                     // 172
                                                                                                                  // 173
    // If _permanent is set, permanently disconnect a stream. Once a stream                                       // 174
    // is forced to disconnect, it can never reconnect. This is for                                               // 175
    // error cases such as ddp version mismatch, where trying again                                               // 176
    // won't fix the problem.                                                                                     // 177
    if (options._permanent) {                                                                                     // 178
      self._forcedToDisconnect = true;                                                                            // 179
    }                                                                                                             // 180
                                                                                                                  // 181
    self._cleanup();                                                                                              // 182
    self._retry.clear();                                                                                          // 183
                                                                                                                  // 184
    self.currentStatus = {                                                                                        // 185
      status: (options._permanent ? "failed" : "offline"),                                                        // 186
      connected: false,                                                                                           // 187
      retryCount: 0                                                                                               // 188
    };                                                                                                            // 189
                                                                                                                  // 190
    if (options._permanent && options._error)                                                                     // 191
      self.currentStatus.reason = options._error;                                                                 // 192
                                                                                                                  // 193
    self.statusChanged();                                                                                         // 194
  },                                                                                                              // 195
                                                                                                                  // 196
  // maybeError is set unless it's a clean protocol-level close.                                                  // 197
  _lostConnection: function (maybeError) {                                                                        // 198
    var self = this;                                                                                              // 199
                                                                                                                  // 200
    self._cleanup(maybeError);                                                                                    // 201
    self._retryLater(maybeError); // sets status. no need to do it here.                                          // 202
  },                                                                                                              // 203
                                                                                                                  // 204
  // fired when we detect that we've gone online. try to reconnect                                                // 205
  // immediately.                                                                                                 // 206
  _online: function () {                                                                                          // 207
    // if we've requested to be offline by disconnecting, don't reconnect.                                        // 208
    if (this.currentStatus.status != "offline")                                                                   // 209
      this.reconnect();                                                                                           // 210
  },                                                                                                              // 211
                                                                                                                  // 212
  _retryLater: function (maybeError) {                                                                            // 213
    var self = this;                                                                                              // 214
                                                                                                                  // 215
    var timeout = 0;                                                                                              // 216
    if (self.options.retry ||                                                                                     // 217
        (maybeError && maybeError.errorType === "DDP.ForcedReconnectError")) {                                    // 218
      timeout = self._retry.retryLater(                                                                           // 219
        self.currentStatus.retryCount,                                                                            // 220
        _.bind(self._retryNow, self)                                                                              // 221
      );                                                                                                          // 222
      self.currentStatus.status = "waiting";                                                                      // 223
      self.currentStatus.retryTime = (new Date()).getTime() + timeout;                                            // 224
    } else {                                                                                                      // 225
      self.currentStatus.status = "failed";                                                                       // 226
      delete self.currentStatus.retryTime;                                                                        // 227
    }                                                                                                             // 228
                                                                                                                  // 229
    self.currentStatus.connected = false;                                                                         // 230
    self.statusChanged();                                                                                         // 231
  },                                                                                                              // 232
                                                                                                                  // 233
  _retryNow: function () {                                                                                        // 234
    var self = this;                                                                                              // 235
                                                                                                                  // 236
    if (self._forcedToDisconnect)                                                                                 // 237
      return;                                                                                                     // 238
                                                                                                                  // 239
    self.currentStatus.retryCount += 1;                                                                           // 240
    self.currentStatus.status = "connecting";                                                                     // 241
    self.currentStatus.connected = false;                                                                         // 242
    delete self.currentStatus.retryTime;                                                                          // 243
    self.statusChanged();                                                                                         // 244
                                                                                                                  // 245
    self._launchConnection();                                                                                     // 246
  },                                                                                                              // 247
                                                                                                                  // 248
                                                                                                                  // 249
  // Get current status. Reactive.                                                                                // 250
  status: function () {                                                                                           // 251
    var self = this;                                                                                              // 252
    if (self.statusListeners)                                                                                     // 253
      self.statusListeners.depend();                                                                              // 254
    return self.currentStatus;                                                                                    // 255
  }                                                                                                               // 256
});                                                                                                               // 257
                                                                                                                  // 258
DDP.ConnectionError = Meteor.makeErrorType(                                                                       // 259
  "DDP.ConnectionError", function (message) {                                                                     // 260
    var self = this;                                                                                              // 261
    self.message = message;                                                                                       // 262
});                                                                                                               // 263
                                                                                                                  // 264
DDP.ForcedReconnectError = Meteor.makeErrorType(                                                                  // 265
  "DDP.ForcedReconnectError", function () {});                                                                    // 266
                                                                                                                  // 267
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/ddp/heartbeat.js                                                                                      //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// Heartbeat options:                                                                                             // 1
//   heartbeatInterval: interval to send pings, in milliseconds.                                                  // 2
//   heartbeatTimeout: timeout to close the connection if a reply isn't                                           // 3
//     received, in milliseconds.                                                                                 // 4
//   sendPing: function to call to send a ping on the connection.                                                 // 5
//   onTimeout: function to call to close the connection.                                                         // 6
                                                                                                                  // 7
Heartbeat = function (options) {                                                                                  // 8
  var self = this;                                                                                                // 9
                                                                                                                  // 10
  self.heartbeatInterval = options.heartbeatInterval;                                                             // 11
  self.heartbeatTimeout = options.heartbeatTimeout;                                                               // 12
  self._sendPing = options.sendPing;                                                                              // 13
  self._onTimeout = options.onTimeout;                                                                            // 14
                                                                                                                  // 15
  self._heartbeatIntervalHandle = null;                                                                           // 16
  self._heartbeatTimeoutHandle = null;                                                                            // 17
};                                                                                                                // 18
                                                                                                                  // 19
_.extend(Heartbeat.prototype, {                                                                                   // 20
  stop: function () {                                                                                             // 21
    var self = this;                                                                                              // 22
    self._clearHeartbeatIntervalTimer();                                                                          // 23
    self._clearHeartbeatTimeoutTimer();                                                                           // 24
  },                                                                                                              // 25
                                                                                                                  // 26
  start: function () {                                                                                            // 27
    var self = this;                                                                                              // 28
    self.stop();                                                                                                  // 29
    self._startHeartbeatIntervalTimer();                                                                          // 30
  },                                                                                                              // 31
                                                                                                                  // 32
  _startHeartbeatIntervalTimer: function () {                                                                     // 33
    var self = this;                                                                                              // 34
    self._heartbeatIntervalHandle = Meteor.setTimeout(                                                            // 35
      _.bind(self._heartbeatIntervalFired, self),                                                                 // 36
      self.heartbeatInterval                                                                                      // 37
    );                                                                                                            // 38
  },                                                                                                              // 39
                                                                                                                  // 40
  _startHeartbeatTimeoutTimer: function () {                                                                      // 41
    var self = this;                                                                                              // 42
    self._heartbeatTimeoutHandle = Meteor.setTimeout(                                                             // 43
      _.bind(self._heartbeatTimeoutFired, self),                                                                  // 44
      self.heartbeatTimeout                                                                                       // 45
    );                                                                                                            // 46
  },                                                                                                              // 47
                                                                                                                  // 48
  _clearHeartbeatIntervalTimer: function () {                                                                     // 49
    var self = this;                                                                                              // 50
    if (self._heartbeatIntervalHandle) {                                                                          // 51
      Meteor.clearTimeout(self._heartbeatIntervalHandle);                                                         // 52
      self._heartbeatIntervalHandle = null;                                                                       // 53
    }                                                                                                             // 54
  },                                                                                                              // 55
                                                                                                                  // 56
  _clearHeartbeatTimeoutTimer: function () {                                                                      // 57
    var self = this;                                                                                              // 58
    if (self._heartbeatTimeoutHandle) {                                                                           // 59
      Meteor.clearTimeout(self._heartbeatTimeoutHandle);                                                          // 60
      self._heartbeatTimeoutHandle = null;                                                                        // 61
    }                                                                                                             // 62
  },                                                                                                              // 63
                                                                                                                  // 64
  // The heartbeat interval timer is fired when we should send a ping.                                            // 65
  _heartbeatIntervalFired: function () {                                                                          // 66
    var self = this;                                                                                              // 67
    self._heartbeatIntervalHandle = null;                                                                         // 68
    self._sendPing();                                                                                             // 69
    // Wait for a pong.                                                                                           // 70
    self._startHeartbeatTimeoutTimer();                                                                           // 71
  },                                                                                                              // 72
                                                                                                                  // 73
  // The heartbeat timeout timer is fired when we sent a ping, but we                                             // 74
  // timed out waiting for the pong.                                                                              // 75
  _heartbeatTimeoutFired: function () {                                                                           // 76
    var self = this;                                                                                              // 77
    self._heartbeatTimeoutHandle = null;                                                                          // 78
    self._onTimeout();                                                                                            // 79
  },                                                                                                              // 80
                                                                                                                  // 81
  pingReceived: function () {                                                                                     // 82
    var self = this;                                                                                              // 83
    // We know the connection is alive if we receive a ping, so we                                                // 84
    // don't need to send a ping ourselves.  Reset the interval timer.                                            // 85
    if (self._heartbeatIntervalHandle) {                                                                          // 86
      self._clearHeartbeatIntervalTimer();                                                                        // 87
      self._startHeartbeatIntervalTimer();                                                                        // 88
    }                                                                                                             // 89
  },                                                                                                              // 90
                                                                                                                  // 91
  pongReceived: function () {                                                                                     // 92
    var self = this;                                                                                              // 93
                                                                                                                  // 94
    // Receiving a pong means we won't timeout, so clear the timeout                                              // 95
    // timer and start the interval again.                                                                        // 96
    if (self._heartbeatTimeoutHandle) {                                                                           // 97
      self._clearHeartbeatTimeoutTimer();                                                                         // 98
      self._startHeartbeatIntervalTimer();                                                                        // 99
    }                                                                                                             // 100
  }                                                                                                               // 101
});                                                                                                               // 102
                                                                                                                  // 103
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/ddp/livedata_common.js                                                                                //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// All the supported versions (for both the client and server)                                                    // 1
// These must be in order of preference; most favored-first                                                       // 2
SUPPORTED_DDP_VERSIONS = [ '1', 'pre2', 'pre1' ];                                                                 // 3
                                                                                                                  // 4
LivedataTest.SUPPORTED_DDP_VERSIONS = SUPPORTED_DDP_VERSIONS;                                                     // 5
                                                                                                                  // 6
// Instance name is this because it is usually referred to as this inside a                                       // 7
// method definition                                                                                              // 8
/**                                                                                                               // 9
 * @summary The state for a single invocation of a method, referenced by this                                     // 10
 * inside a method definition.                                                                                    // 11
 * @param {Object} options                                                                                        // 12
 * @instanceName this                                                                                             // 13
 */                                                                                                               // 14
MethodInvocation = function (options) {                                                                           // 15
  var self = this;                                                                                                // 16
                                                                                                                  // 17
  // true if we're running not the actual method, but a stub (that is,                                            // 18
  // if we're on a client (which may be a browser, or in the future a                                             // 19
  // server connecting to another server) and presently running a                                                 // 20
  // simulation of a server-side method for latency compensation                                                  // 21
  // purposes). not currently true except in a client such as a browser,                                          // 22
  // since there's usually no point in running stubs unless you have a                                            // 23
  // zero-latency connection to the user.                                                                         // 24
                                                                                                                  // 25
  /**                                                                                                             // 26
   * @summary Access inside a method invocation.  Boolean value, true if this invocation is a stub.               // 27
   * @locus Anywhere                                                                                              // 28
   * @name  isSimulation                                                                                          // 29
   * @memberOf MethodInvocation                                                                                   // 30
   * @instance                                                                                                    // 31
   * @type {Boolean}                                                                                              // 32
   */                                                                                                             // 33
  this.isSimulation = options.isSimulation;                                                                       // 34
                                                                                                                  // 35
  // call this function to allow other method invocations (from the                                               // 36
  // same client) to continue running without waiting for this one to                                             // 37
  // complete.                                                                                                    // 38
  this._unblock = options.unblock || function () {};                                                              // 39
  this._calledUnblock = false;                                                                                    // 40
                                                                                                                  // 41
  // current user id                                                                                              // 42
                                                                                                                  // 43
  /**                                                                                                             // 44
   * @summary The id of the user that made this method call, or `null` if no user was logged in.                  // 45
   * @locus Anywhere                                                                                              // 46
   * @name  userId                                                                                                // 47
   * @memberOf MethodInvocation                                                                                   // 48
   * @instance                                                                                                    // 49
   */                                                                                                             // 50
  this.userId = options.userId;                                                                                   // 51
                                                                                                                  // 52
  // sets current user id in all appropriate server contexts and                                                  // 53
  // reruns subscriptions                                                                                         // 54
  this._setUserId = options.setUserId || function () {};                                                          // 55
                                                                                                                  // 56
  // On the server, the connection this method call came in on.                                                   // 57
                                                                                                                  // 58
  /**                                                                                                             // 59
   * @summary Access inside a method invocation. The [connection](#meteor_onconnection) that this method was received on. `null` if the method is not associated with a connection, eg. a server initiated method call.
   * @locus Server                                                                                                // 61
   * @name  connection                                                                                            // 62
   * @memberOf MethodInvocation                                                                                   // 63
   * @instance                                                                                                    // 64
   */                                                                                                             // 65
  this.connection = options.connection;                                                                           // 66
                                                                                                                  // 67
  // The seed for randomStream value generation                                                                   // 68
  this.randomSeed = options.randomSeed;                                                                           // 69
                                                                                                                  // 70
  // This is set by RandomStream.get; and holds the random stream state                                           // 71
  this.randomStream = null;                                                                                       // 72
};                                                                                                                // 73
                                                                                                                  // 74
_.extend(MethodInvocation.prototype, {                                                                            // 75
  /**                                                                                                             // 76
   * @summary Call inside a method invocation.  Allow subsequent method from this client to begin running in a new fiber.
   * @locus Server                                                                                                // 78
   * @memberOf MethodInvocation                                                                                   // 79
   * @instance                                                                                                    // 80
   */                                                                                                             // 81
  unblock: function () {                                                                                          // 82
    var self = this;                                                                                              // 83
    self._calledUnblock = true;                                                                                   // 84
    self._unblock();                                                                                              // 85
  },                                                                                                              // 86
                                                                                                                  // 87
  /**                                                                                                             // 88
   * @summary Set the logged in user.                                                                             // 89
   * @locus Server                                                                                                // 90
   * @memberOf MethodInvocation                                                                                   // 91
   * @instance                                                                                                    // 92
   * @param {String | null} userId The value that should be returned by `userId` on this connection.              // 93
   */                                                                                                             // 94
  setUserId: function(userId) {                                                                                   // 95
    var self = this;                                                                                              // 96
    if (self._calledUnblock)                                                                                      // 97
      throw new Error("Can't call setUserId in a method after calling unblock");                                  // 98
    self.userId = userId;                                                                                         // 99
    self._setUserId(userId);                                                                                      // 100
  }                                                                                                               // 101
});                                                                                                               // 102
                                                                                                                  // 103
parseDDP = function (stringMessage) {                                                                             // 104
  try {                                                                                                           // 105
    var msg = JSON.parse(stringMessage);                                                                          // 106
  } catch (e) {                                                                                                   // 107
    Meteor._debug("Discarding message with invalid JSON", stringMessage);                                         // 108
    return null;                                                                                                  // 109
  }                                                                                                               // 110
  // DDP messages must be objects.                                                                                // 111
  if (msg === null || typeof msg !== 'object') {                                                                  // 112
    Meteor._debug("Discarding non-object DDP message", stringMessage);                                            // 113
    return null;                                                                                                  // 114
  }                                                                                                               // 115
                                                                                                                  // 116
  // massage msg to get it into "abstract ddp" rather than "wire ddp" format.                                     // 117
                                                                                                                  // 118
  // switch between "cleared" rep of unsetting fields and "undefined"                                             // 119
  // rep of same                                                                                                  // 120
  if (_.has(msg, 'cleared')) {                                                                                    // 121
    if (!_.has(msg, 'fields'))                                                                                    // 122
      msg.fields = {};                                                                                            // 123
    _.each(msg.cleared, function (clearKey) {                                                                     // 124
      msg.fields[clearKey] = undefined;                                                                           // 125
    });                                                                                                           // 126
    delete msg.cleared;                                                                                           // 127
  }                                                                                                               // 128
                                                                                                                  // 129
  _.each(['fields', 'params', 'result'], function (field) {                                                       // 130
    if (_.has(msg, field))                                                                                        // 131
      msg[field] = EJSON._adjustTypesFromJSONValue(msg[field]);                                                   // 132
  });                                                                                                             // 133
                                                                                                                  // 134
  return msg;                                                                                                     // 135
};                                                                                                                // 136
                                                                                                                  // 137
stringifyDDP = function (msg) {                                                                                   // 138
  var copy = EJSON.clone(msg);                                                                                    // 139
  // swizzle 'changed' messages from 'fields undefined' rep to 'fields                                            // 140
  // and cleared' rep                                                                                             // 141
  if (_.has(msg, 'fields')) {                                                                                     // 142
    var cleared = [];                                                                                             // 143
    _.each(msg.fields, function (value, key) {                                                                    // 144
      if (value === undefined) {                                                                                  // 145
        cleared.push(key);                                                                                        // 146
        delete copy.fields[key];                                                                                  // 147
      }                                                                                                           // 148
    });                                                                                                           // 149
    if (!_.isEmpty(cleared))                                                                                      // 150
      copy.cleared = cleared;                                                                                     // 151
    if (_.isEmpty(copy.fields))                                                                                   // 152
      delete copy.fields;                                                                                         // 153
  }                                                                                                               // 154
  // adjust types to basic                                                                                        // 155
  _.each(['fields', 'params', 'result'], function (field) {                                                       // 156
    if (_.has(copy, field))                                                                                       // 157
      copy[field] = EJSON._adjustTypesToJSONValue(copy[field]);                                                   // 158
  });                                                                                                             // 159
  if (msg.id && typeof msg.id !== 'string') {                                                                     // 160
    throw new Error("Message id is not a string");                                                                // 161
  }                                                                                                               // 162
  return JSON.stringify(copy);                                                                                    // 163
};                                                                                                                // 164
                                                                                                                  // 165
// This is private but it's used in a few places. accounts-base uses                                              // 166
// it to get the current user. accounts-password uses it to stash SRP                                             // 167
// state in the DDP session. Meteor.setTimeout and friends clear                                                  // 168
// it. We can probably find a better way to factor this.                                                          // 169
DDP._CurrentInvocation = new Meteor.EnvironmentVariable;                                                          // 170
                                                                                                                  // 171
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/ddp/random_stream.js                                                                                  //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// RandomStream allows for generation of pseudo-random values, from a seed.                                       // 1
//                                                                                                                // 2
// We use this for consistent 'random' numbers across the client and server.                                      // 3
// We want to generate probably-unique IDs on the client, and we ideally want                                     // 4
// the server to generate the same IDs when it executes the method.                                               // 5
//                                                                                                                // 6
// For generated values to be the same, we must seed ourselves the same way,                                      // 7
// and we must keep track of the current state of our pseudo-random generators.                                   // 8
// We call this state the scope. By default, we use the current DDP method                                        // 9
// invocation as our scope.  DDP now allows the client to specify a randomSeed.                                   // 10
// If a randomSeed is provided it will be used to seed our random sequences.                                      // 11
// In this way, client and server method calls will generate the same values.                                     // 12
//                                                                                                                // 13
// We expose multiple named streams; each stream is independent                                                   // 14
// and is seeded differently (but predictably from the name).                                                     // 15
// By using multiple streams, we support reordering of requests,                                                  // 16
// as long as they occur on different streams.                                                                    // 17
//                                                                                                                // 18
// @param options {Optional Object}                                                                               // 19
//   seed: Array or value - Seed value(s) for the generator.                                                      // 20
//                          If an array, will be used as-is                                                       // 21
//                          If a value, will be converted to a single-value array                                 // 22
//                          If omitted, a random array will be used as the seed.                                  // 23
RandomStream = function (options) {                                                                               // 24
  var self = this;                                                                                                // 25
                                                                                                                  // 26
  this.seed = [].concat(options.seed || randomToken());                                                           // 27
                                                                                                                  // 28
  this.sequences = {};                                                                                            // 29
};                                                                                                                // 30
                                                                                                                  // 31
// Returns a random string of sufficient length for a random seed.                                                // 32
// This is a placeholder function; a similar function is planned                                                  // 33
// for Random itself; when that is added we should remove this function,                                          // 34
// and call Random's randomToken instead.                                                                         // 35
function randomToken() {                                                                                          // 36
  return Random.hexString(20);                                                                                    // 37
};                                                                                                                // 38
                                                                                                                  // 39
// Returns the random stream with the specified name, in the specified scope.                                     // 40
// If scope is null (or otherwise falsey) then we will use Random, which will                                     // 41
// give us as random numbers as possible, but won't produce the same                                              // 42
// values across client and server.                                                                               // 43
// However, scope will normally be the current DDP method invocation, so                                          // 44
// we'll use the stream with the specified name, and we should get consistent                                     // 45
// values on the client and server sides of a method call.                                                        // 46
RandomStream.get = function (scope, name) {                                                                       // 47
  if (!name) {                                                                                                    // 48
    name = "default";                                                                                             // 49
  }                                                                                                               // 50
  if (!scope) {                                                                                                   // 51
    // There was no scope passed in;                                                                              // 52
    // the sequence won't actually be reproducible.                                                               // 53
    return Random;                                                                                                // 54
  }                                                                                                               // 55
  var randomStream = scope.randomStream;                                                                          // 56
  if (!randomStream) {                                                                                            // 57
    scope.randomStream = randomStream = new RandomStream({                                                        // 58
      seed: scope.randomSeed                                                                                      // 59
    });                                                                                                           // 60
  }                                                                                                               // 61
  return randomStream._sequence(name);                                                                            // 62
};                                                                                                                // 63
                                                                                                                  // 64
// Returns the named sequence of pseudo-random values.                                                            // 65
// The scope will be DDP._CurrentInvocation.get(), so the stream will produce                                     // 66
// consistent values for method calls on the client and server.                                                   // 67
DDP.randomStream = function (name) {                                                                              // 68
  var scope = DDP._CurrentInvocation.get();                                                                       // 69
  return RandomStream.get(scope, name);                                                                           // 70
};                                                                                                                // 71
                                                                                                                  // 72
// Creates a randomSeed for passing to a method call.                                                             // 73
// Note that we take enclosing as an argument,                                                                    // 74
// though we expect it to be DDP._CurrentInvocation.get()                                                         // 75
// However, we often evaluate makeRpcSeed lazily, and thus the relevant                                           // 76
// invocation may not be the one currently in scope.                                                              // 77
// If enclosing is null, we'll use Random and values won't be repeatable.                                         // 78
makeRpcSeed = function (enclosing, methodName) {                                                                  // 79
  var stream = RandomStream.get(enclosing, '/rpc/' + methodName);                                                 // 80
  return stream.hexString(20);                                                                                    // 81
};                                                                                                                // 82
                                                                                                                  // 83
_.extend(RandomStream.prototype, {                                                                                // 84
  // Get a random sequence with the specified name, creating it if does not exist.                                // 85
  // New sequences are seeded with the seed concatenated with the name.                                           // 86
  // By passing a seed into Random.create, we use the Alea generator.                                             // 87
  _sequence: function (name) {                                                                                    // 88
    var self = this;                                                                                              // 89
                                                                                                                  // 90
    var sequence = self.sequences[name] || null;                                                                  // 91
    if (sequence === null) {                                                                                      // 92
      var sequenceSeed = self.seed.concat(name);                                                                  // 93
      for (var i = 0; i < sequenceSeed.length; i++) {                                                             // 94
        if (_.isFunction(sequenceSeed[i])) {                                                                      // 95
          sequenceSeed[i] = sequenceSeed[i]();                                                                    // 96
        }                                                                                                         // 97
      }                                                                                                           // 98
      self.sequences[name] = sequence = Random.createWithSeeds.apply(null, sequenceSeed);                         // 99
    }                                                                                                             // 100
    return sequence;                                                                                              // 101
  }                                                                                                               // 102
});                                                                                                               // 103
                                                                                                                  // 104
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/ddp/livedata_connection.js                                                                            //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
if (Meteor.isServer) {                                                                                            // 1
  var path = Npm.require('path');                                                                                 // 2
  var Fiber = Npm.require('fibers');                                                                              // 3
  var Future = Npm.require(path.join('fibers', 'future'));                                                        // 4
}                                                                                                                 // 5
                                                                                                                  // 6
// @param url {String|Object} URL to Meteor app,                                                                  // 7
//   or an object as a test hook (see code)                                                                       // 8
// Options:                                                                                                       // 9
//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?                                  // 10
//   headers: extra headers to send on the websockets connection, for                                             // 11
//     server-to-server DDP only                                                                                  // 12
//   _sockjsOptions: Specifies options to pass through to the sockjs client                                       // 13
//   onDDPNegotiationVersionFailure: callback when version negotiation fails.                                     // 14
//                                                                                                                // 15
// XXX There should be a way to destroy a DDP connection, causing all                                             // 16
// outstanding method calls to fail.                                                                              // 17
//                                                                                                                // 18
// XXX Our current way of handling failure and reconnection is great                                              // 19
// for an app (where we want to tolerate being disconnected as an                                                 // 20
// expect state, and keep trying forever to reconnect) but cumbersome                                             // 21
// for something like a command line tool that wants to make a                                                    // 22
// connection, call a method, and print an error if connection                                                    // 23
// fails. We should have better usability in the latter case (while                                               // 24
// still transparently reconnecting if it's just a transient failure                                              // 25
// or the server migrating us).                                                                                   // 26
var Connection = function (url, options) {                                                                        // 27
  var self = this;                                                                                                // 28
  options = _.extend({                                                                                            // 29
    onConnected: function () {},                                                                                  // 30
    onDDPVersionNegotiationFailure: function (description) {                                                      // 31
      Meteor._debug(description);                                                                                 // 32
    },                                                                                                            // 33
    heartbeatInterval: 35000,                                                                                     // 34
    heartbeatTimeout: 15000,                                                                                      // 35
    // These options are only for testing.                                                                        // 36
    reloadWithOutstanding: false,                                                                                 // 37
    supportedDDPVersions: SUPPORTED_DDP_VERSIONS,                                                                 // 38
    retry: true,                                                                                                  // 39
    respondToPings: true                                                                                          // 40
  }, options);                                                                                                    // 41
                                                                                                                  // 42
  // If set, called when we reconnect, queuing method calls _before_ the                                          // 43
  // existing outstanding ones. This is the only data member that is part of the                                  // 44
  // public API!                                                                                                  // 45
  self.onReconnect = null;                                                                                        // 46
                                                                                                                  // 47
  // as a test hook, allow passing a stream instead of a url.                                                     // 48
  if (typeof url === "object") {                                                                                  // 49
    self._stream = url;                                                                                           // 50
  } else {                                                                                                        // 51
    self._stream = new LivedataTest.ClientStream(url, {                                                           // 52
      retry: options.retry,                                                                                       // 53
      headers: options.headers,                                                                                   // 54
      _sockjsOptions: options._sockjsOptions,                                                                     // 55
      // Used to keep some tests quiet, or for other cases in which                                               // 56
      // the right thing to do with connection errors is to silently                                              // 57
      // fail (e.g. sending package usage stats). At some point we                                                // 58
      // should have a real API for handling client-stream-level                                                  // 59
      // errors.                                                                                                  // 60
      _dontPrintErrors: options._dontPrintErrors,                                                                 // 61
      connectTimeoutMs: options.connectTimeoutMs                                                                  // 62
    });                                                                                                           // 63
  }                                                                                                               // 64
                                                                                                                  // 65
  self._lastSessionId = null;                                                                                     // 66
  self._versionSuggestion = null;  // The last proposed DDP version.                                              // 67
  self._version = null;   // The DDP version agreed on by client and server.                                      // 68
  self._stores = {}; // name -> object with methods                                                               // 69
  self._methodHandlers = {}; // name -> func                                                                      // 70
  self._nextMethodId = 1;                                                                                         // 71
  self._supportedDDPVersions = options.supportedDDPVersions;                                                      // 72
                                                                                                                  // 73
  self._heartbeatInterval = options.heartbeatInterval;                                                            // 74
  self._heartbeatTimeout = options.heartbeatTimeout;                                                              // 75
                                                                                                                  // 76
  // Tracks methods which the user has tried to call but which have not yet                                       // 77
  // called their user callback (ie, they are waiting on their result or for all                                  // 78
  // of their writes to be written to the local cache). Map from method ID to                                     // 79
  // MethodInvoker object.                                                                                        // 80
  self._methodInvokers = {};                                                                                      // 81
                                                                                                                  // 82
  // Tracks methods which the user has called but whose result messages have not                                  // 83
  // arrived yet.                                                                                                 // 84
  //                                                                                                              // 85
  // _outstandingMethodBlocks is an array of blocks of methods. Each block                                        // 86
  // represents a set of methods that can run at the same time. The first block                                   // 87
  // represents the methods which are currently in flight; subsequent blocks                                      // 88
  // must wait for previous blocks to be fully finished before they can be sent                                   // 89
  // to the server.                                                                                               // 90
  //                                                                                                              // 91
  // Each block is an object with the following fields:                                                           // 92
  // - methods: a list of MethodInvoker objects                                                                   // 93
  // - wait: a boolean; if true, this block had a single method invoked with                                      // 94
  //         the "wait" option                                                                                    // 95
  //                                                                                                              // 96
  // There will never be adjacent blocks with wait=false, because the only thing                                  // 97
  // that makes methods need to be serialized is a wait method.                                                   // 98
  //                                                                                                              // 99
  // Methods are removed from the first block when their "result" is                                              // 100
  // received. The entire first block is only removed when all of the in-flight                                   // 101
  // methods have received their results (so the "methods" list is empty) *AND*                                   // 102
  // all of the data written by those methods are visible in the local cache. So                                  // 103
  // it is possible for the first block's methods list to be empty, if we are                                     // 104
  // still waiting for some objects to quiesce.                                                                   // 105
  //                                                                                                              // 106
  // Example:                                                                                                     // 107
  //  _outstandingMethodBlocks = [                                                                                // 108
  //    {wait: false, methods: []},                                                                               // 109
  //    {wait: true, methods: [<MethodInvoker for 'login'>]},                                                     // 110
  //    {wait: false, methods: [<MethodInvoker for 'foo'>,                                                        // 111
  //                            <MethodInvoker for 'bar'>]}]                                                      // 112
  // This means that there were some methods which were sent to the server and                                    // 113
  // which have returned their results, but some of the data written by                                           // 114
  // the methods may not be visible in the local cache. Once all that data is                                     // 115
  // visible, we will send a 'login' method. Once the login method has returned                                   // 116
  // and all the data is visible (including re-running subs if userId changes),                                   // 117
  // we will send the 'foo' and 'bar' methods in parallel.                                                        // 118
  self._outstandingMethodBlocks = [];                                                                             // 119
                                                                                                                  // 120
  // method ID -> array of objects with keys 'collection' and 'id', listing                                       // 121
  // documents written by a given method's stub. keys are associated with                                         // 122
  // methods whose stub wrote at least one document, and whose data-done message                                  // 123
  // has not yet been received.                                                                                   // 124
  self._documentsWrittenByStub = {};                                                                              // 125
  // collection -> IdMap of "server document" object. A "server document" has:                                    // 126
  // - "document": the version of the document according the                                                      // 127
  //   server (ie, the snapshot before a stub wrote it, amended by any changes                                    // 128
  //   received from the server)                                                                                  // 129
  //   It is undefined if we think the document does not exist                                                    // 130
  // - "writtenByStubs": a set of method IDs whose stubs wrote to the document                                    // 131
  //   whose "data done" messages have not yet been processed                                                     // 132
  self._serverDocuments = {};                                                                                     // 133
                                                                                                                  // 134
  // Array of callbacks to be called after the next update of the local                                           // 135
  // cache. Used for:                                                                                             // 136
  //  - Calling methodInvoker.dataVisible and sub ready callbacks after                                           // 137
  //    the relevant data is flushed.                                                                             // 138
  //  - Invoking the callbacks of "half-finished" methods after reconnect                                         // 139
  //    quiescence. Specifically, methods whose result was received over the old                                  // 140
  //    connection (so we don't re-send it) but whose data had not been made                                      // 141
  //    visible.                                                                                                  // 142
  self._afterUpdateCallbacks = [];                                                                                // 143
                                                                                                                  // 144
  // In two contexts, we buffer all incoming data messages and then process them                                  // 145
  // all at once in a single update:                                                                              // 146
  //   - During reconnect, we buffer all data messages until all subs that had                                    // 147
  //     been ready before reconnect are ready again, and all methods that are                                    // 148
  //     active have returned their "data done message"; then                                                     // 149
  //   - During the execution of a "wait" method, we buffer all data messages                                     // 150
  //     until the wait method gets its "data done" message. (If the wait method                                  // 151
  //     occurs during reconnect, it doesn't get any special handling.)                                           // 152
  // all data messages are processed in one update.                                                               // 153
  //                                                                                                              // 154
  // The following fields are used for this "quiescence" process.                                                 // 155
                                                                                                                  // 156
  // This buffers the messages that aren't being processed yet.                                                   // 157
  self._messagesBufferedUntilQuiescence = [];                                                                     // 158
  // Map from method ID -> true. Methods are removed from this when their                                         // 159
  // "data done" message is received, and we will not quiesce until it is                                         // 160
  // empty.                                                                                                       // 161
  self._methodsBlockingQuiescence = {};                                                                           // 162
  // map from sub ID -> true for subs that were ready (ie, called the sub                                         // 163
  // ready callback) before reconnect but haven't become ready again yet                                          // 164
  self._subsBeingRevived = {}; // map from sub._id -> true                                                        // 165
  // if true, the next data update should reset all stores. (set during                                           // 166
  // reconnect.)                                                                                                  // 167
  self._resetStores = false;                                                                                      // 168
                                                                                                                  // 169
  // name -> array of updates for (yet to be created) collections                                                 // 170
  self._updatesForUnknownStores = {};                                                                             // 171
  // if we're blocking a migration, the retry func                                                                // 172
  self._retryMigrate = null;                                                                                      // 173
                                                                                                                  // 174
  // metadata for subscriptions.  Map from sub ID to object with keys:                                            // 175
  //   - id                                                                                                       // 176
  //   - name                                                                                                     // 177
  //   - params                                                                                                   // 178
  //   - inactive (if true, will be cleaned up if not reused in re-run)                                           // 179
  //   - ready (has the 'ready' message been received?)                                                           // 180
  //   - readyCallback (an optional callback to call when ready)                                                  // 181
  //   - errorCallback (an optional callback to call if the sub terminates with                                   // 182
  //                    an error, XXX COMPAT WITH 1.0.3.1)                                                        // 183
  //   - stopCallback (an optional callback to call when the sub terminates                                       // 184
  //     for any reason, with an error argument if an error triggered the stop)                                   // 185
  self._subscriptions = {};                                                                                       // 186
                                                                                                                  // 187
  // Reactive userId.                                                                                             // 188
  self._userId = null;                                                                                            // 189
  self._userIdDeps = new Tracker.Dependency;                                                                      // 190
                                                                                                                  // 191
  // Block auto-reload while we're waiting for method responses.                                                  // 192
  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {                                      // 193
    Package.reload.Reload._onMigrate(function (retry) {                                                           // 194
      if (!self._readyToMigrate()) {                                                                              // 195
        if (self._retryMigrate)                                                                                   // 196
          throw new Error("Two migrations in progress?");                                                         // 197
        self._retryMigrate = retry;                                                                               // 198
        return false;                                                                                             // 199
      } else {                                                                                                    // 200
        return [true];                                                                                            // 201
      }                                                                                                           // 202
    });                                                                                                           // 203
  }                                                                                                               // 204
                                                                                                                  // 205
  var onMessage = function (raw_msg) {                                                                            // 206
    try {                                                                                                         // 207
      var msg = parseDDP(raw_msg);                                                                                // 208
    } catch (e) {                                                                                                 // 209
      Meteor._debug("Exception while parsing DDP", e);                                                            // 210
      return;                                                                                                     // 211
    }                                                                                                             // 212
                                                                                                                  // 213
    if (msg === null || !msg.msg) {                                                                               // 214
      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back                                           // 215
      // compat.  Remove this 'if' once the server stops sending welcome                                          // 216
      // messages (stream_server.js).                                                                             // 217
      if (! (msg && msg.server_id))                                                                               // 218
        Meteor._debug("discarding invalid livedata message", msg);                                                // 219
      return;                                                                                                     // 220
    }                                                                                                             // 221
                                                                                                                  // 222
    if (msg.msg === 'connected') {                                                                                // 223
      self._version = self._versionSuggestion;                                                                    // 224
      self._livedata_connected(msg);                                                                              // 225
      options.onConnected();                                                                                      // 226
    }                                                                                                             // 227
    else if (msg.msg == 'failed') {                                                                               // 228
      if (_.contains(self._supportedDDPVersions, msg.version)) {                                                  // 229
        self._versionSuggestion = msg.version;                                                                    // 230
        self._stream.reconnect({_force: true});                                                                   // 231
      } else {                                                                                                    // 232
        var description =                                                                                         // 233
              "DDP version negotiation failed; server requested version " + msg.version;                          // 234
        self._stream.disconnect({_permanent: true, _error: description});                                         // 235
        options.onDDPVersionNegotiationFailure(description);                                                      // 236
      }                                                                                                           // 237
    }                                                                                                             // 238
    else if (msg.msg === 'ping') {                                                                                // 239
      if (options.respondToPings)                                                                                 // 240
        self._send({msg: "pong", id: msg.id});                                                                    // 241
      if (self._heartbeat)                                                                                        // 242
        self._heartbeat.pingReceived();                                                                           // 243
    }                                                                                                             // 244
    else if (msg.msg === 'pong') {                                                                                // 245
      if (self._heartbeat) {                                                                                      // 246
        self._heartbeat.pongReceived();                                                                           // 247
      }                                                                                                           // 248
    }                                                                                                             // 249
    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))                             // 250
      self._livedata_data(msg);                                                                                   // 251
    else if (msg.msg === 'nosub')                                                                                 // 252
      self._livedata_nosub(msg);                                                                                  // 253
    else if (msg.msg === 'result')                                                                                // 254
      self._livedata_result(msg);                                                                                 // 255
    else if (msg.msg === 'error')                                                                                 // 256
      self._livedata_error(msg);                                                                                  // 257
    else                                                                                                          // 258
      Meteor._debug("discarding unknown livedata message type", msg);                                             // 259
  };                                                                                                              // 260
                                                                                                                  // 261
  var onReset = function () {                                                                                     // 262
    // Send a connect message at the beginning of the stream.                                                     // 263
    // NOTE: reset is called even on the first connection, so this is                                             // 264
    // the only place we send this message.                                                                       // 265
    var msg = {msg: 'connect'};                                                                                   // 266
    if (self._lastSessionId)                                                                                      // 267
      msg.session = self._lastSessionId;                                                                          // 268
    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];                                       // 269
    self._versionSuggestion = msg.version;                                                                        // 270
    msg.support = self._supportedDDPVersions;                                                                     // 271
    self._send(msg);                                                                                              // 272
                                                                                                                  // 273
    // Now, to minimize setup latency, go ahead and blast out all of                                              // 274
    // our pending methods ands subscriptions before we've even taken                                             // 275
    // the necessary RTT to know if we successfully reconnected. (1)                                              // 276
    // They're supposed to be idempotent; (2) even if we did                                                      // 277
    // reconnect, we're not sure what messages might have gotten lost                                             // 278
    // (in either direction) since we were disconnected (TCP being                                                // 279
    // sloppy about that.)                                                                                        // 280
                                                                                                                  // 281
    // If the current block of methods all got their results (but didn't all get                                  // 282
    // their data visible), discard the empty block now.                                                          // 283
    if (! _.isEmpty(self._outstandingMethodBlocks) &&                                                             // 284
        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {                                                    // 285
      self._outstandingMethodBlocks.shift();                                                                      // 286
    }                                                                                                             // 287
                                                                                                                  // 288
    // Mark all messages as unsent, they have not yet been sent on this                                           // 289
    // connection.                                                                                                // 290
    _.each(self._methodInvokers, function (m) {                                                                   // 291
      m.sentMessage = false;                                                                                      // 292
    });                                                                                                           // 293
                                                                                                                  // 294
    // If an `onReconnect` handler is set, call it first. Go through                                              // 295
    // some hoops to ensure that methods that are called from within                                              // 296
    // `onReconnect` get executed _before_ ones that were originally                                              // 297
    // outstanding (since `onReconnect` is used to re-establish auth                                              // 298
    // certificates)                                                                                              // 299
    if (self.onReconnect)                                                                                         // 300
      self._callOnReconnectAndSendAppropriateOutstandingMethods();                                                // 301
    else                                                                                                          // 302
      self._sendOutstandingMethods();                                                                             // 303
                                                                                                                  // 304
    // add new subscriptions at the end. this way they take effect after                                          // 305
    // the handlers and we don't see flicker.                                                                     // 306
    _.each(self._subscriptions, function (sub, id) {                                                              // 307
      self._send({                                                                                                // 308
        msg: 'sub',                                                                                               // 309
        id: id,                                                                                                   // 310
        name: sub.name,                                                                                           // 311
        params: sub.params                                                                                        // 312
      });                                                                                                         // 313
    });                                                                                                           // 314
  };                                                                                                              // 315
                                                                                                                  // 316
  var onDisconnect = function () {                                                                                // 317
    if (self._heartbeat) {                                                                                        // 318
      self._heartbeat.stop();                                                                                     // 319
      self._heartbeat = null;                                                                                     // 320
    }                                                                                                             // 321
  };                                                                                                              // 322
                                                                                                                  // 323
  if (Meteor.isServer) {                                                                                          // 324
    self._stream.on('message', Meteor.bindEnvironment(onMessage, Meteor._debug));                                 // 325
    self._stream.on('reset', Meteor.bindEnvironment(onReset, Meteor._debug));                                     // 326
    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, Meteor._debug));                           // 327
  } else {                                                                                                        // 328
    self._stream.on('message', onMessage);                                                                        // 329
    self._stream.on('reset', onReset);                                                                            // 330
    self._stream.on('disconnect', onDisconnect);                                                                  // 331
  }                                                                                                               // 332
};                                                                                                                // 333
                                                                                                                  // 334
// A MethodInvoker manages sending a method to the server and calling the user's                                  // 335
// callbacks. On construction, it registers itself in the connection's                                            // 336
// _methodInvokers map; it removes itself once the method is fully finished and                                   // 337
// the callback is invoked. This occurs when it has both received a result,                                       // 338
// and the data written by it is fully visible.                                                                   // 339
var MethodInvoker = function (options) {                                                                          // 340
  var self = this;                                                                                                // 341
                                                                                                                  // 342
  // Public (within this file) fields.                                                                            // 343
  self.methodId = options.methodId;                                                                               // 344
  self.sentMessage = false;                                                                                       // 345
                                                                                                                  // 346
  self._callback = options.callback;                                                                              // 347
  self._connection = options.connection;                                                                          // 348
  self._message = options.message;                                                                                // 349
  self._onResultReceived = options.onResultReceived || function () {};                                            // 350
  self._wait = options.wait;                                                                                      // 351
  self._methodResult = null;                                                                                      // 352
  self._dataVisible = false;                                                                                      // 353
                                                                                                                  // 354
  // Register with the connection.                                                                                // 355
  self._connection._methodInvokers[self.methodId] = self;                                                         // 356
};                                                                                                                // 357
_.extend(MethodInvoker.prototype, {                                                                               // 358
  // Sends the method message to the server. May be called additional times if                                    // 359
  // we lose the connection and reconnect before receiving a result.                                              // 360
  sendMessage: function () {                                                                                      // 361
    var self = this;                                                                                              // 362
    // This function is called before sending a method (including resending on                                    // 363
    // reconnect). We should only (re)send methods where we don't already have a                                  // 364
    // result!                                                                                                    // 365
    if (self.gotResult())                                                                                         // 366
      throw new Error("sendingMethod is called on method with result");                                           // 367
                                                                                                                  // 368
    // If we're re-sending it, it doesn't matter if data was written the first                                    // 369
    // time.                                                                                                      // 370
    self._dataVisible = false;                                                                                    // 371
                                                                                                                  // 372
    self.sentMessage = true;                                                                                      // 373
                                                                                                                  // 374
    // If this is a wait method, make all data messages be buffered until it is                                   // 375
    // done.                                                                                                      // 376
    if (self._wait)                                                                                               // 377
      self._connection._methodsBlockingQuiescence[self.methodId] = true;                                          // 378
                                                                                                                  // 379
    // Actually send the message.                                                                                 // 380
    self._connection._send(self._message);                                                                        // 381
  },                                                                                                              // 382
  // Invoke the callback, if we have both a result and know that all data has                                     // 383
  // been written to the local cache.                                                                             // 384
  _maybeInvokeCallback: function () {                                                                             // 385
    var self = this;                                                                                              // 386
    if (self._methodResult && self._dataVisible) {                                                                // 387
      // Call the callback. (This won't throw: the callback was wrapped with                                      // 388
      // bindEnvironment.)                                                                                        // 389
      self._callback(self._methodResult[0], self._methodResult[1]);                                               // 390
                                                                                                                  // 391
      // Forget about this method.                                                                                // 392
      delete self._connection._methodInvokers[self.methodId];                                                     // 393
                                                                                                                  // 394
      // Let the connection know that this method is finished, so it can try to                                   // 395
      // move on to the next block of methods.                                                                    // 396
      self._connection._outstandingMethodFinished();                                                              // 397
    }                                                                                                             // 398
  },                                                                                                              // 399
  // Call with the result of the method from the server. Only may be called                                       // 400
  // once; once it is called, you should not call sendMessage again.                                              // 401
  // If the user provided an onResultReceived callback, call it immediately.                                      // 402
  // Then invoke the main callback if data is also visible.                                                       // 403
  receiveResult: function (err, result) {                                                                         // 404
    var self = this;                                                                                              // 405
    if (self.gotResult())                                                                                         // 406
      throw new Error("Methods should only receive results once");                                                // 407
    self._methodResult = [err, result];                                                                           // 408
    self._onResultReceived(err, result);                                                                          // 409
    self._maybeInvokeCallback();                                                                                  // 410
  },                                                                                                              // 411
  // Call this when all data written by the method is visible. This means that                                    // 412
  // the method has returns its "data is done" message *AND* all server                                           // 413
  // documents that are buffered at that time have been written to the local                                      // 414
  // cache. Invokes the main callback if the result has been received.                                            // 415
  dataVisible: function () {                                                                                      // 416
    var self = this;                                                                                              // 417
    self._dataVisible = true;                                                                                     // 418
    self._maybeInvokeCallback();                                                                                  // 419
  },                                                                                                              // 420
  // True if receiveResult has been called.                                                                       // 421
  gotResult: function () {                                                                                        // 422
    var self = this;                                                                                              // 423
    return !!self._methodResult;                                                                                  // 424
  }                                                                                                               // 425
});                                                                                                               // 426
                                                                                                                  // 427
_.extend(Connection.prototype, {                                                                                  // 428
  // 'name' is the name of the data on the wire that should go in the                                             // 429
  // store. 'wrappedStore' should be an object with methods beginUpdate, update,                                  // 430
  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.                                  // 431
  registerStore: function (name, wrappedStore) {                                                                  // 432
    var self = this;                                                                                              // 433
                                                                                                                  // 434
    if (name in self._stores)                                                                                     // 435
      return false;                                                                                               // 436
                                                                                                                  // 437
    // Wrap the input object in an object which makes any store method not                                        // 438
    // implemented by 'store' into a no-op.                                                                       // 439
    var store = {};                                                                                               // 440
    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',                                                // 441
            'retrieveOriginals'], function (method) {                                                             // 442
              store[method] = function () {                                                                       // 443
                return (wrappedStore[method]                                                                      // 444
                        ? wrappedStore[method].apply(wrappedStore, arguments)                                     // 445
                        : undefined);                                                                             // 446
              };                                                                                                  // 447
            });                                                                                                   // 448
                                                                                                                  // 449
    self._stores[name] = store;                                                                                   // 450
                                                                                                                  // 451
    var queued = self._updatesForUnknownStores[name];                                                             // 452
    if (queued) {                                                                                                 // 453
      store.beginUpdate(queued.length, false);                                                                    // 454
      _.each(queued, function (msg) {                                                                             // 455
        store.update(msg);                                                                                        // 456
      });                                                                                                         // 457
      store.endUpdate();                                                                                          // 458
      delete self._updatesForUnknownStores[name];                                                                 // 459
    }                                                                                                             // 460
                                                                                                                  // 461
    return true;                                                                                                  // 462
  },                                                                                                              // 463
                                                                                                                  // 464
  /**                                                                                                             // 465
   * @memberOf Meteor                                                                                             // 466
   * @summary Subscribe to a record set.  Returns a handle that provides                                          // 467
   * `stop()` and `ready()` methods.                                                                              // 468
   * @locus Client                                                                                                // 469
   * @param {String} name Name of the subscription.  Matches the name of the                                      // 470
   * server's `publish()` call.                                                                                   // 471
   * @param {Any} [arg1,arg2...] Optional arguments passed to publisher                                           // 472
   * function on server.                                                                                          // 473
   * @param {Function|Object} [callbacks] Optional. May include `onStop`                                          // 474
   * and `onReady` callbacks. If there is an error, it is passed as an                                            // 475
   * argument to `onStop`. If a function is passed instead of an object, it                                       // 476
   * is interpreted as an `onReady` callback.                                                                     // 477
   */                                                                                                             // 478
  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {                                       // 479
    var self = this;                                                                                              // 480
                                                                                                                  // 481
    var params = Array.prototype.slice.call(arguments, 1);                                                        // 482
    var callbacks = {};                                                                                           // 483
    if (params.length) {                                                                                          // 484
      var lastParam = params[params.length - 1];                                                                  // 485
      if (_.isFunction(lastParam)) {                                                                              // 486
        callbacks.onReady = params.pop();                                                                         // 487
      } else if (lastParam &&                                                                                     // 488
        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use                                          // 489
        // onStop with an error callback instead.                                                                 // 490
        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],                                           // 491
          _.isFunction)) {                                                                                        // 492
        callbacks = params.pop();                                                                                 // 493
      }                                                                                                           // 494
    }                                                                                                             // 495
                                                                                                                  // 496
    // Is there an existing sub with the same name and param, run in an                                           // 497
    // invalidated Computation? This will happen if we are rerunning an                                           // 498
    // existing computation.                                                                                      // 499
    //                                                                                                            // 500
    // For example, consider a rerun of:                                                                          // 501
    //                                                                                                            // 502
    //     Tracker.autorun(function () {                                                                          // 503
    //       Meteor.subscribe("foo", Session.get("foo"));                                                         // 504
    //       Meteor.subscribe("bar", Session.get("bar"));                                                         // 505
    //     });                                                                                                    // 506
    //                                                                                                            // 507
    // If "foo" has changed but "bar" has not, we will match the "bar"                                            // 508
    // subcribe to an existing inactive subscription in order to not                                              // 509
    // unsub and resub the subscription unnecessarily.                                                            // 510
    //                                                                                                            // 511
    // We only look for one such sub; if there are N apparently-identical subs                                    // 512
    // being invalidated, we will require N matching subscribe calls to keep                                      // 513
    // them all active.                                                                                           // 514
    var existing = _.find(self._subscriptions, function (sub) {                                                   // 515
      return sub.inactive && sub.name === name &&                                                                 // 516
        EJSON.equals(sub.params, params);                                                                         // 517
    });                                                                                                           // 518
                                                                                                                  // 519
    var id;                                                                                                       // 520
    if (existing) {                                                                                               // 521
      id = existing.id;                                                                                           // 522
      existing.inactive = false; // reactivate                                                                    // 523
                                                                                                                  // 524
      if (callbacks.onReady) {                                                                                    // 525
        // If the sub is not already ready, replace any ready callback with the                                   // 526
        // one provided now. (It's not really clear what users would expect for                                   // 527
        // an onReady callback inside an autorun; the semantics we provide is                                     // 528
        // that at the time the sub first becomes ready, we call the last                                         // 529
        // onReady callback provided, if any.)                                                                    // 530
        if (!existing.ready)                                                                                      // 531
          existing.readyCallback = callbacks.onReady;                                                             // 532
      }                                                                                                           // 533
                                                                                                                  // 534
      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call                                          // 535
      // onStop with an optional error argument                                                                   // 536
      if (callbacks.onError) {                                                                                    // 537
        // Replace existing callback if any, so that errors aren't                                                // 538
        // double-reported.                                                                                       // 539
        existing.errorCallback = callbacks.onError;                                                               // 540
      }                                                                                                           // 541
                                                                                                                  // 542
      if (callbacks.onStop) {                                                                                     // 543
        existing.stopCallback = callbacks.onStop;                                                                 // 544
      }                                                                                                           // 545
    } else {                                                                                                      // 546
      // New sub! Generate an id, save it locally, and send message.                                              // 547
      id = Random.id();                                                                                           // 548
      self._subscriptions[id] = {                                                                                 // 549
        id: id,                                                                                                   // 550
        name: name,                                                                                               // 551
        params: EJSON.clone(params),                                                                              // 552
        inactive: false,                                                                                          // 553
        ready: false,                                                                                             // 554
        readyDeps: new Tracker.Dependency,                                                                        // 555
        readyCallback: callbacks.onReady,                                                                         // 556
        // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                 // 557
        errorCallback: callbacks.onError,                                                                         // 558
        stopCallback: callbacks.onStop,                                                                           // 559
        connection: self,                                                                                         // 560
        remove: function() {                                                                                      // 561
          delete this.connection._subscriptions[this.id];                                                         // 562
          this.ready && this.readyDeps.changed();                                                                 // 563
        },                                                                                                        // 564
        stop: function() {                                                                                        // 565
          this.connection._send({msg: 'unsub', id: id});                                                          // 566
          this.remove();                                                                                          // 567
                                                                                                                  // 568
          if (callbacks.onStop) {                                                                                 // 569
            callbacks.onStop();                                                                                   // 570
          }                                                                                                       // 571
        }                                                                                                         // 572
      };                                                                                                          // 573
      self._send({msg: 'sub', id: id, name: name, params: params});                                               // 574
    }                                                                                                             // 575
                                                                                                                  // 576
    // return a handle to the application.                                                                        // 577
    var handle = {                                                                                                // 578
      stop: function () {                                                                                         // 579
        if (!_.has(self._subscriptions, id))                                                                      // 580
          return;                                                                                                 // 581
                                                                                                                  // 582
        self._subscriptions[id].stop();                                                                           // 583
      },                                                                                                          // 584
      ready: function () {                                                                                        // 585
        // return false if we've unsubscribed.                                                                    // 586
        if (!_.has(self._subscriptions, id))                                                                      // 587
          return false;                                                                                           // 588
        var record = self._subscriptions[id];                                                                     // 589
        record.readyDeps.depend();                                                                                // 590
        return record.ready;                                                                                      // 591
      },                                                                                                          // 592
      subscriptionId: id                                                                                          // 593
    };                                                                                                            // 594
                                                                                                                  // 595
    if (Tracker.active) {                                                                                         // 596
      // We're in a reactive computation, so we'd like to unsubscribe when the                                    // 597
      // computation is invalidated... but not if the rerun just re-subscribes                                    // 598
      // to the same subscription!  When a rerun happens, we use onInvalidate                                     // 599
      // as a change to mark the subscription "inactive" so that it can                                           // 600
      // be reused from the rerun.  If it isn't reused, it's killed from                                          // 601
      // an afterFlush.                                                                                           // 602
      Tracker.onInvalidate(function (c) {                                                                         // 603
        if (_.has(self._subscriptions, id))                                                                       // 604
          self._subscriptions[id].inactive = true;                                                                // 605
                                                                                                                  // 606
        Tracker.afterFlush(function () {                                                                          // 607
          if (_.has(self._subscriptions, id) &&                                                                   // 608
              self._subscriptions[id].inactive)                                                                   // 609
            handle.stop();                                                                                        // 610
        });                                                                                                       // 611
      });                                                                                                         // 612
    }                                                                                                             // 613
                                                                                                                  // 614
    return handle;                                                                                                // 615
  },                                                                                                              // 616
                                                                                                                  // 617
  // options:                                                                                                     // 618
  // - onLateError {Function(error)} called if an error was received after the ready event.                       // 619
  //     (errors received before ready cause an error to be thrown)                                               // 620
  _subscribeAndWait: function (name, args, options) {                                                             // 621
    var self = this;                                                                                              // 622
    var f = new Future();                                                                                         // 623
    var ready = false;                                                                                            // 624
    var handle;                                                                                                   // 625
    args = args || [];                                                                                            // 626
    args.push({                                                                                                   // 627
      onReady: function () {                                                                                      // 628
        ready = true;                                                                                             // 629
        f['return']();                                                                                            // 630
      },                                                                                                          // 631
      onError: function (e) {                                                                                     // 632
        if (!ready)                                                                                               // 633
          f['throw'](e);                                                                                          // 634
        else                                                                                                      // 635
          options && options.onLateError && options.onLateError(e);                                               // 636
      }                                                                                                           // 637
    });                                                                                                           // 638
                                                                                                                  // 639
    handle = self.subscribe.apply(self, [name].concat(args));                                                     // 640
    f.wait();                                                                                                     // 641
    return handle;                                                                                                // 642
  },                                                                                                              // 643
                                                                                                                  // 644
  methods: function (methods) {                                                                                   // 645
    var self = this;                                                                                              // 646
    _.each(methods, function (func, name) {                                                                       // 647
      if (self._methodHandlers[name])                                                                             // 648
        throw new Error("A method named '" + name + "' is already defined");                                      // 649
      self._methodHandlers[name] = func;                                                                          // 650
    });                                                                                                           // 651
  },                                                                                                              // 652
                                                                                                                  // 653
  /**                                                                                                             // 654
   * @memberOf Meteor                                                                                             // 655
   * @summary Invokes a method passing any number of arguments.                                                   // 656
   * @locus Anywhere                                                                                              // 657
   * @param {String} name Name of method to invoke                                                                // 658
   * @param {EJSONable} [arg1,arg2...] Optional method arguments                                                  // 659
   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).
   */                                                                                                             // 661
  call: function (name /* .. [arguments] .. callback */) {                                                        // 662
    // if it's a function, the last argument is the result callback,                                              // 663
    // not a parameter to the remote method.                                                                      // 664
    var args = Array.prototype.slice.call(arguments, 1);                                                          // 665
    if (args.length && typeof args[args.length - 1] === "function")                                               // 666
      var callback = args.pop();                                                                                  // 667
    return this.apply(name, args, callback);                                                                      // 668
  },                                                                                                              // 669
                                                                                                                  // 670
  // @param options {Optional Object}                                                                             // 671
  //   wait: Boolean - Should we wait to call this until all current methods                                      // 672
  //                   are fully finished, and block subsequent method calls                                      // 673
  //                   until this method is fully finished?                                                       // 674
  //                   (does not affect methods called from within this method)                                   // 675
  //   onResultReceived: Function - a callback to call as soon as the method                                      // 676
  //                                result is received. the data written by                                       // 677
  //                                the method may not yet be in the cache!                                       // 678
  //   returnStubValue: Boolean - If true then in cases where we would have                                       // 679
  //                              otherwise discarded the stub's return value                                     // 680
  //                              and returned undefined, instead we go ahead                                     // 681
  //                              and return it.  Specifically, this is any                                       // 682
  //                              time other than when (a) we are already                                         // 683
  //                              inside a stub or (b) we are in Node and no                                      // 684
  //                              callback was provided.  Currently we require                                    // 685
  //                              this flag to be explicitly passed to reduce                                     // 686
  //                              the likelihood that stub return values will                                     // 687
  //                              be confused with server return values; we                                       // 688
  //                              may improve this in future.                                                     // 689
  // @param callback {Optional Function}                                                                          // 690
                                                                                                                  // 691
  /**                                                                                                             // 692
   * @memberOf Meteor                                                                                             // 693
   * @summary Invoke a method passing an array of arguments.                                                      // 694
   * @locus Anywhere                                                                                              // 695
   * @param {String} name Name of method to invoke                                                                // 696
   * @param {EJSONable[]} args Method arguments                                                                   // 697
   * @param {Object} [options]                                                                                    // 698
   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.
   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.
   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).     // 701
   */                                                                                                             // 702
  apply: function (name, args, options, callback) {                                                               // 703
    var self = this;                                                                                              // 704
                                                                                                                  // 705
    // We were passed 3 arguments. They may be either (name, args, options)                                       // 706
    // or (name, args, callback)                                                                                  // 707
    if (!callback && typeof options === 'function') {                                                             // 708
      callback = options;                                                                                         // 709
      options = {};                                                                                               // 710
    }                                                                                                             // 711
    options = options || {};                                                                                      // 712
                                                                                                                  // 713
    if (callback) {                                                                                               // 714
      // XXX would it be better form to do the binding in stream.on,                                              // 715
      // or caller, instead of here?                                                                              // 716
      // XXX improve error message (and how we report it)                                                         // 717
      callback = Meteor.bindEnvironment(                                                                          // 718
        callback,                                                                                                 // 719
        "delivering result of invoking '" + name + "'"                                                            // 720
      );                                                                                                          // 721
    }                                                                                                             // 722
                                                                                                                  // 723
    // Keep our args safe from mutation (eg if we don't send the message for a                                    // 724
    // while because of a wait method).                                                                           // 725
    args = EJSON.clone(args);                                                                                     // 726
                                                                                                                  // 727
    // Lazily allocate method ID once we know that it'll be needed.                                               // 728
    var methodId = (function () {                                                                                 // 729
      var id;                                                                                                     // 730
      return function () {                                                                                        // 731
        if (id === undefined)                                                                                     // 732
          id = '' + (self._nextMethodId++);                                                                       // 733
        return id;                                                                                                // 734
      };                                                                                                          // 735
    })();                                                                                                         // 736
                                                                                                                  // 737
    var enclosing = DDP._CurrentInvocation.get();                                                                 // 738
    var alreadyInSimulation = enclosing && enclosing.isSimulation;                                                // 739
                                                                                                                  // 740
    // Lazily generate a randomSeed, only if it is requested by the stub.                                         // 741
    // The random streams only have utility if they're used on both the client                                    // 742
    // and the server; if the client doesn't generate any 'random' values                                         // 743
    // then we don't expect the server to generate any either.                                                    // 744
    // Less commonly, the server may perform different actions from the client,                                   // 745
    // and may in fact generate values where the client did not, but we don't                                     // 746
    // have any client-side values to match, so even here we may as well just                                     // 747
    // use a random seed on the server.  In that case, we don't pass the                                          // 748
    // randomSeed to save bandwidth, and we don't even generate it to save a                                      // 749
    // bit of CPU and to avoid consuming entropy.                                                                 // 750
    var randomSeed = null;                                                                                        // 751
    var randomSeedGenerator = function () {                                                                       // 752
      if (randomSeed === null) {                                                                                  // 753
        randomSeed = makeRpcSeed(enclosing, name);                                                                // 754
      }                                                                                                           // 755
      return randomSeed;                                                                                          // 756
    };                                                                                                            // 757
                                                                                                                  // 758
    // Run the stub, if we have one. The stub is supposed to make some                                            // 759
    // temporary writes to the database to give the user a smooth experience                                      // 760
    // until the actual result of executing the method comes back from the                                        // 761
    // server (whereupon the temporary writes to the database will be reversed                                    // 762
    // during the beginUpdate/endUpdate process.)                                                                 // 763
    //                                                                                                            // 764
    // Normally, we ignore the return value of the stub (even if it is an                                         // 765
    // exception), in favor of the real return value from the server. The                                         // 766
    // exception is if the *caller* is a stub. In that case, we're not going                                      // 767
    // to do a RPC, so we use the return value of the stub as our return                                          // 768
    // value.                                                                                                     // 769
                                                                                                                  // 770
    var stub = self._methodHandlers[name];                                                                        // 771
    if (stub) {                                                                                                   // 772
      var setUserId = function(userId) {                                                                          // 773
        self.setUserId(userId);                                                                                   // 774
      };                                                                                                          // 775
                                                                                                                  // 776
      var invocation = new MethodInvocation({                                                                     // 777
        isSimulation: true,                                                                                       // 778
        userId: self.userId(),                                                                                    // 779
        setUserId: setUserId,                                                                                     // 780
        randomSeed: function () { return randomSeedGenerator(); }                                                 // 781
      });                                                                                                         // 782
                                                                                                                  // 783
      if (!alreadyInSimulation)                                                                                   // 784
        self._saveOriginals();                                                                                    // 785
                                                                                                                  // 786
      try {                                                                                                       // 787
        // Note that unlike in the corresponding server code, we never audit                                      // 788
        // that stubs check() their arguments.                                                                    // 789
        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {                          // 790
          if (Meteor.isServer) {                                                                                  // 791
            // Because saveOriginals and retrieveOriginals aren't reentrant,                                      // 792
            // don't allow stubs to yield.                                                                        // 793
            return Meteor._noYieldsAllowed(function () {                                                          // 794
              // re-clone, so that the stub can't affect our caller's values                                      // 795
              return stub.apply(invocation, EJSON.clone(args));                                                   // 796
            });                                                                                                   // 797
          } else {                                                                                                // 798
            return stub.apply(invocation, EJSON.clone(args));                                                     // 799
          }                                                                                                       // 800
        });                                                                                                       // 801
      }                                                                                                           // 802
      catch (e) {                                                                                                 // 803
        var exception = e;                                                                                        // 804
      }                                                                                                           // 805
                                                                                                                  // 806
      if (!alreadyInSimulation)                                                                                   // 807
        self._retrieveAndStoreOriginals(methodId());                                                              // 808
    }                                                                                                             // 809
                                                                                                                  // 810
    // If we're in a simulation, stop and return the result we have,                                              // 811
    // rather than going on to do an RPC. If there was no stub,                                                   // 812
    // we'll end up returning undefined.                                                                          // 813
    if (alreadyInSimulation) {                                                                                    // 814
      if (callback) {                                                                                             // 815
        callback(exception, stubReturnValue);                                                                     // 816
        return undefined;                                                                                         // 817
      }                                                                                                           // 818
      if (exception)                                                                                              // 819
        throw exception;                                                                                          // 820
      return stubReturnValue;                                                                                     // 821
    }                                                                                                             // 822
                                                                                                                  // 823
    // If an exception occurred in a stub, and we're ignoring it                                                  // 824
    // because we're doing an RPC and want to use what the server                                                 // 825
    // returns instead, log it so the developer knows.                                                            // 826
    //                                                                                                            // 827
    // Tests can set the 'expected' flag on an exception so it won't                                              // 828
    // go to log.                                                                                                 // 829
    if (exception && !exception.expected) {                                                                       // 830
      Meteor._debug("Exception while simulating the effect of invoking '" +                                       // 831
                    name + "'", exception, exception.stack);                                                      // 832
    }                                                                                                             // 833
                                                                                                                  // 834
                                                                                                                  // 835
    // At this point we're definitely doing an RPC, and we're going to                                            // 836
    // return the value of the RPC to the caller.                                                                 // 837
                                                                                                                  // 838
    // If the caller didn't give a callback, decide what to do.                                                   // 839
    if (!callback) {                                                                                              // 840
      if (Meteor.isClient) {                                                                                      // 841
        // On the client, we don't have fibers, so we can't block. The                                            // 842
        // only thing we can do is to return undefined and discard the                                            // 843
        // result of the RPC. If an error occurred then print the error                                           // 844
        // to the console.                                                                                        // 845
        callback = function (err) {                                                                               // 846
          err && Meteor._debug("Error invoking Method '" + name + "':",                                           // 847
                               err.message);                                                                      // 848
        };                                                                                                        // 849
      } else {                                                                                                    // 850
        // On the server, make the function synchronous. Throw on                                                 // 851
        // errors, return on success.                                                                             // 852
        var future = new Future;                                                                                  // 853
        callback = future.resolver();                                                                             // 854
      }                                                                                                           // 855
    }                                                                                                             // 856
    // Send the RPC. Note that on the client, it is important that the                                            // 857
    // stub have finished before we send the RPC, so that we know we have                                         // 858
    // a complete list of which local documents the stub wrote.                                                   // 859
    var message = {                                                                                               // 860
      msg: 'method',                                                                                              // 861
      method: name,                                                                                               // 862
      params: args,                                                                                               // 863
      id: methodId()                                                                                              // 864
    };                                                                                                            // 865
                                                                                                                  // 866
    // Send the randomSeed only if we used it                                                                     // 867
    if (randomSeed !== null) {                                                                                    // 868
      message.randomSeed = randomSeed;                                                                            // 869
    }                                                                                                             // 870
                                                                                                                  // 871
    var methodInvoker = new MethodInvoker({                                                                       // 872
      methodId: methodId(),                                                                                       // 873
      callback: callback,                                                                                         // 874
      connection: self,                                                                                           // 875
      onResultReceived: options.onResultReceived,                                                                 // 876
      wait: !!options.wait,                                                                                       // 877
      message: message                                                                                            // 878
    });                                                                                                           // 879
                                                                                                                  // 880
    if (options.wait) {                                                                                           // 881
      // It's a wait method! Wait methods go in their own block.                                                  // 882
      self._outstandingMethodBlocks.push(                                                                         // 883
        {wait: true, methods: [methodInvoker]});                                                                  // 884
    } else {                                                                                                      // 885
      // Not a wait method. Start a new block if the previous block was a wait                                    // 886
      // block, and add it to the last block of methods.                                                          // 887
      if (_.isEmpty(self._outstandingMethodBlocks) ||                                                             // 888
          _.last(self._outstandingMethodBlocks).wait)                                                             // 889
        self._outstandingMethodBlocks.push({wait: false, methods: []});                                           // 890
      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);                                          // 891
    }                                                                                                             // 892
                                                                                                                  // 893
    // If we added it to the first block, send it out now.                                                        // 894
    if (self._outstandingMethodBlocks.length === 1)                                                               // 895
      methodInvoker.sendMessage();                                                                                // 896
                                                                                                                  // 897
    // If we're using the default callback on the server,                                                         // 898
    // block waiting for the result.                                                                              // 899
    if (future) {                                                                                                 // 900
      return future.wait();                                                                                       // 901
    }                                                                                                             // 902
    return options.returnStubValue ? stubReturnValue : undefined;                                                 // 903
  },                                                                                                              // 904
                                                                                                                  // 905
  // Before calling a method stub, prepare all stores to track changes and allow                                  // 906
  // _retrieveAndStoreOriginals to get the original versions of changed                                           // 907
  // documents.                                                                                                   // 908
  _saveOriginals: function () {                                                                                   // 909
    var self = this;                                                                                              // 910
    _.each(self._stores, function (s) {                                                                           // 911
      s.saveOriginals();                                                                                          // 912
    });                                                                                                           // 913
  },                                                                                                              // 914
  // Retrieves the original versions of all documents modified by the stub for                                    // 915
  // method 'methodId' from all stores and saves them to _serverDocuments (keyed                                  // 916
  // by document) and _documentsWrittenByStub (keyed by method ID).                                               // 917
  _retrieveAndStoreOriginals: function (methodId) {                                                               // 918
    var self = this;                                                                                              // 919
    if (self._documentsWrittenByStub[methodId])                                                                   // 920
      throw new Error("Duplicate methodId in _retrieveAndStoreOriginals");                                        // 921
                                                                                                                  // 922
    var docsWritten = [];                                                                                         // 923
    _.each(self._stores, function (s, collection) {                                                               // 924
      var originals = s.retrieveOriginals();                                                                      // 925
      // not all stores define retrieveOriginals                                                                  // 926
      if (!originals)                                                                                             // 927
        return;                                                                                                   // 928
      originals.forEach(function (doc, id) {                                                                      // 929
        docsWritten.push({collection: collection, id: id});                                                       // 930
        if (!_.has(self._serverDocuments, collection))                                                            // 931
          self._serverDocuments[collection] = new LocalCollection._IdMap;                                         // 932
        var serverDoc = self._serverDocuments[collection].setDefault(id, {});                                     // 933
        if (serverDoc.writtenByStubs) {                                                                           // 934
          // We're not the first stub to write this doc. Just add our method ID                                   // 935
          // to the record.                                                                                       // 936
          serverDoc.writtenByStubs[methodId] = true;                                                              // 937
        } else {                                                                                                  // 938
          // First stub! Save the original value and our method ID.                                               // 939
          serverDoc.document = doc;                                                                               // 940
          serverDoc.flushCallbacks = [];                                                                          // 941
          serverDoc.writtenByStubs = {};                                                                          // 942
          serverDoc.writtenByStubs[methodId] = true;                                                              // 943
        }                                                                                                         // 944
      });                                                                                                         // 945
    });                                                                                                           // 946
    if (!_.isEmpty(docsWritten)) {                                                                                // 947
      self._documentsWrittenByStub[methodId] = docsWritten;                                                       // 948
    }                                                                                                             // 949
  },                                                                                                              // 950
                                                                                                                  // 951
  // This is very much a private function we use to make the tests                                                // 952
  // take up fewer server resources after they complete.                                                          // 953
  _unsubscribeAll: function () {                                                                                  // 954
    var self = this;                                                                                              // 955
    _.each(_.clone(self._subscriptions), function (sub, id) {                                                     // 956
      // Avoid killing the autoupdate subscription so that developers                                             // 957
      // still get hot code pushes when writing tests.                                                            // 958
      //                                                                                                          // 959
      // XXX it's a hack to encode knowledge about autoupdate here,                                               // 960
      // but it doesn't seem worth it yet to have a special API for                                               // 961
      // subscriptions to preserve after unit tests.                                                              // 962
      if (sub.name !== 'meteor_autoupdate_clientVersions') {                                                      // 963
        self._subscriptions[id].stop();                                                                           // 964
      }                                                                                                           // 965
    });                                                                                                           // 966
  },                                                                                                              // 967
                                                                                                                  // 968
  // Sends the DDP stringification of the given message object                                                    // 969
  _send: function (obj) {                                                                                         // 970
    var self = this;                                                                                              // 971
    self._stream.send(stringifyDDP(obj));                                                                         // 972
  },                                                                                                              // 973
                                                                                                                  // 974
  // We detected via DDP-level heartbeats that we've lost the                                                     // 975
  // connection.  Unlike `disconnect` or `close`, a lost connection                                               // 976
  // will be automatically retried.                                                                               // 977
  _lostConnection: function (error) {                                                                             // 978
    var self = this;                                                                                              // 979
    self._stream._lostConnection(error);                                                                          // 980
  },                                                                                                              // 981
                                                                                                                  // 982
  /**                                                                                                             // 983
   * @summary Get the current connection status. A reactive data source.                                          // 984
   * @locus Client                                                                                                // 985
   * @memberOf Meteor                                                                                             // 986
   */                                                                                                             // 987
  status: function (/*passthrough args*/) {                                                                       // 988
    var self = this;                                                                                              // 989
    return self._stream.status.apply(self._stream, arguments);                                                    // 990
  },                                                                                                              // 991
                                                                                                                  // 992
  /**                                                                                                             // 993
   * @summary Force an immediate reconnection attempt if the client is not connected to the server.               // 994
                                                                                                                  // 995
  This method does nothing if the client is already connected.                                                    // 996
   * @locus Client                                                                                                // 997
   * @memberOf Meteor                                                                                             // 998
   */                                                                                                             // 999
  reconnect: function (/*passthrough args*/) {                                                                    // 1000
    var self = this;                                                                                              // 1001
    return self._stream.reconnect.apply(self._stream, arguments);                                                 // 1002
  },                                                                                                              // 1003
                                                                                                                  // 1004
  /**                                                                                                             // 1005
   * @summary Disconnect the client from the server.                                                              // 1006
   * @locus Client                                                                                                // 1007
   * @memberOf Meteor                                                                                             // 1008
   */                                                                                                             // 1009
  disconnect: function (/*passthrough args*/) {                                                                   // 1010
    var self = this;                                                                                              // 1011
    return self._stream.disconnect.apply(self._stream, arguments);                                                // 1012
  },                                                                                                              // 1013
                                                                                                                  // 1014
  close: function () {                                                                                            // 1015
    var self = this;                                                                                              // 1016
    return self._stream.disconnect({_permanent: true});                                                           // 1017
  },                                                                                                              // 1018
                                                                                                                  // 1019
  ///                                                                                                             // 1020
  /// Reactive user system                                                                                        // 1021
  ///                                                                                                             // 1022
  userId: function () {                                                                                           // 1023
    var self = this;                                                                                              // 1024
    if (self._userIdDeps)                                                                                         // 1025
      self._userIdDeps.depend();                                                                                  // 1026
    return self._userId;                                                                                          // 1027
  },                                                                                                              // 1028
                                                                                                                  // 1029
  setUserId: function (userId) {                                                                                  // 1030
    var self = this;                                                                                              // 1031
    // Avoid invalidating dependents if setUserId is called with current value.                                   // 1032
    if (self._userId === userId)                                                                                  // 1033
      return;                                                                                                     // 1034
    self._userId = userId;                                                                                        // 1035
    if (self._userIdDeps)                                                                                         // 1036
      self._userIdDeps.changed();                                                                                 // 1037
  },                                                                                                              // 1038
                                                                                                                  // 1039
  // Returns true if we are in a state after reconnect of waiting for subs to be                                  // 1040
  // revived or early methods to finish their data, or we are waiting for a                                       // 1041
  // "wait" method to finish.                                                                                     // 1042
  _waitingForQuiescence: function () {                                                                            // 1043
    var self = this;                                                                                              // 1044
    return (! _.isEmpty(self._subsBeingRevived) ||                                                                // 1045
            ! _.isEmpty(self._methodsBlockingQuiescence));                                                        // 1046
  },                                                                                                              // 1047
                                                                                                                  // 1048
  // Returns true if any method whose message has been sent to the server has                                     // 1049
  // not yet invoked its user callback.                                                                           // 1050
  _anyMethodsAreOutstanding: function () {                                                                        // 1051
    var self = this;                                                                                              // 1052
    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));                                                   // 1053
  },                                                                                                              // 1054
                                                                                                                  // 1055
  _livedata_connected: function (msg) {                                                                           // 1056
    var self = this;                                                                                              // 1057
                                                                                                                  // 1058
    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {                                              // 1059
      self._heartbeat = new Heartbeat({                                                                           // 1060
        heartbeatInterval: self._heartbeatInterval,                                                               // 1061
        heartbeatTimeout: self._heartbeatTimeout,                                                                 // 1062
        onTimeout: function () {                                                                                  // 1063
          self._lostConnection(                                                                                   // 1064
            new DDP.ConnectionError("DDP heartbeat timed out"));                                                  // 1065
        },                                                                                                        // 1066
        sendPing: function () {                                                                                   // 1067
          self._send({msg: 'ping'});                                                                              // 1068
        }                                                                                                         // 1069
      });                                                                                                         // 1070
      self._heartbeat.start();                                                                                    // 1071
    }                                                                                                             // 1072
                                                                                                                  // 1073
    // If this is a reconnect, we'll have to reset all stores.                                                    // 1074
    if (self._lastSessionId)                                                                                      // 1075
      self._resetStores = true;                                                                                   // 1076
                                                                                                                  // 1077
    if (typeof (msg.session) === "string") {                                                                      // 1078
      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);                                   // 1079
      self._lastSessionId = msg.session;                                                                          // 1080
    }                                                                                                             // 1081
                                                                                                                  // 1082
    if (reconnectedToPreviousSession) {                                                                           // 1083
      // Successful reconnection -- pick up where we left off.  Note that right                                   // 1084
      // now, this never happens: the server never connects us to a previous                                      // 1085
      // session, because DDP doesn't provide enough data for the server to know                                  // 1086
      // what messages the client has processed. We need to improve DDP to make                                   // 1087
      // this possible, at which point we'll probably need more code here.                                        // 1088
      return;                                                                                                     // 1089
    }                                                                                                             // 1090
                                                                                                                  // 1091
    // Server doesn't have our data any more. Re-sync a new session.                                              // 1092
                                                                                                                  // 1093
    // Forget about messages we were buffering for unknown collections. They'll                                   // 1094
    // be resent if still relevant.                                                                               // 1095
    self._updatesForUnknownStores = {};                                                                           // 1096
                                                                                                                  // 1097
    if (self._resetStores) {                                                                                      // 1098
      // Forget about the effects of stubs. We'll be resetting all collections                                    // 1099
      // anyway.                                                                                                  // 1100
      self._documentsWrittenByStub = {};                                                                          // 1101
      self._serverDocuments = {};                                                                                 // 1102
    }                                                                                                             // 1103
                                                                                                                  // 1104
    // Clear _afterUpdateCallbacks.                                                                               // 1105
    self._afterUpdateCallbacks = [];                                                                              // 1106
                                                                                                                  // 1107
    // Mark all named subscriptions which are ready (ie, we already called the                                    // 1108
    // ready callback) as needing to be revived.                                                                  // 1109
    // XXX We should also block reconnect quiescence until unnamed subscriptions                                  // 1110
    //     (eg, autopublish) are done re-publishing to avoid flicker!                                             // 1111
    self._subsBeingRevived = {};                                                                                  // 1112
    _.each(self._subscriptions, function (sub, id) {                                                              // 1113
      if (sub.ready)                                                                                              // 1114
        self._subsBeingRevived[id] = true;                                                                        // 1115
    });                                                                                                           // 1116
                                                                                                                  // 1117
    // Arrange for "half-finished" methods to have their callbacks run, and                                       // 1118
    // track methods that were sent on this connection so that we don't                                           // 1119
    // quiesce until they are all done.                                                                           // 1120
    //                                                                                                            // 1121
    // Start by clearing _methodsBlockingQuiescence: methods sent before                                          // 1122
    // reconnect don't matter, and any "wait" methods sent on the new connection                                  // 1123
    // that we drop here will be restored by the loop below.                                                      // 1124
    self._methodsBlockingQuiescence = {};                                                                         // 1125
    if (self._resetStores) {                                                                                      // 1126
      _.each(self._methodInvokers, function (invoker) {                                                           // 1127
        if (invoker.gotResult()) {                                                                                // 1128
          // This method already got its result, but it didn't call its callback                                  // 1129
          // because its data didn't become visible. We did not resend the                                        // 1130
          // method RPC. We'll call its callback when we get a full quiesce,                                      // 1131
          // since that's as close as we'll get to "data must be visible".                                        // 1132
          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));                                  // 1133
        } else if (invoker.sentMessage) {                                                                         // 1134
          // This method has been sent on this connection (maybe as a resend                                      // 1135
          // from the last connection, maybe from onReconnect, maybe just very                                    // 1136
          // quickly before processing the connected message).                                                    // 1137
          //                                                                                                      // 1138
          // We don't need to do anything special to ensure its callbacks get                                     // 1139
          // called, but we'll count it as a method which is preventing                                           // 1140
          // reconnect quiescence. (eg, it might be a login method that was run                                   // 1141
          // from onReconnect, and we don't want to see flicker by seeing a                                       // 1142
          // logged-out state.)                                                                                   // 1143
          self._methodsBlockingQuiescence[invoker.methodId] = true;                                               // 1144
        }                                                                                                         // 1145
      });                                                                                                         // 1146
    }                                                                                                             // 1147
                                                                                                                  // 1148
    self._messagesBufferedUntilQuiescence = [];                                                                   // 1149
                                                                                                                  // 1150
    // If we're not waiting on any methods or subs, we can reset the stores and                                   // 1151
    // call the callbacks immediately.                                                                            // 1152
    if (!self._waitingForQuiescence()) {                                                                          // 1153
      if (self._resetStores) {                                                                                    // 1154
        _.each(self._stores, function (s) {                                                                       // 1155
          s.beginUpdate(0, true);                                                                                 // 1156
          s.endUpdate();                                                                                          // 1157
        });                                                                                                       // 1158
        self._resetStores = false;                                                                                // 1159
      }                                                                                                           // 1160
      self._runAfterUpdateCallbacks();                                                                            // 1161
    }                                                                                                             // 1162
  },                                                                                                              // 1163
                                                                                                                  // 1164
                                                                                                                  // 1165
  _processOneDataMessage: function (msg, updates) {                                                               // 1166
    var self = this;                                                                                              // 1167
    // Using underscore here so as not to need to capitalize.                                                     // 1168
    self['_process_' + msg.msg](msg, updates);                                                                    // 1169
  },                                                                                                              // 1170
                                                                                                                  // 1171
                                                                                                                  // 1172
  _livedata_data: function (msg) {                                                                                // 1173
    var self = this;                                                                                              // 1174
                                                                                                                  // 1175
    // collection name -> array of messages                                                                       // 1176
    var updates = {};                                                                                             // 1177
                                                                                                                  // 1178
    if (self._waitingForQuiescence()) {                                                                           // 1179
      self._messagesBufferedUntilQuiescence.push(msg);                                                            // 1180
                                                                                                                  // 1181
      if (msg.msg === "nosub")                                                                                    // 1182
        delete self._subsBeingRevived[msg.id];                                                                    // 1183
                                                                                                                  // 1184
      _.each(msg.subs || [], function (subId) {                                                                   // 1185
        delete self._subsBeingRevived[subId];                                                                     // 1186
      });                                                                                                         // 1187
      _.each(msg.methods || [], function (methodId) {                                                             // 1188
        delete self._methodsBlockingQuiescence[methodId];                                                         // 1189
      });                                                                                                         // 1190
                                                                                                                  // 1191
      if (self._waitingForQuiescence())                                                                           // 1192
        return;                                                                                                   // 1193
                                                                                                                  // 1194
      // No methods or subs are blocking quiescence!                                                              // 1195
      // We'll now process and all of our buffered messages, reset all stores,                                    // 1196
      // and apply them all at once.                                                                              // 1197
      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {                                      // 1198
        self._processOneDataMessage(bufferedMsg, updates);                                                        // 1199
      });                                                                                                         // 1200
      self._messagesBufferedUntilQuiescence = [];                                                                 // 1201
    } else {                                                                                                      // 1202
      self._processOneDataMessage(msg, updates);                                                                  // 1203
    }                                                                                                             // 1204
                                                                                                                  // 1205
    if (self._resetStores || !_.isEmpty(updates)) {                                                               // 1206
      // Begin a transactional update of each store.                                                              // 1207
      _.each(self._stores, function (s, storeName) {                                                              // 1208
        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,                                  // 1209
                      self._resetStores);                                                                         // 1210
      });                                                                                                         // 1211
      self._resetStores = false;                                                                                  // 1212
                                                                                                                  // 1213
      _.each(updates, function (updateMessages, storeName) {                                                      // 1214
        var store = self._stores[storeName];                                                                      // 1215
        if (store) {                                                                                              // 1216
          _.each(updateMessages, function (updateMessage) {                                                       // 1217
            store.update(updateMessage);                                                                          // 1218
          });                                                                                                     // 1219
        } else {                                                                                                  // 1220
          // Nobody's listening for this data. Queue it up until                                                  // 1221
          // someone wants it.                                                                                    // 1222
          // XXX memory use will grow without bound if you forget to                                              // 1223
          // create a collection or just don't care about it... going                                             // 1224
          // to have to do something about that.                                                                  // 1225
          if (!_.has(self._updatesForUnknownStores, storeName))                                                   // 1226
            self._updatesForUnknownStores[storeName] = [];                                                        // 1227
          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],                                    // 1228
                                     updateMessages);                                                             // 1229
        }                                                                                                         // 1230
      });                                                                                                         // 1231
                                                                                                                  // 1232
      // End update transaction.                                                                                  // 1233
      _.each(self._stores, function (s) { s.endUpdate(); });                                                      // 1234
    }                                                                                                             // 1235
                                                                                                                  // 1236
    self._runAfterUpdateCallbacks();                                                                              // 1237
  },                                                                                                              // 1238
                                                                                                                  // 1239
  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose                                       // 1240
  // relevant docs have been flushed, as well as dataVisible callbacks at                                         // 1241
  // reconnect-quiescence time.                                                                                   // 1242
  _runAfterUpdateCallbacks: function () {                                                                         // 1243
    var self = this;                                                                                              // 1244
    var callbacks = self._afterUpdateCallbacks;                                                                   // 1245
    self._afterUpdateCallbacks = [];                                                                              // 1246
    _.each(callbacks, function (c) {                                                                              // 1247
      c();                                                                                                        // 1248
    });                                                                                                           // 1249
  },                                                                                                              // 1250
                                                                                                                  // 1251
  _pushUpdate: function (updates, collection, msg) {                                                              // 1252
    var self = this;                                                                                              // 1253
    if (!_.has(updates, collection)) {                                                                            // 1254
      updates[collection] = [];                                                                                   // 1255
    }                                                                                                             // 1256
    updates[collection].push(msg);                                                                                // 1257
  },                                                                                                              // 1258
                                                                                                                  // 1259
  _getServerDoc: function (collection, id) {                                                                      // 1260
    var self = this;                                                                                              // 1261
    if (!_.has(self._serverDocuments, collection))                                                                // 1262
      return null;                                                                                                // 1263
    var serverDocsForCollection = self._serverDocuments[collection];                                              // 1264
    return serverDocsForCollection.get(id) || null;                                                               // 1265
  },                                                                                                              // 1266
                                                                                                                  // 1267
  _process_added: function (msg, updates) {                                                                       // 1268
    var self = this;                                                                                              // 1269
    var id = LocalCollection._idParse(msg.id);                                                                    // 1270
    var serverDoc = self._getServerDoc(msg.collection, id);                                                       // 1271
    if (serverDoc) {                                                                                              // 1272
      // Some outstanding stub wrote here.                                                                        // 1273
      if (serverDoc.document !== undefined)                                                                       // 1274
        throw new Error("Server sent add for existing id: " + msg.id);                                            // 1275
      serverDoc.document = msg.fields || {};                                                                      // 1276
      serverDoc.document._id = id;                                                                                // 1277
    } else {                                                                                                      // 1278
      self._pushUpdate(updates, msg.collection, msg);                                                             // 1279
    }                                                                                                             // 1280
  },                                                                                                              // 1281
                                                                                                                  // 1282
  _process_changed: function (msg, updates) {                                                                     // 1283
    var self = this;                                                                                              // 1284
    var serverDoc = self._getServerDoc(                                                                           // 1285
      msg.collection, LocalCollection._idParse(msg.id));                                                          // 1286
    if (serverDoc) {                                                                                              // 1287
      if (serverDoc.document === undefined)                                                                       // 1288
        throw new Error("Server sent changed for nonexisting id: " + msg.id);                                     // 1289
      LocalCollection._applyChanges(serverDoc.document, msg.fields);                                              // 1290
    } else {                                                                                                      // 1291
      self._pushUpdate(updates, msg.collection, msg);                                                             // 1292
    }                                                                                                             // 1293
  },                                                                                                              // 1294
                                                                                                                  // 1295
  _process_removed: function (msg, updates) {                                                                     // 1296
    var self = this;                                                                                              // 1297
    var serverDoc = self._getServerDoc(                                                                           // 1298
      msg.collection, LocalCollection._idParse(msg.id));                                                          // 1299
    if (serverDoc) {                                                                                              // 1300
      // Some outstanding stub wrote here.                                                                        // 1301
      if (serverDoc.document === undefined)                                                                       // 1302
        throw new Error("Server sent removed for nonexisting id:" + msg.id);                                      // 1303
      serverDoc.document = undefined;                                                                             // 1304
    } else {                                                                                                      // 1305
      self._pushUpdate(updates, msg.collection, {                                                                 // 1306
        msg: 'removed',                                                                                           // 1307
        collection: msg.collection,                                                                               // 1308
        id: msg.id                                                                                                // 1309
      });                                                                                                         // 1310
    }                                                                                                             // 1311
  },                                                                                                              // 1312
                                                                                                                  // 1313
  _process_updated: function (msg, updates) {                                                                     // 1314
    var self = this;                                                                                              // 1315
    // Process "method done" messages.                                                                            // 1316
    _.each(msg.methods, function (methodId) {                                                                     // 1317
      _.each(self._documentsWrittenByStub[methodId], function (written) {                                         // 1318
        var serverDoc = self._getServerDoc(written.collection, written.id);                                       // 1319
        if (!serverDoc)                                                                                           // 1320
          throw new Error("Lost serverDoc for " + JSON.stringify(written));                                       // 1321
        if (!serverDoc.writtenByStubs[methodId])                                                                  // 1322
          throw new Error("Doc " + JSON.stringify(written) +                                                      // 1323
                          " not written by  method " + methodId);                                                 // 1324
        delete serverDoc.writtenByStubs[methodId];                                                                // 1325
        if (_.isEmpty(serverDoc.writtenByStubs)) {                                                                // 1326
          // All methods whose stubs wrote this method have completed! We can                                     // 1327
          // now copy the saved document to the database (reverting the stub's                                    // 1328
          // change if the server did not write to this object, or applying the                                   // 1329
          // server's writes if it did).                                                                          // 1330
                                                                                                                  // 1331
          // This is a fake ddp 'replace' message.  It's just for talking                                         // 1332
          // between livedata connections and minimongo.  (We have to stringify                                   // 1333
          // the ID because it's supposed to look like a wire message.)                                           // 1334
          self._pushUpdate(updates, written.collection, {                                                         // 1335
            msg: 'replace',                                                                                       // 1336
            id: LocalCollection._idStringify(written.id),                                                         // 1337
            replace: serverDoc.document                                                                           // 1338
          });                                                                                                     // 1339
          // Call all flush callbacks.                                                                            // 1340
          _.each(serverDoc.flushCallbacks, function (c) {                                                         // 1341
            c();                                                                                                  // 1342
          });                                                                                                     // 1343
                                                                                                                  // 1344
          // Delete this completed serverDocument. Don't bother to GC empty                                       // 1345
          // IdMaps inside self._serverDocuments, since there probably aren't                                     // 1346
          // many collections and they'll be written repeatedly.                                                  // 1347
          self._serverDocuments[written.collection].remove(written.id);                                           // 1348
        }                                                                                                         // 1349
      });                                                                                                         // 1350
      delete self._documentsWrittenByStub[methodId];                                                              // 1351
                                                                                                                  // 1352
      // We want to call the data-written callback, but we can't do so until all                                  // 1353
      // currently buffered messages are flushed.                                                                 // 1354
      var callbackInvoker = self._methodInvokers[methodId];                                                       // 1355
      if (!callbackInvoker)                                                                                       // 1356
        throw new Error("No callback invoker for method " + methodId);                                            // 1357
      self._runWhenAllServerDocsAreFlushed(                                                                       // 1358
        _.bind(callbackInvoker.dataVisible, callbackInvoker));                                                    // 1359
    });                                                                                                           // 1360
  },                                                                                                              // 1361
                                                                                                                  // 1362
  _process_ready: function (msg, updates) {                                                                       // 1363
    var self = this;                                                                                              // 1364
    // Process "sub ready" messages. "sub ready" messages don't take effect                                       // 1365
    // until all current server documents have been flushed to the local                                          // 1366
    // database. We can use a write fence to implement this.                                                      // 1367
    _.each(msg.subs, function (subId) {                                                                           // 1368
      self._runWhenAllServerDocsAreFlushed(function () {                                                          // 1369
        var subRecord = self._subscriptions[subId];                                                               // 1370
        // Did we already unsubscribe?                                                                            // 1371
        if (!subRecord)                                                                                           // 1372
          return;                                                                                                 // 1373
        // Did we already receive a ready message? (Oops!)                                                        // 1374
        if (subRecord.ready)                                                                                      // 1375
          return;                                                                                                 // 1376
        subRecord.readyCallback && subRecord.readyCallback();                                                     // 1377
        subRecord.ready = true;                                                                                   // 1378
        subRecord.readyDeps.changed();                                                                            // 1379
      });                                                                                                         // 1380
    });                                                                                                           // 1381
  },                                                                                                              // 1382
                                                                                                                  // 1383
  // Ensures that "f" will be called after all documents currently in                                             // 1384
  // _serverDocuments have been written to the local cache. f will not be called                                  // 1385
  // if the connection is lost before then!                                                                       // 1386
  _runWhenAllServerDocsAreFlushed: function (f) {                                                                 // 1387
    var self = this;                                                                                              // 1388
    var runFAfterUpdates = function () {                                                                          // 1389
      self._afterUpdateCallbacks.push(f);                                                                         // 1390
    };                                                                                                            // 1391
    var unflushedServerDocCount = 0;                                                                              // 1392
    var onServerDocFlush = function () {                                                                          // 1393
      --unflushedServerDocCount;                                                                                  // 1394
      if (unflushedServerDocCount === 0) {                                                                        // 1395
        // This was the last doc to flush! Arrange to run f after the updates                                     // 1396
        // have been applied.                                                                                     // 1397
        runFAfterUpdates();                                                                                       // 1398
      }                                                                                                           // 1399
    };                                                                                                            // 1400
    _.each(self._serverDocuments, function (collectionDocs) {                                                     // 1401
      collectionDocs.forEach(function (serverDoc) {                                                               // 1402
        var writtenByStubForAMethodWithSentMessage = _.any(                                                       // 1403
          serverDoc.writtenByStubs, function (dummy, methodId) {                                                  // 1404
            var invoker = self._methodInvokers[methodId];                                                         // 1405
            return invoker && invoker.sentMessage;                                                                // 1406
          });                                                                                                     // 1407
        if (writtenByStubForAMethodWithSentMessage) {                                                             // 1408
          ++unflushedServerDocCount;                                                                              // 1409
          serverDoc.flushCallbacks.push(onServerDocFlush);                                                        // 1410
        }                                                                                                         // 1411
      });                                                                                                         // 1412
    });                                                                                                           // 1413
    if (unflushedServerDocCount === 0) {                                                                          // 1414
      // There aren't any buffered docs --- we can call f as soon as the current                                  // 1415
      // round of updates is applied!                                                                             // 1416
      runFAfterUpdates();                                                                                         // 1417
    }                                                                                                             // 1418
  },                                                                                                              // 1419
                                                                                                                  // 1420
  _livedata_nosub: function (msg) {                                                                               // 1421
    var self = this;                                                                                              // 1422
                                                                                                                  // 1423
    // First pass it through _livedata_data, which only uses it to help get                                       // 1424
    // towards quiescence.                                                                                        // 1425
    self._livedata_data(msg);                                                                                     // 1426
                                                                                                                  // 1427
    // Do the rest of our processing immediately, with no                                                         // 1428
    // buffering-until-quiescence.                                                                                // 1429
                                                                                                                  // 1430
    // we weren't subbed anyway, or we initiated the unsub.                                                       // 1431
    if (!_.has(self._subscriptions, msg.id))                                                                      // 1432
      return;                                                                                                     // 1433
                                                                                                                  // 1434
    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                     // 1435
    var errorCallback = self._subscriptions[msg.id].errorCallback;                                                // 1436
    var stopCallback = self._subscriptions[msg.id].stopCallback;                                                  // 1437
                                                                                                                  // 1438
    self._subscriptions[msg.id].remove();                                                                         // 1439
                                                                                                                  // 1440
    var meteorErrorFromMsg = function (msgArg) {                                                                  // 1441
      return msgArg && msgArg.error && new Meteor.Error(                                                          // 1442
        msgArg.error.error, msgArg.error.reason, msgArg.error.details);                                           // 1443
    }                                                                                                             // 1444
                                                                                                                  // 1445
    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                     // 1446
    if (errorCallback && msg.error) {                                                                             // 1447
      errorCallback(meteorErrorFromMsg(msg));                                                                     // 1448
    }                                                                                                             // 1449
                                                                                                                  // 1450
    if (stopCallback) {                                                                                           // 1451
      stopCallback(meteorErrorFromMsg(msg));                                                                      // 1452
    }                                                                                                             // 1453
  },                                                                                                              // 1454
                                                                                                                  // 1455
  _process_nosub: function () {                                                                                   // 1456
    // This is called as part of the "buffer until quiescence" process, but                                       // 1457
    // nosub's effect is always immediate. It only goes in the buffer at all                                      // 1458
    // because it's possible for a nosub to be the thing that triggers                                            // 1459
    // quiescence, if we were waiting for a sub to be revived and it dies                                         // 1460
    // instead.                                                                                                   // 1461
  },                                                                                                              // 1462
                                                                                                                  // 1463
  _livedata_result: function (msg) {                                                                              // 1464
    // id, result or error. error has error (code), reason, details                                               // 1465
                                                                                                                  // 1466
    var self = this;                                                                                              // 1467
                                                                                                                  // 1468
    // find the outstanding request                                                                               // 1469
    // should be O(1) in nearly all realistic use cases                                                           // 1470
    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                               // 1471
      Meteor._debug("Received method result but no methods outstanding");                                         // 1472
      return;                                                                                                     // 1473
    }                                                                                                             // 1474
    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                            // 1475
    var m;                                                                                                        // 1476
    for (var i = 0; i < currentMethodBlock.length; i++) {                                                         // 1477
      m = currentMethodBlock[i];                                                                                  // 1478
      if (m.methodId === msg.id)                                                                                  // 1479
        break;                                                                                                    // 1480
    }                                                                                                             // 1481
                                                                                                                  // 1482
    if (!m) {                                                                                                     // 1483
      Meteor._debug("Can't match method response to original method call", msg);                                  // 1484
      return;                                                                                                     // 1485
    }                                                                                                             // 1486
                                                                                                                  // 1487
    // Remove from current method block. This may leave the block empty, but we                                   // 1488
    // don't move on to the next block until the callback has been delivered, in                                  // 1489
    // _outstandingMethodFinished.                                                                                // 1490
    currentMethodBlock.splice(i, 1);                                                                              // 1491
                                                                                                                  // 1492
    if (_.has(msg, 'error')) {                                                                                    // 1493
      m.receiveResult(new Meteor.Error(                                                                           // 1494
        msg.error.error, msg.error.reason,                                                                        // 1495
        msg.error.details));                                                                                      // 1496
    } else {                                                                                                      // 1497
      // msg.result may be undefined if the method didn't return a                                                // 1498
      // value                                                                                                    // 1499
      m.receiveResult(undefined, msg.result);                                                                     // 1500
    }                                                                                                             // 1501
  },                                                                                                              // 1502
                                                                                                                  // 1503
  // Called by MethodInvoker after a method's callback is invoked.  If this was                                   // 1504
  // the last outstanding method in the current block, runs the next block. If                                    // 1505
  // there are no more methods, consider accepting a hot code push.                                               // 1506
  _outstandingMethodFinished: function () {                                                                       // 1507
    var self = this;                                                                                              // 1508
    if (self._anyMethodsAreOutstanding())                                                                         // 1509
      return;                                                                                                     // 1510
                                                                                                                  // 1511
    // No methods are outstanding. This should mean that the first block of                                       // 1512
    // methods is empty. (Or it might not exist, if this was a method that                                        // 1513
    // half-finished before disconnect/reconnect.)                                                                // 1514
    if (! _.isEmpty(self._outstandingMethodBlocks)) {                                                             // 1515
      var firstBlock = self._outstandingMethodBlocks.shift();                                                     // 1516
      if (! _.isEmpty(firstBlock.methods))                                                                        // 1517
        throw new Error("No methods outstanding but nonempty block: " +                                           // 1518
                        JSON.stringify(firstBlock));                                                              // 1519
                                                                                                                  // 1520
      // Send the outstanding methods now in the first block.                                                     // 1521
      if (!_.isEmpty(self._outstandingMethodBlocks))                                                              // 1522
        self._sendOutstandingMethods();                                                                           // 1523
    }                                                                                                             // 1524
                                                                                                                  // 1525
    // Maybe accept a hot code push.                                                                              // 1526
    self._maybeMigrate();                                                                                         // 1527
  },                                                                                                              // 1528
                                                                                                                  // 1529
  // Sends messages for all the methods in the first block in                                                     // 1530
  // _outstandingMethodBlocks.                                                                                    // 1531
  _sendOutstandingMethods: function() {                                                                           // 1532
    var self = this;                                                                                              // 1533
    if (_.isEmpty(self._outstandingMethodBlocks))                                                                 // 1534
      return;                                                                                                     // 1535
    _.each(self._outstandingMethodBlocks[0].methods, function (m) {                                               // 1536
      m.sendMessage();                                                                                            // 1537
    });                                                                                                           // 1538
  },                                                                                                              // 1539
                                                                                                                  // 1540
  _livedata_error: function (msg) {                                                                               // 1541
    Meteor._debug("Received error from server: ", msg.reason);                                                    // 1542
    if (msg.offendingMessage)                                                                                     // 1543
      Meteor._debug("For: ", msg.offendingMessage);                                                               // 1544
  },                                                                                                              // 1545
                                                                                                                  // 1546
  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {                                              // 1547
    var self = this;                                                                                              // 1548
    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;                                               // 1549
    self._outstandingMethodBlocks = [];                                                                           // 1550
                                                                                                                  // 1551
    self.onReconnect();                                                                                           // 1552
                                                                                                                  // 1553
    if (_.isEmpty(oldOutstandingMethodBlocks))                                                                    // 1554
      return;                                                                                                     // 1555
                                                                                                                  // 1556
    // We have at least one block worth of old outstanding methods to try                                         // 1557
    // again. First: did onReconnect actually send anything? If not, we just                                      // 1558
    // restore all outstanding methods and run the first block.                                                   // 1559
    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                               // 1560
      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;                                                 // 1561
      self._sendOutstandingMethods();                                                                             // 1562
      return;                                                                                                     // 1563
    }                                                                                                             // 1564
                                                                                                                  // 1565
    // OK, there are blocks on both sides. Special case: merge the last block of                                  // 1566
    // the reconnect methods with the first block of the original methods, if                                     // 1567
    // neither of them are "wait" blocks.                                                                         // 1568
    if (!_.last(self._outstandingMethodBlocks).wait &&                                                            // 1569
        !oldOutstandingMethodBlocks[0].wait) {                                                                    // 1570
      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {                                                // 1571
        _.last(self._outstandingMethodBlocks).methods.push(m);                                                    // 1572
                                                                                                                  // 1573
        // If this "last block" is also the first block, send the message.                                        // 1574
        if (self._outstandingMethodBlocks.length === 1)                                                           // 1575
          m.sendMessage();                                                                                        // 1576
      });                                                                                                         // 1577
                                                                                                                  // 1578
      oldOutstandingMethodBlocks.shift();                                                                         // 1579
    }                                                                                                             // 1580
                                                                                                                  // 1581
    // Now add the rest of the original blocks on.                                                                // 1582
    _.each(oldOutstandingMethodBlocks, function (block) {                                                         // 1583
      self._outstandingMethodBlocks.push(block);                                                                  // 1584
    });                                                                                                           // 1585
  },                                                                                                              // 1586
                                                                                                                  // 1587
  // We can accept a hot code push if there are no methods in flight.                                             // 1588
  _readyToMigrate: function() {                                                                                   // 1589
    var self = this;                                                                                              // 1590
    return _.isEmpty(self._methodInvokers);                                                                       // 1591
  },                                                                                                              // 1592
                                                                                                                  // 1593
  // If we were blocking a migration, see if it's now possible to continue.                                       // 1594
  // Call whenever the set of outstanding/blocked methods shrinks.                                                // 1595
  _maybeMigrate: function () {                                                                                    // 1596
    var self = this;                                                                                              // 1597
    if (self._retryMigrate && self._readyToMigrate()) {                                                           // 1598
      self._retryMigrate();                                                                                       // 1599
      self._retryMigrate = null;                                                                                  // 1600
    }                                                                                                             // 1601
  }                                                                                                               // 1602
});                                                                                                               // 1603
                                                                                                                  // 1604
LivedataTest.Connection = Connection;                                                                             // 1605
                                                                                                                  // 1606
// @param url {String} URL to Meteor app,                                                                         // 1607
//     e.g.:                                                                                                      // 1608
//     "subdomain.meteor.com",                                                                                    // 1609
//     "http://subdomain.meteor.com",                                                                             // 1610
//     "/",                                                                                                       // 1611
//     "ddp+sockjs://ddp--****-foo.meteor.com/sockjs"                                                             // 1612
                                                                                                                  // 1613
/**                                                                                                               // 1614
 * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.
 * @locus Anywhere                                                                                                // 1616
 * @param {String} url The URL of another Meteor application.                                                     // 1617
 */                                                                                                               // 1618
DDP.connect = function (url, options) {                                                                           // 1619
  var ret = new Connection(url, options);                                                                         // 1620
  allConnections.push(ret); // hack. see below.                                                                   // 1621
  return ret;                                                                                                     // 1622
};                                                                                                                // 1623
                                                                                                                  // 1624
// Hack for `spiderable` package: a way to see if the page is done                                                // 1625
// loading all the data it needs.                                                                                 // 1626
//                                                                                                                // 1627
allConnections = [];                                                                                              // 1628
DDP._allSubscriptionsReady = function () {                                                                        // 1629
  return _.all(allConnections, function (conn) {                                                                  // 1630
    return _.all(conn._subscriptions, function (sub) {                                                            // 1631
      return sub.ready;                                                                                           // 1632
    });                                                                                                           // 1633
  });                                                                                                             // 1634
};                                                                                                                // 1635
                                                                                                                  // 1636
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/ddp/client_convenience.js                                                                             //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// Meteor.refresh can be called on the client (if you're in common code) but it                                   // 1
// only has an effect on the server.                                                                              // 2
Meteor.refresh = function (notification) {                                                                        // 3
};                                                                                                                // 4
                                                                                                                  // 5
if (Meteor.isClient) {                                                                                            // 6
  // By default, try to connect back to the same endpoint as the page                                             // 7
  // was served from.                                                                                             // 8
  //                                                                                                              // 9
  // XXX We should be doing this a different way. Right now we don't                                              // 10
  // include ROOT_URL_PATH_PREFIX when computing ddpUrl. (We don't                                                // 11
  // include it on the server when computing                                                                      // 12
  // DDP_DEFAULT_CONNECTION_URL, and we don't include it in our                                                   // 13
  // default, '/'.) We get by with this because DDP.connect then                                                  // 14
  // forces the URL passed to it to be interpreted relative to the                                                // 15
  // app's deploy path, even if it is absolute. Instead, we should                                                // 16
  // make DDP_DEFAULT_CONNECTION_URL, if set, include the path prefix;                                            // 17
  // make the default ddpUrl be '' rather that '/'; and make                                                      // 18
  // _translateUrl in stream_client_common.js not force absolute paths                                            // 19
  // to be treated like relative paths. See also                                                                  // 20
  // stream_client_common.js #RationalizingRelativeDDPURLs                                                        // 21
  var ddpUrl = '/';                                                                                               // 22
  if (typeof __meteor_runtime_config__ !== "undefined") {                                                         // 23
    if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL)                                                     // 24
      ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;                                              // 25
  }                                                                                                               // 26
                                                                                                                  // 27
  var retry = new Retry();                                                                                        // 28
                                                                                                                  // 29
  var onDDPVersionNegotiationFailure = function (description) {                                                   // 30
    Meteor._debug(description);                                                                                   // 31
    if (Package.reload) {                                                                                         // 32
      var migrationData = Package.reload.Reload._migrationData('livedata') || {};                                 // 33
      var failures = migrationData.DDPVersionNegotiationFailures || 0;                                            // 34
      ++failures;                                                                                                 // 35
      Package.reload.Reload._onMigrate('livedata', function () {                                                  // 36
        return [true, {DDPVersionNegotiationFailures: failures}];                                                 // 37
      });                                                                                                         // 38
      retry.retryLater(failures, function () {                                                                    // 39
        Package.reload.Reload._reload();                                                                          // 40
      });                                                                                                         // 41
    }                                                                                                             // 42
  };                                                                                                              // 43
                                                                                                                  // 44
  Meteor.connection =                                                                                             // 45
    DDP.connect(ddpUrl, {                                                                                         // 46
      onDDPVersionNegotiationFailure: onDDPVersionNegotiationFailure                                              // 47
    });                                                                                                           // 48
                                                                                                                  // 49
  // Proxy the public methods of Meteor.connection so they can                                                    // 50
  // be called directly on Meteor.                                                                                // 51
  _.each(['subscribe', 'methods', 'call', 'apply', 'status', 'reconnect',                                         // 52
          'disconnect'],                                                                                          // 53
         function (name) {                                                                                        // 54
           Meteor[name] = _.bind(Meteor.connection[name], Meteor.connection);                                     // 55
         });                                                                                                      // 56
} else {                                                                                                          // 57
  // Never set up a default connection on the server. Don't even map                                              // 58
  // subscribe/call/etc onto Meteor.                                                                              // 59
  Meteor.connection = null;                                                                                       // 60
}                                                                                                                 // 61
                                                                                                                  // 62
// Meteor.connection used to be called                                                                            // 63
// Meteor.default_connection. Provide backcompat as a courtesy even                                               // 64
// though it was never documented.                                                                                // 65
// XXX COMPAT WITH 0.6.4                                                                                          // 66
Meteor.default_connection = Meteor.connection;                                                                    // 67
                                                                                                                  // 68
// We should transition from Meteor.connect to DDP.connect.                                                       // 69
// XXX COMPAT WITH 0.6.4                                                                                          // 70
Meteor.connect = DDP.connect;                                                                                     // 71
                                                                                                                  // 72
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.ddp = {
  DDP: DDP,
  LivedataTest: LivedataTest
};

})();
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var Random = Package.random.Random;
var EJSON = Package.ejson.EJSON;
var JSON = Package.json.JSON;
var _ = Package.underscore._;
var LocalCollection = Package.minimongo.LocalCollection;
var Minimongo = Package.minimongo.Minimongo;
var Log = Package.logging.Log;
var DDP = Package.ddp.DDP;
var Tracker = Package.tracker.Tracker;
var Deps = Package.tracker.Deps;
var check = Package.check.check;
var Match = Package.check.Match;

/* Package-scope variables */
var Mongo, LocalCollectionDriver;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
// packages/mongo/local_collection_driver.js                                                                          //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                      //
LocalCollectionDriver = function () {                                                                                 // 1
  var self = this;                                                                                                    // 2
  self.noConnCollections = {};                                                                                        // 3
};                                                                                                                    // 4
                                                                                                                      // 5
var ensureCollection = function (name, collections) {                                                                 // 6
  if (!(name in collections))                                                                                         // 7
    collections[name] = new LocalCollection(name);                                                                    // 8
  return collections[name];                                                                                           // 9
};                                                                                                                    // 10
                                                                                                                      // 11
_.extend(LocalCollectionDriver.prototype, {                                                                           // 12
  open: function (name, conn) {                                                                                       // 13
    var self = this;                                                                                                  // 14
    if (!name)                                                                                                        // 15
      return new LocalCollection;                                                                                     // 16
    if (! conn) {                                                                                                     // 17
      return ensureCollection(name, self.noConnCollections);                                                          // 18
    }                                                                                                                 // 19
    if (! conn._mongo_livedata_collections)                                                                           // 20
      conn._mongo_livedata_collections = {};                                                                          // 21
    // XXX is there a way to keep track of a connection's collections without                                         // 22
    // dangling it off the connection object?                                                                         // 23
    return ensureCollection(name, conn._mongo_livedata_collections);                                                  // 24
  }                                                                                                                   // 25
});                                                                                                                   // 26
                                                                                                                      // 27
// singleton                                                                                                          // 28
LocalCollectionDriver = new LocalCollectionDriver;                                                                    // 29
                                                                                                                      // 30
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                    //
// packages/mongo/collection.js                                                                                       //
//                                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                      //
// options.connection, if given, is a LivedataClient or LivedataServer                                                // 1
// XXX presently there is no way to destroy/clean up a Collection                                                     // 2
                                                                                                                      // 3
/**                                                                                                                   // 4
 * @summary Namespace for MongoDB-related items                                                                       // 5
 * @namespace                                                                                                         // 6
 */                                                                                                                   // 7
Mongo = {};                                                                                                           // 8
                                                                                                                      // 9
/**                                                                                                                   // 10
 * @summary Constructor for a Collection                                                                              // 11
 * @locus Anywhere                                                                                                    // 12
 * @instancename collection                                                                                           // 13
 * @class                                                                                                             // 14
 * @param {String} name The name of the collection.  If null, creates an unmanaged (unsynchronized) local collection. // 15
 * @param {Object} [options]                                                                                          // 16
 * @param {Object} options.connection The server connection that will manage this collection. Uses the default connection if not specified.  Pass the return value of calling [`DDP.connect`](#ddp_connect) to specify a different server. Pass `null` to specify no connection. Unmanaged (`name` is null) collections cannot specify a connection.
 * @param {String} options.idGeneration The method of generating the `_id` fields of new documents in this collection.  Possible values:
                                                                                                                      // 19
 - **`'STRING'`**: random strings                                                                                     // 20
 - **`'MONGO'`**:  random [`Mongo.ObjectID`](#mongo_object_id) values                                                 // 21
                                                                                                                      // 22
The default id generation technique is `'STRING'`.                                                                    // 23
 * @param {Function} options.transform An optional transformation function. Documents will be passed through this function before being returned from `fetch` or `findOne`, and before being passed to callbacks of `observe`, `map`, `forEach`, `allow`, and `deny`. Transforms are *not* applied for the callbacks of `observeChanges` or to cursors returned from publish functions.
 */                                                                                                                   // 25
Mongo.Collection = function (name, options) {                                                                         // 26
  var self = this;                                                                                                    // 27
  if (! (self instanceof Mongo.Collection))                                                                           // 28
    throw new Error('use "new" to construct a Mongo.Collection');                                                     // 29
                                                                                                                      // 30
  if (!name && (name !== null)) {                                                                                     // 31
    Meteor._debug("Warning: creating anonymous collection. It will not be " +                                         // 32
                  "saved or synchronized over the network. (Pass null for " +                                         // 33
                  "the collection name to turn off this warning.)");                                                  // 34
    name = null;                                                                                                      // 35
  }                                                                                                                   // 36
                                                                                                                      // 37
  if (name !== null && typeof name !== "string") {                                                                    // 38
    throw new Error(                                                                                                  // 39
      "First argument to new Mongo.Collection must be a string or null");                                             // 40
  }                                                                                                                   // 41
                                                                                                                      // 42
  if (options && options.methods) {                                                                                   // 43
    // Backwards compatibility hack with original signature (which passed                                             // 44
    // "connection" directly instead of in options. (Connections must have a "methods"                                // 45
    // method.)                                                                                                       // 46
    // XXX remove before 1.0                                                                                          // 47
    options = {connection: options};                                                                                  // 48
  }                                                                                                                   // 49
  // Backwards compatibility: "connection" used to be called "manager".                                               // 50
  if (options && options.manager && !options.connection) {                                                            // 51
    options.connection = options.manager;                                                                             // 52
  }                                                                                                                   // 53
  options = _.extend({                                                                                                // 54
    connection: undefined,                                                                                            // 55
    idGeneration: 'STRING',                                                                                           // 56
    transform: null,                                                                                                  // 57
    _driver: undefined,                                                                                               // 58
    _preventAutopublish: false                                                                                        // 59
  }, options);                                                                                                        // 60
                                                                                                                      // 61
  switch (options.idGeneration) {                                                                                     // 62
  case 'MONGO':                                                                                                       // 63
    self._makeNewID = function () {                                                                                   // 64
      var src = name ? DDP.randomStream('/collection/' + name) : Random;                                              // 65
      return new Mongo.ObjectID(src.hexString(24));                                                                   // 66
    };                                                                                                                // 67
    break;                                                                                                            // 68
  case 'STRING':                                                                                                      // 69
  default:                                                                                                            // 70
    self._makeNewID = function () {                                                                                   // 71
      var src = name ? DDP.randomStream('/collection/' + name) : Random;                                              // 72
      return src.id();                                                                                                // 73
    };                                                                                                                // 74
    break;                                                                                                            // 75
  }                                                                                                                   // 76
                                                                                                                      // 77
  self._transform = LocalCollection.wrapTransform(options.transform);                                                 // 78
                                                                                                                      // 79
  if (! name || options.connection === null)                                                                          // 80
    // note: nameless collections never have a connection                                                             // 81
    self._connection = null;                                                                                          // 82
  else if (options.connection)                                                                                        // 83
    self._connection = options.connection;                                                                            // 84
  else if (Meteor.isClient)                                                                                           // 85
    self._connection = Meteor.connection;                                                                             // 86
  else                                                                                                                // 87
    self._connection = Meteor.server;                                                                                 // 88
                                                                                                                      // 89
  if (!options._driver) {                                                                                             // 90
    // XXX This check assumes that webapp is loaded so that Meteor.server !==                                         // 91
    // null. We should fully support the case of "want to use a Mongo-backed                                          // 92
    // collection from Node code without webapp", but we don't yet.                                                   // 93
    // #MeteorServerNull                                                                                              // 94
    if (name && self._connection === Meteor.server &&                                                                 // 95
        typeof MongoInternals !== "undefined" &&                                                                      // 96
        MongoInternals.defaultRemoteCollectionDriver) {                                                               // 97
      options._driver = MongoInternals.defaultRemoteCollectionDriver();                                               // 98
    } else {                                                                                                          // 99
      options._driver = LocalCollectionDriver;                                                                        // 100
    }                                                                                                                 // 101
  }                                                                                                                   // 102
                                                                                                                      // 103
  self._collection = options._driver.open(name, self._connection);                                                    // 104
  self._name = name;                                                                                                  // 105
  self._driver = options._driver;                                                                                     // 106
                                                                                                                      // 107
  if (self._connection && self._connection.registerStore) {                                                           // 108
    // OK, we're going to be a slave, replicating some remote                                                         // 109
    // database, except possibly with some temporary divergence while                                                 // 110
    // we have unacknowledged RPC's.                                                                                  // 111
    var ok = self._connection.registerStore(name, {                                                                   // 112
      // Called at the beginning of a batch of updates. batchSize is the number                                       // 113
      // of update calls to expect.                                                                                   // 114
      //                                                                                                              // 115
      // XXX This interface is pretty janky. reset probably ought to go back to                                       // 116
      // being its own function, and callers shouldn't have to calculate                                              // 117
      // batchSize. The optimization of not calling pause/remove should be                                            // 118
      // delayed until later: the first call to update() should buffer its                                            // 119
      // message, and then we can either directly apply it at endUpdate time if                                       // 120
      // it was the only update, or do pauseObservers/apply/apply at the next                                         // 121
      // update() if there's another one.                                                                             // 122
      beginUpdate: function (batchSize, reset) {                                                                      // 123
        // pause observers so users don't see flicker when updating several                                           // 124
        // objects at once (including the post-reconnect reset-and-reapply                                            // 125
        // stage), and so that a re-sorting of a query can take advantage of the                                      // 126
        // full _diffQuery moved calculation instead of applying change one at a                                      // 127
        // time.                                                                                                      // 128
        if (batchSize > 1 || reset)                                                                                   // 129
          self._collection.pauseObservers();                                                                          // 130
                                                                                                                      // 131
        if (reset)                                                                                                    // 132
          self._collection.remove({});                                                                                // 133
      },                                                                                                              // 134
                                                                                                                      // 135
      // Apply an update.                                                                                             // 136
      // XXX better specify this interface (not in terms of a wire message)?                                          // 137
      update: function (msg) {                                                                                        // 138
        var mongoId = LocalCollection._idParse(msg.id);                                                               // 139
        var doc = self._collection.findOne(mongoId);                                                                  // 140
                                                                                                                      // 141
        // Is this a "replace the whole doc" message coming from the quiescence                                       // 142
        // of method writes to an object? (Note that 'undefined' is a valid                                           // 143
        // value meaning "remove it".)                                                                                // 144
        if (msg.msg === 'replace') {                                                                                  // 145
          var replace = msg.replace;                                                                                  // 146
          if (!replace) {                                                                                             // 147
            if (doc)                                                                                                  // 148
              self._collection.remove(mongoId);                                                                       // 149
          } else if (!doc) {                                                                                          // 150
            self._collection.insert(replace);                                                                         // 151
          } else {                                                                                                    // 152
            // XXX check that replace has no $ ops                                                                    // 153
            self._collection.update(mongoId, replace);                                                                // 154
          }                                                                                                           // 155
          return;                                                                                                     // 156
        } else if (msg.msg === 'added') {                                                                             // 157
          if (doc) {                                                                                                  // 158
            throw new Error("Expected not to find a document already present for an add");                            // 159
          }                                                                                                           // 160
          self._collection.insert(_.extend({_id: mongoId}, msg.fields));                                              // 161
        } else if (msg.msg === 'removed') {                                                                           // 162
          if (!doc)                                                                                                   // 163
            throw new Error("Expected to find a document already present for removed");                               // 164
          self._collection.remove(mongoId);                                                                           // 165
        } else if (msg.msg === 'changed') {                                                                           // 166
          if (!doc)                                                                                                   // 167
            throw new Error("Expected to find a document to change");                                                 // 168
          if (!_.isEmpty(msg.fields)) {                                                                               // 169
            var modifier = {};                                                                                        // 170
            _.each(msg.fields, function (value, key) {                                                                // 171
              if (value === undefined) {                                                                              // 172
                if (!modifier.$unset)                                                                                 // 173
                  modifier.$unset = {};                                                                               // 174
                modifier.$unset[key] = 1;                                                                             // 175
              } else {                                                                                                // 176
                if (!modifier.$set)                                                                                   // 177
                  modifier.$set = {};                                                                                 // 178
                modifier.$set[key] = value;                                                                           // 179
              }                                                                                                       // 180
            });                                                                                                       // 181
            self._collection.update(mongoId, modifier);                                                               // 182
          }                                                                                                           // 183
        } else {                                                                                                      // 184
          throw new Error("I don't know how to deal with this message");                                              // 185
        }                                                                                                             // 186
                                                                                                                      // 187
      },                                                                                                              // 188
                                                                                                                      // 189
      // Called at the end of a batch of updates.                                                                     // 190
      endUpdate: function () {                                                                                        // 191
        self._collection.resumeObservers();                                                                           // 192
      },                                                                                                              // 193
                                                                                                                      // 194
      // Called around method stub invocations to capture the original versions                                       // 195
      // of modified documents.                                                                                       // 196
      saveOriginals: function () {                                                                                    // 197
        self._collection.saveOriginals();                                                                             // 198
      },                                                                                                              // 199
      retrieveOriginals: function () {                                                                                // 200
        return self._collection.retrieveOriginals();                                                                  // 201
      }                                                                                                               // 202
    });                                                                                                               // 203
                                                                                                                      // 204
    if (!ok)                                                                                                          // 205
      throw new Error("There is already a collection named '" + name + "'");                                          // 206
  }                                                                                                                   // 207
                                                                                                                      // 208
  self._defineMutationMethods();                                                                                      // 209
                                                                                                                      // 210
  // autopublish                                                                                                      // 211
  if (Package.autopublish && !options._preventAutopublish && self._connection                                         // 212
      && self._connection.publish) {                                                                                  // 213
    self._connection.publish(null, function () {                                                                      // 214
      return self.find();                                                                                             // 215
    }, {is_auto: true});                                                                                              // 216
  }                                                                                                                   // 217
};                                                                                                                    // 218
                                                                                                                      // 219
///                                                                                                                   // 220
/// Main collection API                                                                                               // 221
///                                                                                                                   // 222
                                                                                                                      // 223
                                                                                                                      // 224
_.extend(Mongo.Collection.prototype, {                                                                                // 225
                                                                                                                      // 226
  _getFindSelector: function (args) {                                                                                 // 227
    if (args.length == 0)                                                                                             // 228
      return {};                                                                                                      // 229
    else                                                                                                              // 230
      return args[0];                                                                                                 // 231
  },                                                                                                                  // 232
                                                                                                                      // 233
  _getFindOptions: function (args) {                                                                                  // 234
    var self = this;                                                                                                  // 235
    if (args.length < 2) {                                                                                            // 236
      return { transform: self._transform };                                                                          // 237
    } else {                                                                                                          // 238
      check(args[1], Match.Optional(Match.ObjectIncluding({                                                           // 239
        fields: Match.Optional(Match.OneOf(Object, undefined)),                                                       // 240
        sort: Match.Optional(Match.OneOf(Object, Array, undefined)),                                                  // 241
        limit: Match.Optional(Match.OneOf(Number, undefined)),                                                        // 242
        skip: Match.Optional(Match.OneOf(Number, undefined))                                                          // 243
     })));                                                                                                            // 244
                                                                                                                      // 245
      return _.extend({                                                                                               // 246
        transform: self._transform                                                                                    // 247
      }, args[1]);                                                                                                    // 248
    }                                                                                                                 // 249
  },                                                                                                                  // 250
                                                                                                                      // 251
  /**                                                                                                                 // 252
   * @summary Find the documents in a collection that match the selector.                                             // 253
   * @locus Anywhere                                                                                                  // 254
   * @method find                                                                                                     // 255
   * @memberOf Mongo.Collection                                                                                       // 256
   * @instance                                                                                                        // 257
   * @param {MongoSelector} [selector] A query describing the documents to find                                       // 258
   * @param {Object} [options]                                                                                        // 259
   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)                                     // 260
   * @param {Number} options.skip Number of results to skip at the beginning                                          // 261
   * @param {Number} options.limit Maximum number of results to return                                                // 262
   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.                           // 263
   * @param {Boolean} options.reactive (Client only) Default `true`; pass `false` to disable reactivity               // 264
   * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.
   * @returns {Mongo.Cursor}                                                                                          // 266
   */                                                                                                                 // 267
  find: function (/* selector, options */) {                                                                          // 268
    // Collection.find() (return all docs) behaves differently                                                        // 269
    // from Collection.find(undefined) (return 0 docs).  so be                                                        // 270
    // careful about the length of arguments.                                                                         // 271
    var self = this;                                                                                                  // 272
    var argArray = _.toArray(arguments);                                                                              // 273
    return self._collection.find(self._getFindSelector(argArray),                                                     // 274
                                 self._getFindOptions(argArray));                                                     // 275
  },                                                                                                                  // 276
                                                                                                                      // 277
  /**                                                                                                                 // 278
   * @summary Finds the first document that matches the selector, as ordered by sort and skip options.                // 279
   * @locus Anywhere                                                                                                  // 280
   * @method findOne                                                                                                  // 281
   * @memberOf Mongo.Collection                                                                                       // 282
   * @instance                                                                                                        // 283
   * @param {MongoSelector} [selector] A query describing the documents to find                                       // 284
   * @param {Object} [options]                                                                                        // 285
   * @param {MongoSortSpecifier} options.sort Sort order (default: natural order)                                     // 286
   * @param {Number} options.skip Number of results to skip at the beginning                                          // 287
   * @param {MongoFieldSpecifier} options.fields Dictionary of fields to return or exclude.                           // 288
   * @param {Boolean} options.reactive (Client only) Default true; pass false to disable reactivity                   // 289
   * @param {Function} options.transform Overrides `transform` on the [`Collection`](#collections) for this cursor.  Pass `null` to disable transformation.
   * @returns {Object}                                                                                                // 291
   */                                                                                                                 // 292
  findOne: function (/* selector, options */) {                                                                       // 293
    var self = this;                                                                                                  // 294
    var argArray = _.toArray(arguments);                                                                              // 295
    return self._collection.findOne(self._getFindSelector(argArray),                                                  // 296
                                    self._getFindOptions(argArray));                                                  // 297
  }                                                                                                                   // 298
                                                                                                                      // 299
});                                                                                                                   // 300
                                                                                                                      // 301
Mongo.Collection._publishCursor = function (cursor, sub, collection) {                                                // 302
  var observeHandle = cursor.observeChanges({                                                                         // 303
    added: function (id, fields) {                                                                                    // 304
      sub.added(collection, id, fields);                                                                              // 305
    },                                                                                                                // 306
    changed: function (id, fields) {                                                                                  // 307
      sub.changed(collection, id, fields);                                                                            // 308
    },                                                                                                                // 309
    removed: function (id) {                                                                                          // 310
      sub.removed(collection, id);                                                                                    // 311
    }                                                                                                                 // 312
  });                                                                                                                 // 313
                                                                                                                      // 314
  // We don't call sub.ready() here: it gets called in livedata_server, after                                         // 315
  // possibly calling _publishCursor on multiple returned cursors.                                                    // 316
                                                                                                                      // 317
  // register stop callback (expects lambda w/ no args).                                                              // 318
  sub.onStop(function () {observeHandle.stop();});                                                                    // 319
};                                                                                                                    // 320
                                                                                                                      // 321
// protect against dangerous selectors.  falsey and {_id: falsey} are both                                            // 322
// likely programmer error, and not what you want, particularly for destructive                                       // 323
// operations.  JS regexps don't serialize over DDP but can be trivially                                              // 324
// replaced by $regex.                                                                                                // 325
Mongo.Collection._rewriteSelector = function (selector) {                                                             // 326
  // shorthand -- scalars match _id                                                                                   // 327
  if (LocalCollection._selectorIsId(selector))                                                                        // 328
    selector = {_id: selector};                                                                                       // 329
                                                                                                                      // 330
  if (!selector || (('_id' in selector) && !selector._id))                                                            // 331
    // can't match anything                                                                                           // 332
    return {_id: Random.id()};                                                                                        // 333
                                                                                                                      // 334
  var ret = {};                                                                                                       // 335
  _.each(selector, function (value, key) {                                                                            // 336
    // Mongo supports both {field: /foo/} and {field: {$regex: /foo/}}                                                // 337
    if (value instanceof RegExp) {                                                                                    // 338
      ret[key] = convertRegexpToMongoSelector(value);                                                                 // 339
    } else if (value && value.$regex instanceof RegExp) {                                                             // 340
      ret[key] = convertRegexpToMongoSelector(value.$regex);                                                          // 341
      // if value is {$regex: /foo/, $options: ...} then $options                                                     // 342
      // override the ones set on $regex.                                                                             // 343
      if (value.$options !== undefined)                                                                               // 344
        ret[key].$options = value.$options;                                                                           // 345
    }                                                                                                                 // 346
    else if (_.contains(['$or','$and','$nor'], key)) {                                                                // 347
      // Translate lower levels of $and/$or/$nor                                                                      // 348
      ret[key] = _.map(value, function (v) {                                                                          // 349
        return Mongo.Collection._rewriteSelector(v);                                                                  // 350
      });                                                                                                             // 351
    } else {                                                                                                          // 352
      ret[key] = value;                                                                                               // 353
    }                                                                                                                 // 354
  });                                                                                                                 // 355
  return ret;                                                                                                         // 356
};                                                                                                                    // 357
                                                                                                                      // 358
// convert a JS RegExp object to a Mongo {$regex: ..., $options: ...}                                                 // 359
// selector                                                                                                           // 360
var convertRegexpToMongoSelector = function (regexp) {                                                                // 361
  check(regexp, RegExp); // safety belt                                                                               // 362
                                                                                                                      // 363
  var selector = {$regex: regexp.source};                                                                             // 364
  var regexOptions = '';                                                                                              // 365
  // JS RegExp objects support 'i', 'm', and 'g'. Mongo regex $options                                                // 366
  // support 'i', 'm', 'x', and 's'. So we support 'i' and 'm' here.                                                  // 367
  if (regexp.ignoreCase)                                                                                              // 368
    regexOptions += 'i';                                                                                              // 369
  if (regexp.multiline)                                                                                               // 370
    regexOptions += 'm';                                                                                              // 371
  if (regexOptions)                                                                                                   // 372
    selector.$options = regexOptions;                                                                                 // 373
                                                                                                                      // 374
  return selector;                                                                                                    // 375
};                                                                                                                    // 376
                                                                                                                      // 377
var throwIfSelectorIsNotId = function (selector, methodName) {                                                        // 378
  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {                                                      // 379
    throw new Meteor.Error(                                                                                           // 380
      403, "Not permitted. Untrusted code may only " + methodName +                                                   // 381
        " documents by ID.");                                                                                         // 382
  }                                                                                                                   // 383
};                                                                                                                    // 384
                                                                                                                      // 385
// 'insert' immediately returns the inserted document's new _id.                                                      // 386
// The others return values immediately if you are in a stub, an in-memory                                            // 387
// unmanaged collection, or a mongo-backed collection and you don't pass a                                            // 388
// callback. 'update' and 'remove' return the number of affected                                                      // 389
// documents. 'upsert' returns an object with keys 'numberAffected' and, if an                                        // 390
// insert happened, 'insertedId'.                                                                                     // 391
//                                                                                                                    // 392
// Otherwise, the semantics are exactly like other methods: they take                                                 // 393
// a callback as an optional last argument; if no callback is                                                         // 394
// provided, they block until the operation is complete, and throw an                                                 // 395
// exception if it fails; if a callback is provided, then they don't                                                  // 396
// necessarily block, and they call the callback when they finish with error and                                      // 397
// result arguments.  (The insert method provides the document ID as its result;                                      // 398
// update and remove provide the number of affected docs as the result; upsert                                        // 399
// provides an object with numberAffected and maybe insertedId.)                                                      // 400
//                                                                                                                    // 401
// On the client, blocking is impossible, so if a callback                                                            // 402
// isn't provided, they just return immediately and any error                                                         // 403
// information is lost.                                                                                               // 404
//                                                                                                                    // 405
// There's one more tweak. On the client, if you don't provide a                                                      // 406
// callback, then if there is an error, a message will be logged with                                                 // 407
// Meteor._debug.                                                                                                     // 408
//                                                                                                                    // 409
// The intent (though this is actually determined by the underlying                                                   // 410
// drivers) is that the operations should be done synchronously, not                                                  // 411
// generating their result until the database has acknowledged                                                        // 412
// them. In the future maybe we should provide a flag to turn this                                                    // 413
// off.                                                                                                               // 414
                                                                                                                      // 415
/**                                                                                                                   // 416
 * @summary Insert a document in the collection.  Returns its unique _id.                                             // 417
 * @locus Anywhere                                                                                                    // 418
 * @method  insert                                                                                                    // 419
 * @memberOf Mongo.Collection                                                                                         // 420
 * @instance                                                                                                          // 421
 * @param {Object} doc The document to insert. May not yet have an _id attribute, in which case Meteor will generate one for you.
 * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the _id as the second.
 */                                                                                                                   // 424
                                                                                                                      // 425
/**                                                                                                                   // 426
 * @summary Modify one or more documents in the collection. Returns the number of affected documents.                 // 427
 * @locus Anywhere                                                                                                    // 428
 * @method update                                                                                                     // 429
 * @memberOf Mongo.Collection                                                                                         // 430
 * @instance                                                                                                          // 431
 * @param {MongoSelector} selector Specifies which documents to modify                                                // 432
 * @param {MongoModifier} modifier Specifies how to modify the documents                                              // 433
 * @param {Object} [options]                                                                                          // 434
 * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).
 * @param {Boolean} options.upsert True to insert a document if no matching documents are found.                      // 436
 * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.
 */                                                                                                                   // 438
                                                                                                                      // 439
/**                                                                                                                   // 440
 * @summary Remove documents from the collection                                                                      // 441
 * @locus Anywhere                                                                                                    // 442
 * @method remove                                                                                                     // 443
 * @memberOf Mongo.Collection                                                                                         // 444
 * @instance                                                                                                          // 445
 * @param {MongoSelector} selector Specifies which documents to remove                                                // 446
 * @param {Function} [callback] Optional.  If present, called with an error object as its argument.                   // 447
 */                                                                                                                   // 448
                                                                                                                      // 449
_.each(["insert", "update", "remove"], function (name) {                                                              // 450
  Mongo.Collection.prototype[name] = function (/* arguments */) {                                                     // 451
    var self = this;                                                                                                  // 452
    var args = _.toArray(arguments);                                                                                  // 453
    var callback;                                                                                                     // 454
    var insertId;                                                                                                     // 455
    var ret;                                                                                                          // 456
                                                                                                                      // 457
    // Pull off any callback (or perhaps a 'callback' variable that was passed                                        // 458
    // in undefined, like how 'upsert' does it).                                                                      // 459
    if (args.length &&                                                                                                // 460
        (args[args.length - 1] === undefined ||                                                                       // 461
         args[args.length - 1] instanceof Function)) {                                                                // 462
      callback = args.pop();                                                                                          // 463
    }                                                                                                                 // 464
                                                                                                                      // 465
    if (name === "insert") {                                                                                          // 466
      if (!args.length)                                                                                               // 467
        throw new Error("insert requires an argument");                                                               // 468
      // shallow-copy the document and generate an ID                                                                 // 469
      args[0] = _.extend({}, args[0]);                                                                                // 470
      if ('_id' in args[0]) {                                                                                         // 471
        insertId = args[0]._id;                                                                                       // 472
        if (!insertId || !(typeof insertId === 'string'                                                               // 473
              || insertId instanceof Mongo.ObjectID))                                                                 // 474
          throw new Error("Meteor requires document _id fields to be non-empty strings or ObjectIDs");                // 475
      } else {                                                                                                        // 476
        var generateId = true;                                                                                        // 477
        // Don't generate the id if we're the client and the 'outermost' call                                         // 478
        // This optimization saves us passing both the randomSeed and the id                                          // 479
        // Passing both is redundant.                                                                                 // 480
        if (self._connection && self._connection !== Meteor.server) {                                                 // 481
          var enclosing = DDP._CurrentInvocation.get();                                                               // 482
          if (!enclosing) {                                                                                           // 483
            generateId = false;                                                                                       // 484
          }                                                                                                           // 485
        }                                                                                                             // 486
        if (generateId) {                                                                                             // 487
          insertId = args[0]._id = self._makeNewID();                                                                 // 488
        }                                                                                                             // 489
      }                                                                                                               // 490
    } else {                                                                                                          // 491
      args[0] = Mongo.Collection._rewriteSelector(args[0]);                                                           // 492
                                                                                                                      // 493
      if (name === "update") {                                                                                        // 494
        // Mutate args but copy the original options object. We need to add                                           // 495
        // insertedId to options, but don't want to mutate the caller's options                                       // 496
        // object. We need to mutate `args` because we pass `args` into the                                           // 497
        // driver below.                                                                                              // 498
        var options = args[2] = _.clone(args[2]) || {};                                                               // 499
        if (options && typeof options !== "function" && options.upsert) {                                             // 500
          // set `insertedId` if absent.  `insertedId` is a Meteor extension.                                         // 501
          if (options.insertedId) {                                                                                   // 502
            if (!(typeof options.insertedId === 'string'                                                              // 503
                  || options.insertedId instanceof Mongo.ObjectID))                                                   // 504
              throw new Error("insertedId must be string or ObjectID");                                               // 505
          } else if (! args[0]._id) {                                                                                 // 506
            options.insertedId = self._makeNewID();                                                                   // 507
          }                                                                                                           // 508
        }                                                                                                             // 509
      }                                                                                                               // 510
    }                                                                                                                 // 511
                                                                                                                      // 512
    // On inserts, always return the id that we generated; on all other                                               // 513
    // operations, just return the result from the collection.                                                        // 514
    var chooseReturnValueFromCollectionResult = function (result) {                                                   // 515
      if (name === "insert") {                                                                                        // 516
        if (!insertId && result) {                                                                                    // 517
          insertId = result;                                                                                          // 518
        }                                                                                                             // 519
        return insertId;                                                                                              // 520
      } else {                                                                                                        // 521
        return result;                                                                                                // 522
      }                                                                                                               // 523
    };                                                                                                                // 524
                                                                                                                      // 525
    var wrappedCallback;                                                                                              // 526
    if (callback) {                                                                                                   // 527
      wrappedCallback = function (error, result) {                                                                    // 528
        callback(error, ! error && chooseReturnValueFromCollectionResult(result));                                    // 529
      };                                                                                                              // 530
    }                                                                                                                 // 531
                                                                                                                      // 532
    // XXX see #MeteorServerNull                                                                                      // 533
    if (self._connection && self._connection !== Meteor.server) {                                                     // 534
      // just remote to another endpoint, propagate return value or                                                   // 535
      // exception.                                                                                                   // 536
                                                                                                                      // 537
      var enclosing = DDP._CurrentInvocation.get();                                                                   // 538
      var alreadyInSimulation = enclosing && enclosing.isSimulation;                                                  // 539
                                                                                                                      // 540
      if (Meteor.isClient && !wrappedCallback && ! alreadyInSimulation) {                                             // 541
        // Client can't block, so it can't report errors by exception,                                                // 542
        // only by callback. If they forget the callback, give them a                                                 // 543
        // default one that logs the error, so they aren't totally                                                    // 544
        // baffled if their writes don't work because their database is                                               // 545
        // down.                                                                                                      // 546
        // Don't give a default callback in simulation, because inside stubs we                                       // 547
        // want to return the results from the local collection immediately and                                       // 548
        // not force a callback.                                                                                      // 549
        wrappedCallback = function (err) {                                                                            // 550
          if (err)                                                                                                    // 551
            Meteor._debug(name + " failed: " + (err.reason || err.stack));                                            // 552
        };                                                                                                            // 553
      }                                                                                                               // 554
                                                                                                                      // 555
      if (!alreadyInSimulation && name !== "insert") {                                                                // 556
        // If we're about to actually send an RPC, we should throw an error if                                        // 557
        // this is a non-ID selector, because the mutation methods only allow                                         // 558
        // single-ID selectors. (If we don't throw here, we'll see flicker.)                                          // 559
        throwIfSelectorIsNotId(args[0], name);                                                                        // 560
      }                                                                                                               // 561
                                                                                                                      // 562
      ret = chooseReturnValueFromCollectionResult(                                                                    // 563
        self._connection.apply(self._prefix + name, args, {returnStubValue: true}, wrappedCallback)                   // 564
      );                                                                                                              // 565
                                                                                                                      // 566
    } else {                                                                                                          // 567
      // it's my collection.  descend into the collection object                                                      // 568
      // and propagate any exception.                                                                                 // 569
      args.push(wrappedCallback);                                                                                     // 570
      try {                                                                                                           // 571
        // If the user provided a callback and the collection implements this                                         // 572
        // operation asynchronously, then queryRet will be undefined, and the                                         // 573
        // result will be returned through the callback instead.                                                      // 574
        var queryRet = self._collection[name].apply(self._collection, args);                                          // 575
        ret = chooseReturnValueFromCollectionResult(queryRet);                                                        // 576
      } catch (e) {                                                                                                   // 577
        if (callback) {                                                                                               // 578
          callback(e);                                                                                                // 579
          return null;                                                                                                // 580
        }                                                                                                             // 581
        throw e;                                                                                                      // 582
      }                                                                                                               // 583
    }                                                                                                                 // 584
                                                                                                                      // 585
    // both sync and async, unless we threw an exception, return ret                                                  // 586
    // (new document ID for insert, num affected for update/remove, object with                                       // 587
    // numberAffected and maybe insertedId for upsert).                                                               // 588
    return ret;                                                                                                       // 589
  };                                                                                                                  // 590
});                                                                                                                   // 591
                                                                                                                      // 592
/**                                                                                                                   // 593
 * @summary Modify one or more documents in the collection, or insert one if no matching documents were found. Returns an object with keys `numberAffected` (the number of documents modified)  and `insertedId` (the unique _id of the document that was inserted, if any).
 * @locus Anywhere                                                                                                    // 595
 * @param {MongoSelector} selector Specifies which documents to modify                                                // 596
 * @param {MongoModifier} modifier Specifies how to modify the documents                                              // 597
 * @param {Object} [options]                                                                                          // 598
 * @param {Boolean} options.multi True to modify all matching documents; false to only modify one of the matching documents (the default).
 * @param {Function} [callback] Optional.  If present, called with an error object as the first argument and, if no error, the number of affected documents as the second.
 */                                                                                                                   // 601
Mongo.Collection.prototype.upsert = function (selector, modifier,                                                     // 602
                                               options, callback) {                                                   // 603
  var self = this;                                                                                                    // 604
  if (! callback && typeof options === "function") {                                                                  // 605
    callback = options;                                                                                               // 606
    options = {};                                                                                                     // 607
  }                                                                                                                   // 608
  return self.update(selector, modifier,                                                                              // 609
              _.extend({}, options, { _returnObject: true, upsert: true }),                                           // 610
              callback);                                                                                              // 611
};                                                                                                                    // 612
                                                                                                                      // 613
// We'll actually design an index API later. For now, we just pass through to                                         // 614
// Mongo's, but make it synchronous.                                                                                  // 615
Mongo.Collection.prototype._ensureIndex = function (index, options) {                                                 // 616
  var self = this;                                                                                                    // 617
  if (!self._collection._ensureIndex)                                                                                 // 618
    throw new Error("Can only call _ensureIndex on server collections");                                              // 619
  self._collection._ensureIndex(index, options);                                                                      // 620
};                                                                                                                    // 621
Mongo.Collection.prototype._dropIndex = function (index) {                                                            // 622
  var self = this;                                                                                                    // 623
  if (!self._collection._dropIndex)                                                                                   // 624
    throw new Error("Can only call _dropIndex on server collections");                                                // 625
  self._collection._dropIndex(index);                                                                                 // 626
};                                                                                                                    // 627
Mongo.Collection.prototype._dropCollection = function () {                                                            // 628
  var self = this;                                                                                                    // 629
  if (!self._collection.dropCollection)                                                                               // 630
    throw new Error("Can only call _dropCollection on server collections");                                           // 631
  self._collection.dropCollection();                                                                                  // 632
};                                                                                                                    // 633
Mongo.Collection.prototype._createCappedCollection = function (byteSize, maxDocuments) {                              // 634
  var self = this;                                                                                                    // 635
  if (!self._collection._createCappedCollection)                                                                      // 636
    throw new Error("Can only call _createCappedCollection on server collections");                                   // 637
  self._collection._createCappedCollection(byteSize, maxDocuments);                                                   // 638
};                                                                                                                    // 639
                                                                                                                      // 640
Mongo.Collection.prototype.rawCollection = function () {                                                              // 641
  var self = this;                                                                                                    // 642
  if (! self._collection.rawCollection) {                                                                             // 643
    throw new Error("Can only call rawCollection on server collections");                                             // 644
  }                                                                                                                   // 645
  return self._collection.rawCollection();                                                                            // 646
};                                                                                                                    // 647
                                                                                                                      // 648
Mongo.Collection.prototype.rawDatabase = function () {                                                                // 649
  var self = this;                                                                                                    // 650
  if (! (self._driver.mongo && self._driver.mongo.db)) {                                                              // 651
    throw new Error("Can only call rawDatabase on server collections");                                               // 652
  }                                                                                                                   // 653
  return self._driver.mongo.db;                                                                                       // 654
};                                                                                                                    // 655
                                                                                                                      // 656
                                                                                                                      // 657
/**                                                                                                                   // 658
 * @summary Create a Mongo-style `ObjectID`.  If you don't specify a `hexString`, the `ObjectID` will generated randomly (not using MongoDB's ID construction rules).
 * @locus Anywhere                                                                                                    // 660
 * @class                                                                                                             // 661
 * @param {String} hexString Optional.  The 24-character hexadecimal contents of the ObjectID to create               // 662
 */                                                                                                                   // 663
Mongo.ObjectID = LocalCollection._ObjectID;                                                                           // 664
                                                                                                                      // 665
/**                                                                                                                   // 666
 * @summary To create a cursor, use find. To access the documents in a cursor, use forEach, map, or fetch.            // 667
 * @class                                                                                                             // 668
 * @instanceName cursor                                                                                               // 669
 */                                                                                                                   // 670
Mongo.Cursor = LocalCollection.Cursor;                                                                                // 671
                                                                                                                      // 672
/**                                                                                                                   // 673
 * @deprecated in 0.9.1                                                                                               // 674
 */                                                                                                                   // 675
Mongo.Collection.Cursor = Mongo.Cursor;                                                                               // 676
                                                                                                                      // 677
/**                                                                                                                   // 678
 * @deprecated in 0.9.1                                                                                               // 679
 */                                                                                                                   // 680
Mongo.Collection.ObjectID = Mongo.ObjectID;                                                                           // 681
                                                                                                                      // 682
///                                                                                                                   // 683
/// Remote methods and access control.                                                                                // 684
///                                                                                                                   // 685
                                                                                                                      // 686
// Restrict default mutators on collection. allow() and deny() take the                                               // 687
// same options:                                                                                                      // 688
//                                                                                                                    // 689
// options.insert {Function(userId, doc)}                                                                             // 690
//   return true to allow/deny adding this document                                                                   // 691
//                                                                                                                    // 692
// options.update {Function(userId, docs, fields, modifier)}                                                          // 693
//   return true to allow/deny updating these documents.                                                              // 694
//   `fields` is passed as an array of fields that are to be modified                                                 // 695
//                                                                                                                    // 696
// options.remove {Function(userId, docs)}                                                                            // 697
//   return true to allow/deny removing these documents                                                               // 698
//                                                                                                                    // 699
// options.fetch {Array}                                                                                              // 700
//   Fields to fetch for these validators. If any call to allow or deny                                               // 701
//   does not have this option then all fields are loaded.                                                            // 702
//                                                                                                                    // 703
// allow and deny can be called multiple times. The validators are                                                    // 704
// evaluated as follows:                                                                                              // 705
// - If neither deny() nor allow() has been called on the collection,                                                 // 706
//   then the request is allowed if and only if the "insecure" smart                                                  // 707
//   package is in use.                                                                                               // 708
// - Otherwise, if any deny() function returns true, the request is denied.                                           // 709
// - Otherwise, if any allow() function returns true, the request is allowed.                                         // 710
// - Otherwise, the request is denied.                                                                                // 711
//                                                                                                                    // 712
// Meteor may call your deny() and allow() functions in any order, and may not                                        // 713
// call all of them if it is able to make a decision without calling them all                                         // 714
// (so don't include side effects).                                                                                   // 715
                                                                                                                      // 716
(function () {                                                                                                        // 717
  var addValidator = function(allowOrDeny, options) {                                                                 // 718
    // validate keys                                                                                                  // 719
    var VALID_KEYS = ['insert', 'update', 'remove', 'fetch', 'transform'];                                            // 720
    _.each(_.keys(options), function (key) {                                                                          // 721
      if (!_.contains(VALID_KEYS, key))                                                                               // 722
        throw new Error(allowOrDeny + ": Invalid key: " + key);                                                       // 723
    });                                                                                                               // 724
                                                                                                                      // 725
    var self = this;                                                                                                  // 726
    self._restricted = true;                                                                                          // 727
                                                                                                                      // 728
    _.each(['insert', 'update', 'remove'], function (name) {                                                          // 729
      if (options[name]) {                                                                                            // 730
        if (!(options[name] instanceof Function)) {                                                                   // 731
          throw new Error(allowOrDeny + ": Value for `" + name + "` must be a function");                             // 732
        }                                                                                                             // 733
                                                                                                                      // 734
        // If the transform is specified at all (including as 'null') in this                                         // 735
        // call, then take that; otherwise, take the transform from the                                               // 736
        // collection.                                                                                                // 737
        if (options.transform === undefined) {                                                                        // 738
          options[name].transform = self._transform;  // already wrapped                                              // 739
        } else {                                                                                                      // 740
          options[name].transform = LocalCollection.wrapTransform(                                                    // 741
            options.transform);                                                                                       // 742
        }                                                                                                             // 743
                                                                                                                      // 744
        self._validators[name][allowOrDeny].push(options[name]);                                                      // 745
      }                                                                                                               // 746
    });                                                                                                               // 747
                                                                                                                      // 748
    // Only update the fetch fields if we're passed things that affect                                                // 749
    // fetching. This way allow({}) and allow({insert: f}) don't result in                                            // 750
    // setting fetchAllFields                                                                                         // 751
    if (options.update || options.remove || options.fetch) {                                                          // 752
      if (options.fetch && !(options.fetch instanceof Array)) {                                                       // 753
        throw new Error(allowOrDeny + ": Value for `fetch` must be an array");                                        // 754
      }                                                                                                               // 755
      self._updateFetch(options.fetch);                                                                               // 756
    }                                                                                                                 // 757
  };                                                                                                                  // 758
                                                                                                                      // 759
  /**                                                                                                                 // 760
   * @summary Allow users to write directly to this collection from client code, subject to limitations you define.   // 761
   * @locus Server                                                                                                    // 762
   * @param {Object} options                                                                                          // 763
   * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.
   * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.
   * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.
   */                                                                                                                 // 767
  Mongo.Collection.prototype.allow = function(options) {                                                              // 768
    addValidator.call(this, 'allow', options);                                                                        // 769
  };                                                                                                                  // 770
                                                                                                                      // 771
  /**                                                                                                                 // 772
   * @summary Override `allow` rules.                                                                                 // 773
   * @locus Server                                                                                                    // 774
   * @param {Object} options                                                                                          // 775
   * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.
   * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.
   * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.
   */                                                                                                                 // 779
  Mongo.Collection.prototype.deny = function(options) {                                                               // 780
    addValidator.call(this, 'deny', options);                                                                         // 781
  };                                                                                                                  // 782
})();                                                                                                                 // 783
                                                                                                                      // 784
                                                                                                                      // 785
Mongo.Collection.prototype._defineMutationMethods = function() {                                                      // 786
  var self = this;                                                                                                    // 787
                                                                                                                      // 788
  // set to true once we call any allow or deny methods. If true, use                                                 // 789
  // allow/deny semantics. If false, use insecure mode semantics.                                                     // 790
  self._restricted = false;                                                                                           // 791
                                                                                                                      // 792
  // Insecure mode (default to allowing writes). Defaults to 'undefined' which                                        // 793
  // means insecure iff the insecure package is loaded. This property can be                                          // 794
  // overriden by tests or packages wishing to change insecure mode behavior of                                       // 795
  // their collections.                                                                                               // 796
  self._insecure = undefined;                                                                                         // 797
                                                                                                                      // 798
  self._validators = {                                                                                                // 799
    insert: {allow: [], deny: []},                                                                                    // 800
    update: {allow: [], deny: []},                                                                                    // 801
    remove: {allow: [], deny: []},                                                                                    // 802
    upsert: {allow: [], deny: []}, // dummy arrays; can't set these!                                                  // 803
    fetch: [],                                                                                                        // 804
    fetchAllFields: false                                                                                             // 805
  };                                                                                                                  // 806
                                                                                                                      // 807
  if (!self._name)                                                                                                    // 808
    return; // anonymous collection                                                                                   // 809
                                                                                                                      // 810
  // XXX Think about method namespacing. Maybe methods should be                                                      // 811
  // "Meteor:Mongo:insert/NAME"?                                                                                      // 812
  self._prefix = '/' + self._name + '/';                                                                              // 813
                                                                                                                      // 814
  // mutation methods                                                                                                 // 815
  if (self._connection) {                                                                                             // 816
    var m = {};                                                                                                       // 817
                                                                                                                      // 818
    _.each(['insert', 'update', 'remove'], function (method) {                                                        // 819
      m[self._prefix + method] = function (/* ... */) {                                                               // 820
        // All the methods do their own validation, instead of using check().                                         // 821
        check(arguments, [Match.Any]);                                                                                // 822
        var args = _.toArray(arguments);                                                                              // 823
        try {                                                                                                         // 824
          // For an insert, if the client didn't specify an _id, generate one                                         // 825
          // now; because this uses DDP.randomStream, it will be consistent with                                      // 826
          // what the client generated. We generate it now rather than later so                                       // 827
          // that if (eg) an allow/deny rule does an insert to the same                                               // 828
          // collection (not that it really should), the generated _id will                                           // 829
          // still be the first use of the stream and will be consistent.                                             // 830
          //                                                                                                          // 831
          // However, we don't actually stick the _id onto the document yet,                                          // 832
          // because we want allow/deny rules to be able to differentiate                                             // 833
          // between arbitrary client-specified _id fields and merely                                                 // 834
          // client-controlled-via-randomSeed fields.                                                                 // 835
          var generatedId = null;                                                                                     // 836
          if (method === "insert" && !_.has(args[0], '_id')) {                                                        // 837
            generatedId = self._makeNewID();                                                                          // 838
          }                                                                                                           // 839
                                                                                                                      // 840
          if (this.isSimulation) {                                                                                    // 841
            // In a client simulation, you can do any mutation (even with a                                           // 842
            // complex selector).                                                                                     // 843
            if (generatedId !== null)                                                                                 // 844
              args[0]._id = generatedId;                                                                              // 845
            return self._collection[method].apply(                                                                    // 846
              self._collection, args);                                                                                // 847
          }                                                                                                           // 848
                                                                                                                      // 849
          // This is the server receiving a method call from the client.                                              // 850
                                                                                                                      // 851
          // We don't allow arbitrary selectors in mutations from the client: only                                    // 852
          // single-ID selectors.                                                                                     // 853
          if (method !== 'insert')                                                                                    // 854
            throwIfSelectorIsNotId(args[0], method);                                                                  // 855
                                                                                                                      // 856
          if (self._restricted) {                                                                                     // 857
            // short circuit if there is no way it will pass.                                                         // 858
            if (self._validators[method].allow.length === 0) {                                                        // 859
              throw new Meteor.Error(                                                                                 // 860
                403, "Access denied. No allow validators set on restricted " +                                        // 861
                  "collection for method '" + method + "'.");                                                         // 862
            }                                                                                                         // 863
                                                                                                                      // 864
            var validatedMethodName =                                                                                 // 865
                  '_validated' + method.charAt(0).toUpperCase() + method.slice(1);                                    // 866
            args.unshift(this.userId);                                                                                // 867
            method === 'insert' && args.push(generatedId);                                                            // 868
            return self[validatedMethodName].apply(self, args);                                                       // 869
          } else if (self._isInsecure()) {                                                                            // 870
            if (generatedId !== null)                                                                                 // 871
              args[0]._id = generatedId;                                                                              // 872
            // In insecure mode, allow any mutation (with a simple selector).                                         // 873
            // XXX This is kind of bogus.  Instead of blindly passing whatever                                        // 874
            //     we get from the network to this function, we should actually                                       // 875
            //     know the correct arguments for the function and pass just                                          // 876
            //     them.  For example, if you have an extraneous extra null                                           // 877
            //     argument and this is Mongo on the server, the .wrapAsync'd                                         // 878
            //     functions like update will get confused and pass the                                               // 879
            //     "fut.resolver()" in the wrong slot, where _update will never                                       // 880
            //     invoke it. Bam, broken DDP connection.  Probably should just                                       // 881
            //     take this whole method and write it three times, invoking                                          // 882
            //     helpers for the common code.                                                                       // 883
            return self._collection[method].apply(self._collection, args);                                            // 884
          } else {                                                                                                    // 885
            // In secure mode, if we haven't called allow or deny, then nothing                                       // 886
            // is permitted.                                                                                          // 887
            throw new Meteor.Error(403, "Access denied");                                                             // 888
          }                                                                                                           // 889
        } catch (e) {                                                                                                 // 890
          if (e.name === 'MongoError' || e.name === 'MinimongoError') {                                               // 891
            throw new Meteor.Error(409, e.toString());                                                                // 892
          } else {                                                                                                    // 893
            throw e;                                                                                                  // 894
          }                                                                                                           // 895
        }                                                                                                             // 896
      };                                                                                                              // 897
    });                                                                                                               // 898
    // Minimongo on the server gets no stubs; instead, by default                                                     // 899
    // it wait()s until its result is ready, yielding.                                                                // 900
    // This matches the behavior of macromongo on the server better.                                                  // 901
    // XXX see #MeteorServerNull                                                                                      // 902
    if (Meteor.isClient || self._connection === Meteor.server)                                                        // 903
      self._connection.methods(m);                                                                                    // 904
  }                                                                                                                   // 905
};                                                                                                                    // 906
                                                                                                                      // 907
                                                                                                                      // 908
Mongo.Collection.prototype._updateFetch = function (fields) {                                                         // 909
  var self = this;                                                                                                    // 910
                                                                                                                      // 911
  if (!self._validators.fetchAllFields) {                                                                             // 912
    if (fields) {                                                                                                     // 913
      self._validators.fetch = _.union(self._validators.fetch, fields);                                               // 914
    } else {                                                                                                          // 915
      self._validators.fetchAllFields = true;                                                                         // 916
      // clear fetch just to make sure we don't accidentally read it                                                  // 917
      self._validators.fetch = null;                                                                                  // 918
    }                                                                                                                 // 919
  }                                                                                                                   // 920
};                                                                                                                    // 921
                                                                                                                      // 922
Mongo.Collection.prototype._isInsecure = function () {                                                                // 923
  var self = this;                                                                                                    // 924
  if (self._insecure === undefined)                                                                                   // 925
    return !!Package.insecure;                                                                                        // 926
  return self._insecure;                                                                                              // 927
};                                                                                                                    // 928
                                                                                                                      // 929
var docToValidate = function (validator, doc, generatedId) {                                                          // 930
  var ret = doc;                                                                                                      // 931
  if (validator.transform) {                                                                                          // 932
    ret = EJSON.clone(doc);                                                                                           // 933
    // If you set a server-side transform on your collection, then you don't get                                      // 934
    // to tell the difference between "client specified the ID" and "server                                           // 935
    // generated the ID", because transforms expect to get _id.  If you want to                                       // 936
    // do that check, you can do it with a specific                                                                   // 937
    // `C.allow({insert: f, transform: null})` validator.                                                             // 938
    if (generatedId !== null) {                                                                                       // 939
      ret._id = generatedId;                                                                                          // 940
    }                                                                                                                 // 941
    ret = validator.transform(ret);                                                                                   // 942
  }                                                                                                                   // 943
  return ret;                                                                                                         // 944
};                                                                                                                    // 945
                                                                                                                      // 946
Mongo.Collection.prototype._validatedInsert = function (userId, doc,                                                  // 947
                                                         generatedId) {                                               // 948
  var self = this;                                                                                                    // 949
                                                                                                                      // 950
  // call user validators.                                                                                            // 951
  // Any deny returns true means denied.                                                                              // 952
  if (_.any(self._validators.insert.deny, function(validator) {                                                       // 953
    return validator(userId, docToValidate(validator, doc, generatedId));                                             // 954
  })) {                                                                                                               // 955
    throw new Meteor.Error(403, "Access denied");                                                                     // 956
  }                                                                                                                   // 957
  // Any allow returns true means proceed. Throw error if they all fail.                                              // 958
  if (_.all(self._validators.insert.allow, function(validator) {                                                      // 959
    return !validator(userId, docToValidate(validator, doc, generatedId));                                            // 960
  })) {                                                                                                               // 961
    throw new Meteor.Error(403, "Access denied");                                                                     // 962
  }                                                                                                                   // 963
                                                                                                                      // 964
  // If we generated an ID above, insert it now: after the validation, but                                            // 965
  // before actually inserting.                                                                                       // 966
  if (generatedId !== null)                                                                                           // 967
    doc._id = generatedId;                                                                                            // 968
                                                                                                                      // 969
  self._collection.insert.call(self._collection, doc);                                                                // 970
};                                                                                                                    // 971
                                                                                                                      // 972
var transformDoc = function (validator, doc) {                                                                        // 973
  if (validator.transform)                                                                                            // 974
    return validator.transform(doc);                                                                                  // 975
  return doc;                                                                                                         // 976
};                                                                                                                    // 977
                                                                                                                      // 978
// Simulate a mongo `update` operation while validating that the access                                               // 979
// control rules set by calls to `allow/deny` are satisfied. If all                                                   // 980
// pass, rewrite the mongo operation to use $in to set the list of                                                    // 981
// document ids to change ##ValidatedChange                                                                           // 982
Mongo.Collection.prototype._validatedUpdate = function(                                                               // 983
    userId, selector, mutator, options) {                                                                             // 984
  var self = this;                                                                                                    // 985
                                                                                                                      // 986
  check(mutator, Object);                                                                                             // 987
                                                                                                                      // 988
  options = _.clone(options) || {};                                                                                   // 989
                                                                                                                      // 990
  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))                                                        // 991
    throw new Error("validated update should be of a single ID");                                                     // 992
                                                                                                                      // 993
  // We don't support upserts because they don't fit nicely into allow/deny                                           // 994
  // rules.                                                                                                           // 995
  if (options.upsert)                                                                                                 // 996
    throw new Meteor.Error(403, "Access denied. Upserts not " +                                                       // 997
                           "allowed in a restricted collection.");                                                    // 998
                                                                                                                      // 999
  var noReplaceError = "Access denied. In a restricted collection you can only" +                                     // 1000
        " update documents, not replace them. Use a Mongo update operator, such " +                                   // 1001
        "as '$set'.";                                                                                                 // 1002
                                                                                                                      // 1003
  // compute modified fields                                                                                          // 1004
  var fields = [];                                                                                                    // 1005
  if (_.isEmpty(mutator)) {                                                                                           // 1006
    throw new Meteor.Error(403, noReplaceError);                                                                      // 1007
  }                                                                                                                   // 1008
  _.each(mutator, function (params, op) {                                                                             // 1009
    if (op.charAt(0) !== '$') {                                                                                       // 1010
      throw new Meteor.Error(403, noReplaceError);                                                                    // 1011
    } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {                                                               // 1012
      throw new Meteor.Error(                                                                                         // 1013
        403, "Access denied. Operator " + op + " not allowed in a restricted collection.");                           // 1014
    } else {                                                                                                          // 1015
      _.each(_.keys(params), function (field) {                                                                       // 1016
        // treat dotted fields as if they are replacing their                                                         // 1017
        // top-level part                                                                                             // 1018
        if (field.indexOf('.') !== -1)                                                                                // 1019
          field = field.substring(0, field.indexOf('.'));                                                             // 1020
                                                                                                                      // 1021
        // record the field we are trying to change                                                                   // 1022
        if (!_.contains(fields, field))                                                                               // 1023
          fields.push(field);                                                                                         // 1024
      });                                                                                                             // 1025
    }                                                                                                                 // 1026
  });                                                                                                                 // 1027
                                                                                                                      // 1028
  var findOptions = {transform: null};                                                                                // 1029
  if (!self._validators.fetchAllFields) {                                                                             // 1030
    findOptions.fields = {};                                                                                          // 1031
    _.each(self._validators.fetch, function(fieldName) {                                                              // 1032
      findOptions.fields[fieldName] = 1;                                                                              // 1033
    });                                                                                                               // 1034
  }                                                                                                                   // 1035
                                                                                                                      // 1036
  var doc = self._collection.findOne(selector, findOptions);                                                          // 1037
  if (!doc)  // none satisfied!                                                                                       // 1038
    return 0;                                                                                                         // 1039
                                                                                                                      // 1040
  // call user validators.                                                                                            // 1041
  // Any deny returns true means denied.                                                                              // 1042
  if (_.any(self._validators.update.deny, function(validator) {                                                       // 1043
    var factoriedDoc = transformDoc(validator, doc);                                                                  // 1044
    return validator(userId,                                                                                          // 1045
                     factoriedDoc,                                                                                    // 1046
                     fields,                                                                                          // 1047
                     mutator);                                                                                        // 1048
  })) {                                                                                                               // 1049
    throw new Meteor.Error(403, "Access denied");                                                                     // 1050
  }                                                                                                                   // 1051
  // Any allow returns true means proceed. Throw error if they all fail.                                              // 1052
  if (_.all(self._validators.update.allow, function(validator) {                                                      // 1053
    var factoriedDoc = transformDoc(validator, doc);                                                                  // 1054
    return !validator(userId,                                                                                         // 1055
                      factoriedDoc,                                                                                   // 1056
                      fields,                                                                                         // 1057
                      mutator);                                                                                       // 1058
  })) {                                                                                                               // 1059
    throw new Meteor.Error(403, "Access denied");                                                                     // 1060
  }                                                                                                                   // 1061
                                                                                                                      // 1062
  options._forbidReplace = true;                                                                                      // 1063
                                                                                                                      // 1064
  // Back when we supported arbitrary client-provided selectors, we actually                                          // 1065
  // rewrote the selector to include an _id clause before passing to Mongo to                                         // 1066
  // avoid races, but since selector is guaranteed to already just be an ID, we                                       // 1067
  // don't have to any more.                                                                                          // 1068
                                                                                                                      // 1069
  return self._collection.update.call(                                                                                // 1070
    self._collection, selector, mutator, options);                                                                    // 1071
};                                                                                                                    // 1072
                                                                                                                      // 1073
// Only allow these operations in validated updates. Specifically                                                     // 1074
// whitelist operations, rather than blacklist, so new complex                                                        // 1075
// operations that are added aren't automatically allowed. A complex                                                  // 1076
// operation is one that does more than just modify its target                                                        // 1077
// field. For now this contains all update operations except '$rename'.                                               // 1078
// http://docs.mongodb.org/manual/reference/operators/#update                                                         // 1079
var ALLOWED_UPDATE_OPERATIONS = {                                                                                     // 1080
  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,                                                 // 1081
  $pushAll:1, $push:1, $bit:1                                                                                         // 1082
};                                                                                                                    // 1083
                                                                                                                      // 1084
// Simulate a mongo `remove` operation while validating access control                                                // 1085
// rules. See #ValidatedChange                                                                                        // 1086
Mongo.Collection.prototype._validatedRemove = function(userId, selector) {                                            // 1087
  var self = this;                                                                                                    // 1088
                                                                                                                      // 1089
  var findOptions = {transform: null};                                                                                // 1090
  if (!self._validators.fetchAllFields) {                                                                             // 1091
    findOptions.fields = {};                                                                                          // 1092
    _.each(self._validators.fetch, function(fieldName) {                                                              // 1093
      findOptions.fields[fieldName] = 1;                                                                              // 1094
    });                                                                                                               // 1095
  }                                                                                                                   // 1096
                                                                                                                      // 1097
  var doc = self._collection.findOne(selector, findOptions);                                                          // 1098
  if (!doc)                                                                                                           // 1099
    return 0;                                                                                                         // 1100
                                                                                                                      // 1101
  // call user validators.                                                                                            // 1102
  // Any deny returns true means denied.                                                                              // 1103
  if (_.any(self._validators.remove.deny, function(validator) {                                                       // 1104
    return validator(userId, transformDoc(validator, doc));                                                           // 1105
  })) {                                                                                                               // 1106
    throw new Meteor.Error(403, "Access denied");                                                                     // 1107
  }                                                                                                                   // 1108
  // Any allow returns true means proceed. Throw error if they all fail.                                              // 1109
  if (_.all(self._validators.remove.allow, function(validator) {                                                      // 1110
    return !validator(userId, transformDoc(validator, doc));                                                          // 1111
  })) {                                                                                                               // 1112
    throw new Meteor.Error(403, "Access denied");                                                                     // 1113
  }                                                                                                                   // 1114
                                                                                                                      // 1115
  // Back when we supported arbitrary client-provided selectors, we actually                                          // 1116
  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to                                      // 1117
  // Mongo to avoid races, but since selector is guaranteed to already just be                                        // 1118
  // an ID, we don't have to any more.                                                                                // 1119
                                                                                                                      // 1120
  return self._collection.remove.call(self._collection, selector);                                                    // 1121
};                                                                                                                    // 1122
                                                                                                                      // 1123
/**                                                                                                                   // 1124
 * @deprecated in 0.9.1                                                                                               // 1125
 */                                                                                                                   // 1126
Meteor.Collection = Mongo.Collection;                                                                                 // 1127
                                                                                                                      // 1128
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.mongo = {
  Mongo: Mongo
};

})();
/* Imports for global scope */

Meteor = Package.meteor.Meteor;
Log = Package.logging.Log;
Tracker = Package.tracker.Tracker;
DDP = Package.ddp.DDP;
Mongo = Package.mongo.Mongo;
check = Package.check.check;
Match = Package.check.Match;
_ = Package.underscore._;
Random = Package.random.Random;
EJSON = Package.ejson.EJSON;
